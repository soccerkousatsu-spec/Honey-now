<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>HONEY NOW</title>

    <style>
/* ÂÖ®‰Ωì„É¨„Ç§„Ç¢„Ç¶„Éà */
body {
    margin: 0; padding: 0;
    background-color: #050505;
    color: #fff;
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    display: flex; flex-direction: column;
    position: fixed; width: 100%; height: 100svh;
    touch-action: none; -webkit-text-size-adjust: 100%;
    overflow: hidden; transition: background-color 0.5s ease;

    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none; 
}

/* „Çø„Ç§„Éà„É´ÁîªÈù¢„ÅÆ„É¨„Ç§„Ç¢„Ç¶„Éà */
#title-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: none;
    z-index: 200;
}

/* ËÉåÊôØÁîªÂÉèÂ∞ÇÁî®„ÅÆ„É¨„Ç§„É§„Éº */
.bg-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-image: url('bg_title.png');
    background-size: cover;
    background-position: center;
    z-index: -1;
}

/* „É≠„Ç¥„ÅÆË®≠ÂÆö */
#game-logo {
    width: 60%; max-width: 450px; height: auto;
    margin-bottom: 10px;
    animation: floating 3s ease-in-out infinite;
    filter: drop-shadow(0 10px 10px rgba(0,0,0,0.3));
}
@keyframes floating {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}

/* Ê≠ØËªä„Ç¢„Ç§„Ç≥„É≥ */
#gear-btn {
    position: absolute;
    top: max(20px, env(safe-area-inset-top));
    left: 20px;
    width: 50px; height: 50px;
    cursor: pointer;
    transition: transform 0.5s;
    filter: drop-shadow(0 2px 5px rgba(0,0,0,0.5));
    z-index: 10;
}
#gear-btn:hover { transform: rotate(180deg); }

/* „É°„Éã„É•„Éº„Éú„Çø„É≥Áæ§ */
.menu-container {
    display: flex; flex-direction: column;
    gap: 20px; width: 100%; align-items: center;
}

/* Êú®„ÅÆ„Éú„Çø„É≥ */
.wooden-btn {
    width: 240px; height: 90px;
    background-image: url('btn_wood.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    display: flex; justify-content: center; align-items: center;
    cursor: pointer; transition: transform 0.1s;
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.4));
}
.wooden-btn:active { transform: scale(0.95); }

.wooden-btn .btn-text {
    font-size: 32px; font-weight: 900; color: #fff;
    text-shadow: 2px 2px 0 #5d3a1a, -1px -1px 0 #5d3a1a, 0 0 10px rgba(0,0,0,0.5);
    font-family: 'Arial Black', sans-serif; letter-spacing: 2px;
    position: relative; top: -2px;
}
.wooden-btn.small { position: relative; width: 180px; height: 60px; margin-top: 15px;
left: 70px;}
.wooden-btn.small .btn-text { font-size: 24px; }

/* „É¢„Éº„ÉÄ„É´ÂÖ±ÈÄöË®≠ÂÆö */
.modal-overlay {
    display: none;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
    justify-content: center; align-items: center; z-index: 300;
}
.modal-overlay.active { display: flex; }

.modal-box {
    background: rgba(255, 255, 255, 0.95);
    padding: 30px; border-radius: 20px;
    width: 80%; max-width: 320px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 4px solid #ffd700; color: #333;
}
.modal-box h2 {
    margin: 0 0 20px 0; color: #ff8c00; font-weight: 900;
    font-size: 28px; letter-spacing: 2px; text-shadow: 2px 2px 0 #fff;
}
.modal-box label {
    display: block; text-align: left; font-weight: bold;
    margin-top: 15px; font-size: 14px; color: #666;
}
.modal-box input[type="text"] {
    width: 100%; padding: 10px; font-size: 18px;
    border: 2px solid #ccc; border-radius: 10px; margin-top: 5px;
    box-sizing: border-box; text-align: center;
    background: #f9f9f9; color: #333;
}
input[type=range] { width: 100%; margin: 10px 0 20px 0; cursor: pointer; }

.close-btn {
    background: #ff8c00; color: #fff; border: none;
    padding: 10px 30px; font-size: 18px; border-radius: 30px;
    font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #cc7000; margin-top: 10px;
}
.close-btn:active { transform: translateY(4px); box-shadow: none; }
.text-btn {
    background: none; border: none; color: #888;
    font-weight: bold; margin-top: 15px; cursor: pointer; text-decoration: underline;
}

/* „Éò„ÉÉ„ÉÄ„Éº„Éª„Ç≤„Éº„É†„Ç®„É™„Ç¢ */
header {
    padding: 20px; padding-top: max(40px, env(safe-area-inset-top));
    background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0));
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    pointer-events: none;
}
.score-board {
    display: flex; justify-content: center; align-items: flex-start;
    width: 100%; height: 60px; padding: 0 10px; box-sizing: border-box; position: relative;
}
.player-badge {
    position: absolute; top: 5px; z-index: 100;
    display: flex; flex-direction: column; justify-content: center;
    width: 85px; min-height: 40px; align-items: flex-start; text-align: left;
    padding: 5px 8px; border-radius: 6px; background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.3); backdrop-filter: blur(4px); transition: all 0.3s;
}
.player-badge.p1 { left: 0; box-shadow: 0 0 8px rgba(0, 204, 255, 0.2) inset; border-color: rgba(0, 204, 255, 0.4); }
.player-badge.p2 { right: 0; box-shadow: 0 0 8px rgba(255, 51, 102, 0.2) inset; border-color: rgba(255, 51, 102, 0.4); }
.badge-name { font-size: 13px; font-weight: 900; letter-spacing: 0.5px; width: 100%; word-break: break-word; line-height: 1.1; }
.badge-comment { font-size: 9px; color: #ccc; word-break: break-word; line-height: 1.2; opacity: 0.9; }

#turn-indicator { font-size: 40px; font-weight: 900; text-shadow: 0 0 20px currentColor; letter-spacing: 4px; line-height: 1; margin: 0 10px; }
#phase-badge { position: relative; left: 3px; height: 24px; line-height: 24px; margin-bottom: 5px; font-size: 16px; font-weight: 800; text-transform: uppercase; letter-spacing: 8px; opacity: 0.8; text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 100%; text-align: center; }
#card-info { position: relative; left: 5px; color: #ffd700; height: 40px; display: flex; align-items: center; justify-content: center; margin-top: 1px; }
#card-info svg { height: 100%; width: auto; fill: currentColor; }

#timer-display { position: absolute; top: 80px; right: 180px; font-size: 30px; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.8); font-family: 'Courier New', Courier, monospace; z-index: 100; transition: color 0.3s; }
#timer-display.danger { color: #ff3333; text-shadow: 0 0 15px #ff0000; animation: pulse 0.5s infinite alternate; }
@keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }

#game-area { flex: 1; position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden; }
canvas { filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5)); position: relative; top: -2px; }

footer { padding: 20px; padding-bottom: max(50px, env(safe-area-inset-bottom)); background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); display: flex; flex-direction: column; gap: 0; border-top: 1px solid rgba(255,255,255,0.1); }
#action-area { width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; }
#card-panel { width: 100%; display: flex; justify-content: center; gap: 15px; }
.card { background: linear-gradient(145deg, #2a2a2a, #333); border: 2px solid #555; color: #aaa; padding: 5px 0; width: 30%; display: flex; justify-content: center; align-items: center; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s; position: relative; z-index: 1;}
.card svg { height: 28px; width: auto; fill: currentColor; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); max-width: 95%; position: relative; left: 5px; }
.card.selected { border-color: #ffd700; background: linear-gradient(145deg, #ffd700, #ffaa00); color: #000; transform: translateY(-5px); box-shadow: 0 10px 15px rgba(255, 215, 0, 0.3); }

#main-btn { font-family: 'Arial Black', sans-serif; font-size: 24px; width: 100%; padding: 18px; background: linear-gradient(90deg, #ff8c00, #ff0080); color: #fff; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 4px 15px rgba(255, 0, 128, 0.4); transition: transform 0.1s; }
#main-btn:disabled { background: #444; color: #888; box-shadow: none; cursor: not-allowed; }
#main-btn:active { transform: scale(0.98); }

#result-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
#result-screen.show { opacity: 1; pointer-events: auto; }
.result-label { font-size: 24px; color: #fff; letter-spacing: 10px; margin-bottom: 10px; opacity: 0.8; }
#winner-name { font-size: 60px; font-weight: 900; text-shadow: 0 0 30px currentColor; letter-spacing: 5px; transform: scale(0.5); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
#result-screen.show #winner-name { transform: scale(1); }
.mode-btn { padding: 15px 40px; font-size: 20px; font-weight: bold; color: #fff; background: transparent; border: 2px solid #fff; border-radius: 50px; cursor: pointer; transition: all 0.2s; }

#quit-btn { position: absolute; top: max(10px, env(safe-area-inset-top)); left: 10px; z-index: 150; background: rgba(0, 0, 0, 0.5); color: rgba(255, 255, 255, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 20px; padding: 5px 15px; font-size: 14px; font-weight: bold; cursor: pointer; backdrop-filter: blur(4px); transition: all 0.2s; }
#title-screen[style*="flex"] ~ #quit-btn { display: none; }

#toast { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s; pointer-events: none; white-space: nowrap; border: 1px solid rgba(255,255,255,0.2); z-index: 400; }

#emote-container { position: fixed; bottom: 160px; right: 20px; z-index: 150; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: none; }
#emote-btn { pointer-events: auto; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #fff, #ddd); border: none; font-size: 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; transition: transform 0.1s; }
#emote-btn:active { transform: scale(0.9); }
#emote-menu { background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(5px); padding: 10px; border-radius: 15px; display: flex; flex-wrap: wrap; width: 140px; gap: 8px; justify-content: center; border: 1px solid rgba(255,255,255,0.2); opacity: 0; transform: scale(0.8) translateY(20px); pointer-events: none; transition: all 0.2s; }
#emote-menu.show { opacity: 1; transform: scale(1) translateY(0); pointer-events: auto; }
.emote-item { font-size: 28px; cursor: pointer; transition: transform 0.1s; user-select: none; }
.emote-item:hover { transform: scale(1.2); }

/* ÈñãÂßã„Ç´„ÉÉ„Éà„Ç§„É≥ */
#ready-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex; justify-content: center; align-items: center;
    z-index: 500; /* ÊúÄÂâçÈù¢„Å´ */
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
}
#ready-screen.active { opacity: 1; pointer-events: auto; }

.ready-content {
    text-align: center; transform: scale(0.8); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
#ready-screen.active .ready-content { transform: scale(1); }

.ready-label { font-size: 20px; color: #fff; letter-spacing: 5px; opacity: 0.8; margin-bottom: 10px; }
#player-role-text {
    font-size: 60px; font-weight: 900; letter-spacing: 5px; margin-bottom: 20px;
    text-shadow: 0 0 30px currentColor;
}
.vs-text { font-size: 30px; font-weight: bold; color: #888; margin-bottom: 10px; font-style: italic; }
#enemy-name-display { font-size: 40px; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }

/* --- „Ç¨„Ç§„ÉâÊºîÂá∫Áî® --- */
@keyframes attention-pulse {
    0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); transform: scale(1); }
    50% { box-shadow: 0 0 0 15px rgba(255, 215, 0, 0); transform: scale(1.05); }
    100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); transform: scale(1); }
}

/* „Ç´„Éº„Éâ„ÅåÊ≥®ÁõÆ„Åï„Çå„ÇãÊôÇ„ÅÆ„ÇØ„É©„Çπ */
.card.suggest-glow {
    animation: attention-pulse 1s ease-out infinite;
    border-color: #ffd700;
    z-index: 10;
}

    </style>
</head>
<body>

<div id="result-screen" style="display: none;">
    <div class="result-label">WINNER</div>
    <div id="winner-name">BLUE</div>
    <button class="mode-btn" onclick="backToTitle()" style="margin-top: 40px;">TITLE</button>
</div>

<button id="quit-btn" onclick="quitGame()">TOP</button>

<div id="title-screen">
    <div class="bg-layer"></div>

    <img src="icon_gear.png" id="gear-btn" onclick="openSettings()">

    <img src="logo.png" id="game-logo" alt="HONEY NOW">

    <div class="menu-container">
        <div class="wooden-btn" onclick="openSecretModal()">
            <span class="btn-text">ONLINE</span>
        </div>

        <div class="wooden-btn" onclick="startGame('PvE')">
            <span class="btn-text">CPU</span>
        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SETTINGS</h2>
            
            <label>NAME</label>
            <input type="text" id="username-input" placeholder="PLAYER" maxlength="6">
            
            <label>COMMENT</label>
            <input type="text" id="comment-input" placeholder="..." maxlength="30">
            
            <label>BGM VOLUME</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.1" oninput="changeVolume(this.value)">
            
            <button class="close-btn" onclick="closeSettings()">OK</button>
        </div>
    </div>

    <div id="secret-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SECRET WORD</h2>
            <p style="font-size:12px; margin-bottom:10px;">ÂêàË®ÄËëâ„ÇíÂÖ•Âäõ„Åó„Å¶„Å≠</p>
            
            <input type="text" id="room-input" placeholder="ENTER WORD" maxlength="10">
            
            <div class="wooden-btn small" onclick="startOnlineGame()">
                <span class="btn-text">GO!</span>
            </div>
            
            <button class="text-btn" onclick="closeSecretModal()">CANCEL</button>
        </div>
    </div>
</div>

<div id="ready-screen">
    <div class="ready-content">
        <div class="ready-label">YOU ARE</div>
        <div id="player-role-text">BLUE</div>
        <div class="vs-text">VS</div>
        <div id="enemy-name-display">CPU</div>
    </div>
</div>

<div id="waiting-modal" class="modal-overlay">
    <div class="modal-box">
        <h2>WAITING...</h2>
        <p style="font-size:14px; margin-bottom:5px;">ÂêàË®ÄËëâ</p>
        <div id="display-room-id" style="font-size:24px; font-weight:900; color:#00ccff; margin-bottom:20px; letter-spacing:2px;"></div>
        
        <div class="wooden-btn small" onclick="shareInviteLink()">
            <span class="btn-text" style="font-size:18px;">INVITE</span>
        </div>
        
        <button class="text-btn" onclick="cancelWait()">CANCEL</button>
    </div>
</div>

<header>
    <div class="score-board">
        <div class="player-badge p1">
            <div class="badge-name" id="p1-label">PLAYER</div>
            <div class="badge-comment" id="p1-comment">READY?</div>
        </div>
        
        <div id="turn-indicator">BLUE</div>
        
        <div class="player-badge p2">
            <div class="badge-name" id="p2-label">CPU</div>
            <div class="badge-comment" id="p2-comment">...</div>
        </div>
    </div>

    <div id="card-info"></div>
    <div id="phase-badge">PICK CARD</div>

    <div id="timer-display">30</div>
</header>

<div id="game-area">
    <canvas id="board"></canvas>
    <div id="toast"></div>
</div>

<div id="emote-container">
    <div id="emote-menu">
        <div class="emote-item" onclick="sendEmote('üòÄ')">üòÄ</div>
        <div class="emote-item" onclick="sendEmote('ü§î')">ü§î</div>
        <div class="emote-item" onclick="sendEmote('üò±')">üò±</div>
        <div class="emote-item" onclick="sendEmote('üòé')">üòé</div>
        <div class="emote-item" onclick="sendEmote('üëè')">üëè</div>
        <div class="emote-item" onclick="sendEmote('üò°')">üò°</div>
    </div>
    <button id="emote-btn" onclick="toggleEmoteMenu()">üí¨</button>
</div>

<footer>
    <div id="action-area">
        <div id="card-panel">
            <div class="card" onclick="uiSelectCard(2)">
                <svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
            
            <div class="card" onclick="uiSelectCard(3)">
                <svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>

            <div class="card" onclick="uiSelectCard(4)">
                <svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(61.96, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
        </div>

        <button id="main-btn" onclick="uiConfirm()" disabled>GO!</button>
    </div>
</footer>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
  import { getDatabase, ref, set, push, onValue, update, remove, get, child, onDisconnect, onChildAdded, off } 
  from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDswxDswxU_DU-DdhYI8KsANtVeYVP6NN4",
    authDomain: "honeynow-7fe79.firebaseapp.com",
    databaseURL: "https://honeynow-7fe79-default-rtdb.firebaseio.com",
    projectId: "honeynow-7fe79",
    storageBucket: "honeynow-7fe79.firebasestorage.app",
    messagingSenderId: "745229921816",
    appId: "1:745229921816:web:345524bda3da61f8c7dd6d",
    measurementId: "G-RTEVBEYH3M"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);

const BOARD_RADIUS = 3;
const bgm = new Audio('bgm.mp3');
bgm.loop = true;
bgm.volume = 0.1;

const COLORS = {
    p1: '#00ccff', p1Bg: '#001a33',
    p2: '#ff3366', p2Bg: '#2a0a12',
    hex: '#222', hexEdge: '#333',
    damageZone: 'rgba(255, 50, 50, 0.2)', damageStroke: '#ff3333',
    previewLine: 'rgba(255, 255, 0, 0.8)', guideMarker: 'rgba(255, 255, 255, 0.3)'
};

const P1 = { id: 1, name: 'BLUE', color: COLORS.p1, bg: COLORS.p1Bg };
const P2 = { id: 2, name: 'RED', color: COLORS.p2, bg: COLORS.p2Bg };
const DIRECTIONS = [{dq:1,dr:0}, {dq:1,dr:-1}, {dq:0,dr:-1}, {dq:-1,dr:0}, {dq:-1,dr:1}, {dq:0,dr:1}];

let state = {
    gameMode: null,
    turn: 1,
    turnPlayer: P1,
    phase: 'TITLE', 
    hexes: [],
    units: [],
    selectedCard: null,
    tempRotationStart: null,
    validDirections: [], 
    hiddenRotation: null,
    defenderMoves: [],
    selectedUnit: null,
    winner: null,
    frameCount: 0,
    isCpuThinking: false,
    emotes: [],
    damageEffects: [],
    timeLeft: 30,
    timerInterval: null,
    lastEmoteTime: 0,
    previewRotation: null,
    showUnitGuidance: false

};

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
let HEX_SIZE = 30;

// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// 1„Å§ÁõÆ„ÅÆË¶ÅÊ≥®ÊÑèÁÆáÊâÄ: startGame
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
function startGame(mode) {
    state.gameMode = mode;
    
    if (bgm.paused) {
        bgm.play().catch(e => console.log("BGMÂÜçÁîü„Ç®„É©„Éº:", e));
    }

    const inputName = document.getElementById('username-input').value.trim();
    const inputComment = document.getElementById('comment-input').value.trim();

    const p1Name = inputName || (mode === 'PvE' ? "PLAYER" : "P1");
    const p1Comment = inputComment || "..."; 
    const p2Name = mode === 'PvE' ? "CPU" : "P2";
    const p2Comment = "..."; 

    document.getElementById('title-screen').style.display = 'none';

    const myColorName = "BLUE";
    const myColorCode = COLORS.p1;
    const enemyName = p2Name;

    playStartAnimation(myColorName, myColorCode, enemyName, () => {
        
        document.getElementById('p1-label').innerText = p1Name;
        document.getElementById('p1-comment').innerText = p1Comment;
        document.getElementById('p2-label').innerText = p2Name;
        document.getElementById('p2-comment').innerText = p2Comment;

        initBoardUnits();
        state.turn = 1;
        state.turnPlayer = P1;
        state.turnPlayer.nameDisplay = p1Name; 
        state.phase = 'SELECT_CARD';
        state.winner = null;
        state.isCpuThinking = false;

        updateTurnVisuals();
        showToast("GAME START!");
        
        triggerPhaseGuidance(); 
        
        resizeCanvas();
        gameLoop();

        resetTimer(); 
    });
} // startGame ÁµÇ‰∫Ü

function playStartAnimation(myColorName, myColorCode, enemyName, callback) {
    const screen = document.getElementById('ready-screen');
    const roleText = document.getElementById('player-role-text');
    const enemyText = document.getElementById('enemy-name-display');

    roleText.innerText = myColorName;
    roleText.style.color = myColorCode;
    enemyText.innerText = enemyName;

    screen.classList.add('active');

    setTimeout(() => {
        screen.classList.remove('active');
        if (callback) callback();
    }, 2000);
}

function initBoardUnits() {
    state.hexes = [];
    for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        let r1 = Math.max(-BOARD_RADIUS, -q - BOARD_RADIUS);
        let r2 = Math.min(BOARD_RADIUS, -q + BOARD_RADIUS);
        for (let r = r1; r <= r2; r++) {
            const dist = (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
            const isEdge = dist === BOARD_RADIUS;
            
            const isCorner = (Math.abs(q) === BOARD_RADIUS && r === 0) ||
                             (Math.abs(r) === BOARD_RADIUS && q === 0) ||
                             (Math.abs(q) === BOARD_RADIUS && r === -q);

            state.hexes.push({ q, r, isEdge, isCorner });
        }
    }
    const initialPositions = [
        { q: 2, r: 0, owner: 1 }, { q: 0, r: 2, owner: 2 },
        { q: -2, r: 2, owner: 1 }, { q: -2, r: 0, owner: 2 },
        { q: 0, r: -2, owner: 1 }, { q: 2, r: -2, owner: 2 }
    ];
    state.units = [];
    initialPositions.forEach((pos, i) => {
        state.units.push({
            id: `u${i}`, owner: pos.owner, q: pos.q, r: pos.r, hp: 1000,
            animQ: pos.q, animR: pos.r
        });
    });
}

function gameLoop() {
    state.frameCount++;
    state.units.forEach(u => {
        u.animQ += (u.q - u.animQ) * 0.2;
        u.animR += (u.r - u.animR) * 0.2;
    });
    draw();
    if (!state.winner) requestAnimationFrame(gameLoop);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    state.hexes.forEach(h => {
        const {x, y} = hexToPixel(h.q, h.r);
        let color = COLORS.hex;
        let stroke = COLORS.hexEdge;
        let lineWidth = 1;
        if (h.isEdge) { stroke = COLORS.damageStroke; lineWidth = 2; }
        if (state.hiddenRotation && state.phase === 'ANIMATION' && state.hiddenRotation.indices.includes(getHexIndex(h.q, h.r))) {
             color = '#444';
        }
        drawHex(x, y, HEX_SIZE * 0.95, color, stroke, lineWidth);
        
        if (state.phase === 'DEFENDER_MOVE' && state.selectedUnit && !state.isCpuThinking) {
            if (!getUnitAt(h.q, h.r)) {
                ctx.beginPath(); ctx.arc(x, y, HEX_SIZE * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.guideMarker; ctx.fill();
            }
        }
    });

    if (state.phase === 'SELECT_ROTATION') {
        if (state.tempRotationStart) {
            const startPos = hexToPixel(state.tempRotationStart.q, state.tempRotationStart.r);
            drawHex(startPos.x, startPos.y, HEX_SIZE * 0.9, '#ffd700', '#fff', 3);
            
            state.validDirections.forEach(dirObj => {
                dirObj.indices.forEach(idx => {
                    if(state.hexes[idx] === state.tempRotationStart) return;
                    const h = state.hexes[idx];
                    const p = hexToPixel(h.q, h.r);
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    drawHex(p.x, p.y, HEX_SIZE * 0.85, '#ffd700', null, 0); 
                    ctx.restore();
                });
                const lastIdx = dirObj.indices[dirObj.indices.length - 1];
                const lastHex = state.hexes[lastIdx];
                const endP = hexToPixel(lastHex.q, lastHex.r);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath(); ctx.arc(endP.x, endP.y, 4, 0, Math.PI*2); ctx.fill();
            });
        }

        if (state.previewRotation) {
            const indices = state.previewRotation.indices;
            indices.forEach(idx => {
                const h = state.hexes[idx];
                const p = hexToPixel(h.q, h.r);
                ctx.save();
                ctx.shadowColor = "#fff";
                ctx.shadowBlur = 20;
                drawHex(p.x, p.y, HEX_SIZE * 0.9, 'rgba(255, 255, 200, 0.8)', '#fff', 4);
                ctx.restore();
            });
        }
    }

    [1, 2].forEach(ownerId => {
        const myUnits = state.units.filter(u => u.owner === ownerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.animQ, u.animR));
            const isEq = isEquilateral(pts[0], pts[1], pts[2]);
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y); ctx.lineTo(pts[2].x, pts[2].y); ctx.closePath();
            const color = ownerId === 1 ? COLORS.p1 : COLORS.p2;
            if (isEq) {
                ctx.strokeStyle = color; ctx.lineWidth = 4;
                ctx.shadowColor = color; ctx.shadowBlur = 20; ctx.stroke();
                ctx.fillStyle = color + '22'; ctx.fill();
            } else {
                ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.shadowBlur = 0; ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }
    });

    state.units.forEach(u => {
        const {x, y} = hexToPixel(u.animQ, u.animR);
        let color = u.owner === 1 ? COLORS.p1 : COLORS.p2;
        
        if (u.hitFlash > 0) {
             color = '#fff'; 
             u.hitFlash--;
        }

        const move = state.defenderMoves.find(m => m.unitId === u.id);
        if (move) {
            const destHex = state.hexes[move.toIndex];
            const destPos = hexToPixel(destHex.q, destHex.r);
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(destPos.x, destPos.y);
            ctx.strokeStyle = '#fff'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        let size = HEX_SIZE * 0.7; let stroke = '#fff'; let lw = 2;
        if (state.selectedUnit && state.selectedUnit.id === u.id) {
            size *= 1.1; stroke = '#ffd700'; lw = 4;
            ctx.beginPath(); ctx.arc(x, y, HEX_SIZE, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke();
        }
        drawHex(x, y, size, color, stroke, lw);
        const hpPct = u.hp / 1000;
        ctx.fillStyle = '#000'; ctx.fillRect(x - 15, y - 5, 30, 4);
        ctx.fillStyle = hpPct > 0.5 ? '#0f0' : '#f00'; ctx.fillRect(x - 15, y - 5, 30 * Math.max(0, hpPct), 4);
    });
    
    // ... (Êó¢Â≠ò„ÅÆÊèèÁîªÂá¶ÁêÜ) ...

    // ‚òÖ‚òÖ‚òÖ ËøΩÂä†ÔºöÁßªÂãï„Éï„Çß„Éº„Ç∫„ÅÆ„Ç¨„Ç§„ÉâË°®Á§∫ÔºàÈßí„Åå„Éù„ÉØ„ÉØ„Éº„É≥„Å®ÂÖâ„ÇãÔºâ ‚òÖ‚òÖ‚òÖ
    if (state.showUnitGuidance && state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1; 
        
        // ‚òÖËøΩÂä†: ÁµåÈÅéÊôÇÈñì„ÇíË®àÁÆó„Åó„Å¶„ÄÅ„Åò„ÇèÔΩû„Å£„Å®Ê∂à„Åô
        const elapsed = Date.now() - (state.guidanceStartTime || 0);
        const duration = 3000; // 3Áßí„Åã„Åë„Å¶Ê∂à„Åà„Çã
        
        if (elapsed > duration) {
            state.showUnitGuidance = false; // ÊôÇÈñìÂàá„Çå„Åß„Ç™„Éï
            return;
        }

        // „Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÁéáÔºà1.0 ‚Üí 0.0Ôºâ
        const fade = Math.pow(1.0 - (elapsed / duration), 2); 

        // Ëº™„Å£„Åã„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        const pulse = (Date.now() % 1000) / 1000; 
        const radius = HEX_SIZE * (1.0 + pulse * 0.8);
        const alpha = (1.0 - pulse) * fade; // ‚òÖÂ§âÊõ¥: „Éï„Çß„Éº„ÉâÁéá„ÇíÊéõ„ÅëÁÆó

        state.units.forEach(u => {
            if (u.owner === defenderId) {
                const {x, y} = hexToPixel(u.animQ, u.animR);
                
                // ÂÖâ„ÇãËº™„Å£„Åã
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`; // ‚òÖalphaÈÅ©Áî®
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Êú¨‰Ωì„ÇÇÂ∞ë„ÅóÂÖâ„Çâ„Åõ„ÇãÔºà„Åì„Åì„ÇÇfade„Çí„Åã„Åë„Å¶Ëá™ÁÑ∂„Å´Ê∂à„ÅôÔºâ
                ctx.beginPath();
                ctx.arc(x, y, HEX_SIZE, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.8 * fade})`; // ‚òÖfadeÈÅ©Áî®
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });
    }

    drawEmotes();
}

function addDamageEffect(unit, damage) {
    unit.hitFlash = 10; 
}

function drawHex(x, y, size, fill, stroke, lw) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = 2 * Math.PI / 6 * i + Math.PI/6;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}
function drawArrowHead(x, y) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill(); }

function updateTurnVisuals() {
    const p = state.turnPlayer;
    document.body.style.backgroundColor = p.bg;
    
    const indicator = document.getElementById('turn-indicator');
    const badge = document.getElementById('phase-badge');
    const cardPanel = document.getElementById('card-panel');
    const mainBtn = document.getElementById('main-btn');

    indicator.innerText = p.name; 
    indicator.style.color = p.color;

    // ‚òÖËøΩÂä†: Ëá™ÂàÜ„ÅÆÊìç‰Ωú„Çø„Éº„É≥„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
    let isMyTurn = false;
    if (state.gameMode === 'PvE') {
        isMyTurn = (p.id === 1); // PvE„Å™„ÇâP1„ÅåËá™ÂàÜ
    } else if (state.gameMode === 'ONLINE') {
        isMyTurn = (p.id === myPlayerId); // Online„Å™„ÇâID„ÅßÂà§ÂÆö
    } else {
        isMyTurn = true; // TitleÁîªÈù¢„Å™„Å©
    }

    if (state.isCpuThinking) {
        cardPanel.style.pointerEvents = 'none';
        mainBtn.disabled = true;
        badge.innerText = "WAIT"; 
        badge.style.color = "#aaa";
        
        // CPUÊÄùËÄÉ‰∏≠„ÅØ„Ç´„Éº„Éâ„Éë„Éç„É´„ÇíÈö†„Åô
        if (state.phase === 'SELECT_CARD') cardPanel.style.display = 'none';
        return;
    }
    
    else if (state.phase === 'TURN_CUTIN') {
        badge.innerText = "";
        cardPanel.style.display = 'none'; // „Ç´„ÉÉ„Éà„Ç§„É≥‰∏≠„ÅØÊìç‰Ωú„Éë„Éç„É´„ÇíÊ∂à„Åô
        mainBtn.style.display = 'none';
        return; // „Åì„Çå‰ª•‰∏ä„ÅÆÂá¶ÁêÜ„ÅØ„Åó„Å™„ÅÑ
    }

cardPanel.style.pointerEvents = 'auto';

    if (state.phase === 'SELECT_CARD') {
        // ‚òÖ‰øÆÊ≠£: Ëá™ÂàÜ„ÅÆ„Çø„Éº„É≥„ÅÆÊôÇ„Å†„Åë„Éë„Éç„É´„ÇíÂá∫„Åô
        if (isMyTurn) {
            badge.innerText = "PICK CARD";
            badge.style.color = "#fff";
            cardPanel.style.display = 'flex';
        } else {
            badge.innerText = "OPPONENT TURN";
            badge.style.color = "#888";
            cardPanel.style.display = 'none'; // Áõ∏Êâã„Çø„Éº„É≥„ÅØÈö†„Åô
        }
        mainBtn.style.display = 'none';
        
    } else if (state.phase === 'SELECT_ROTATION') {
        badge.innerText = ""; // ‚òÖ‰øÆÊ≠£: "AIMING" „ÇíÂâäÈô§ÔºàÁ©∫ÊñáÂ≠ó„Å´Ôºâ
        badge.style.color = "#fff";

        if (state.previewRotation) {
            cardPanel.style.display = 'none';
            mainBtn.style.display = 'block';
            mainBtn.disabled = false;
            mainBtn.innerText = "OK";
        } else {
            // ÂõûËª¢Ëª∏„ÇíÈÅ∏„Çì„Åß„ÅÑ„ÇãÊúÄ‰∏≠„ÇÇ„ÄÅËá™ÂàÜ„ÅÆ„Çø„Éº„É≥„Åß„Å™„Åë„Çå„Å∞Èö†„Åô
            cardPanel.style.display = isMyTurn ? 'flex' : 'none';
            mainBtn.style.display = 'none';
        }
        
    } else if (state.phase === 'DEFENDER_MOVE') {
        badge.innerText = "MOVE"; 
        badge.style.color = "#fff"; // ‚òÖ‰øÆÊ≠£: Ëµ§(#ff3333) „Åã„Çâ ÁôΩ(#fff) „Å´Â§âÊõ¥„Åó„Å¶ÂÆâÂøÉÊÑü„ÇíÂá∫„Åô

        cardPanel.style.display = 'none'; mainBtn.style.display = 'block';
        
        const defender = state.turnPlayer.id === 1 ? P2 : P1;
        mainBtn.innerText = "GO";
        mainBtn.disabled = false;
        
        indicator.innerText = defender.name;
        indicator.style.color = defender.color;
        document.body.style.backgroundColor = defender.bg;
        
    } else {
        badge.innerText = "";
    }
}

async function triggerCpuAction() {
    if (state.gameMode !== 'PvE' || state.winner) return;
    
    const isCpuAttacker = (state.turnPlayer.id === 2);
    const isCpuDefender = (state.turnPlayer.id === 1 && state.phase === 'DEFENDER_MOVE');

    if (!isCpuAttacker && !isCpuDefender) return;

    state.isCpuThinking = true;
    updateTurnVisuals();

    await wait(1000);

    if (state.phase === 'SELECT_CARD') {
        const bestAction = aiFindBestCardAction();
        const choice = bestAction.cardLen;
        uiSelectCard(choice, true);
        showToast(`CPU SELECT: ${choice}ÈÄ£`);
        await wait(1500);
        
        if (bestAction.indices) {
            state.hiddenRotation = { indices: bestAction.indices };
            state.phase = 'DEFENDER_MOVE';
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("CPU„ÅåÂõûËª¢„Çí„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü");
            updateTurnVisuals();	
            triggerPhaseGuidance(); 
        } else {

            const cards = [2,3,4];
            uiSelectCard(cards[0], true);
        }
    } 
    else if (state.phase === 'DEFENDER_MOVE') {
        let move1 = aiFindBestMove();
        if (move1) {
            state.defenderMoves.push({ unitId: move1.unitId, toIndex: move1.toIndex });
            
            const u = state.units.find(u => u.id === move1.unitId);
            const originalQ = u.q; const originalR = u.r;
            const targetHex = state.hexes[move1.toIndex];
            u.q = targetHex.q; u.r = targetHex.r;

            let move2 = aiFindBestMove(move1.unitId);
            if (move2) {
                state.defenderMoves.push({ unitId: move2.unitId, toIndex: move2.toIndex });
            }
            u.q = originalQ; u.r = originalR;
        }

        showToast("CPU„ÅåÁßªÂãï„Åó„Åæ„Åó„Åü");
        await wait(500);
        startTurnResolution();
    }

    state.isCpuThinking = false;
    updateTurnVisuals();
}

function uiSelectCard(len, fromCpu = false) {
    if (state.isCpuThinking && !fromCpu) return;
    
    if (state.gameMode === 'ONLINE' && !fromCpu) {
        sendAction('SELECT_CARD', { value: len });
    }

    state.selectedCard = len;
    
    const svgs = {
        2: `<svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        3: `<svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        4: `<svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(61.96, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`
    };
    document.getElementById('card-info').innerHTML = svgs[len];

    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.card')[len-2].classList.add('selected');
    
    state.phase = 'SELECT_ROTATION';
    state.tempRotationStart = null;
    state.validDirections = [];
    state.previewRotation = null; 
    
    if (!fromCpu) {
        showToast("Ëª∏„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ");
    }
    updateTurnVisuals();
    
    if (!fromCpu && state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}

async function uiConfirm() {
    if (state.isCpuThinking) return;
     clearInterval(state.timerInterval);

    if (state.gameMode === 'ONLINE') {
        const isMyPhase = 
            (state.phase === 'DEFENDER_MOVE' && (state.turnPlayer.id === 1 ? 2 : 1) === myPlayerId) ||
            (state.phase === 'SELECT_ROTATION' && state.turnPlayer.id === myPlayerId);
        
        if (!isMyPhase) return;
    }

    if (state.phase === 'SELECT_ROTATION' && state.previewRotation) {
        state.hiddenRotation = state.previewRotation;

        if (state.gameMode === 'ONLINE') {
            sendAction('ROTATE', { indices: state.hiddenRotation.indices });
        }

        state.previewRotation = null;
        state.tempRotationStart = null;
        state.validDirections = [];

        // 1. ‰∏ÄÊó¶ UI „ÇíÊ∂à„Åó„Å¶„ÄåÈñì„Äç„É¢„Éº„Éâ„Å´„Åô„Çã
        const prevPhase = state.phase; // Âøµ„ÅÆ„Åü„ÇÅ
        state.phase = 'TURN_CUTIN';    // „Åì„Çå„Åß updateTurnVisuals „Åå UI „ÇíÊ∂à„Åô
        updateTurnVisuals();

        // 2. 1ÁßíÂæÖ„Å§Ôºà„Çø„Éº„É≥Âàá„ÇäÊõø„Åà„Å®Âêå„ÅòÊºîÂá∫Ôºâ
        await playTurnCutIn(state.turnPlayer);

        if (state.phase !== 'TURN_CUTIN') {
            return;
        }

        state.phase = 'DEFENDER_MOVE';
        updateTurnVisuals();
        showToast("ÁßªÂãï„Éï„Çß„Éº„Ç∫");
        resetTimer();


        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        const isMyDefender = (state.gameMode === 'ONLINE') ? (defenderId === myPlayerId) : (state.gameMode === 'PvE' ? defenderId === 1 : true);

        if (isMyDefender) {
            triggerPhaseGuidance();
        }

        if (state.gameMode === 'PvE') triggerCpuAction();
        return;
    }

    if (state.phase === 'DEFENDER_MOVE') {
        if (state.gameMode === 'ONLINE') {
            sendAction('MOVE', { moves: state.defenderMoves });
        }
        startTurnResolution();
    }
}

// ‚òÖ Êñ∞Ë¶èËøΩÂä†Ê©üËÉΩ
async function triggerPhaseGuidance() {
    // 1. UI„ÅåË°®Á§∫„Åï„Çå„Å¶„Åã„Çâ„Äå‰∏ÄÂëºÂê∏Ôºà0.5ÁßíÔºâ„ÄçÂæÖ„Å§
    await wait(500);

    // 2. „Éï„Çß„Éº„Ç∫„Å´Âêà„Çè„Åõ„Å¶ÂÖâ„Çâ„Åõ„Çã
    if (state.phase === 'SELECT_CARD') {
        // „Ç´„Éº„Éâ„ÇíÂÖ®ÈÉ®ÂÖâ„Çâ„Åõ„Çã
        const cards = document.querySelectorAll('.card');
        cards.forEach(c => c.classList.add('suggest-glow'));
        
        // 3ÁßíÂæå„Å´Ê∂à„ÅôÔºàÈßí„ÅÆ„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÊôÇÈñì„Å´Âêà„Çè„Åõ„ÇãÔºâ
        setTimeout(() => {
            cards.forEach(c => c.classList.remove('suggest-glow'));
        }, 3000);

    } else if (state.phase === 'DEFENDER_MOVE') {
        // Èßí„ÇíÂÖâ„Çâ„Åõ„Çã„Éï„É©„Ç∞ON
        state.showUnitGuidance = true;
        
        // ‚òÖ‚òÖ‚òÖ ËøΩÂä†Ôºö‰ªä„Åì„ÅÆÁû¨Èñì„Çí„ÄåÈñãÂßãÊôÇÈñì„Äç„Å®„Åó„Å¶Ë®òÈå≤„Åô„Çã ‚òÖ‚òÖ‚òÖ
        state.guidanceStartTime = Date.now(); 
    }

}


function handleInput(x, y) {
    // TURN_CUTIN „ÇíËøΩÂä†
    if (state.phase === 'TITLE' || state.phase === 'ANIMATION' || state.phase === 'TURN_CUTIN' || state.winner || state.isCpuThinking) return;

    if (state.gameMode === 'ONLINE') {
        if (state.phase === 'DEFENDER_MOVE') {
            const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
            if (defenderId !== myPlayerId) return;
        } else {
            if (state.turnPlayer.id !== myPlayerId) return;
        }
    }

    const coords = pixelToHex(x, y);
    const hexIndex = getHexIndex(coords.q, coords.r);
    
    // ‚ñ† ‰øÆÊ≠£ÁÇπ1ÔºöËÉåÊôØÔºàÁõ§Èù¢Â§ñÔºâ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÊôÇ„ÅÆ„Ç≠„É£„É≥„Çª„É´Âá¶ÁêÜ„ÇíËøΩÂä†
    if (hexIndex === -1) {
        if (state.phase === 'SELECT_ROTATION' && state.tempRotationStart) {
            state.previewRotation = null;
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü");
            updateTurnVisuals();
        }
        return;
    }

    const clickedHex = state.hexes[hexIndex];

    if (state.phase === 'SELECT_ROTATION') {
        if (!state.tempRotationStart) {
            // „Åæ„Å†Ëª∏„ÅåÊ±∫„Åæ„Å£„Å¶„ÅÑ„Å™„ÅÑÊôÇÔºàÊúÄÂàù„ÅÆ„Çø„ÉÉ„ÉóÔºâ
            state.tempRotationStart = clickedHex;
            calcValidDirections(clickedHex);
            if (state.validDirections.length === 0) {
                showToast("ÂõûËª¢‰∏çÂèØ"); 
                state.tempRotationStart = null;
            }
        
        } else {
            // Ëª∏„Åå„Åô„Åß„Å´Ê±∫„Åæ„Å£„Å¶„ÅÑ„ÇãÊôÇÔºà2ÂõûÁõÆ„ÅÆ„Çø„ÉÉ„ÉóÔºâ
            
            // ‚ñ† ‰øÆÊ≠£ÁÇπ2ÔºöËª∏Ôºà‰∏≠ÂøÉÔºâ„Çí„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Çø„ÉÉ„Éó„Åó„Åü„Çâ„Ç≠„É£„É≥„Çª„É´„Åô„Çã
            if (state.tempRotationStart === clickedHex) {
                state.previewRotation = null;
                state.tempRotationStart = null;
                state.validDirections = [];
                showToast("„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü");
                updateTurnVisuals();
                return;
            }

            const clickedIndex = getHexIndex(clickedHex.q, clickedHex.r);
            const valid = state.validDirections.find(v => v.indices.includes(clickedIndex));

            if (valid) {
                state.previewRotation = { indices: valid.indices };
                showToast("OK„Éú„Çø„É≥„ÅßÁ¢∫ÂÆö");
                updateTurnVisuals(); 
            } 
            else {
                // ÂÖ®„ÅèÈñ¢‰øÇ„Å™„ÅÑ„Éû„Çπ„Çí„Çø„ÉÉ„Éó„Åó„ÅüÊôÇ„ÅÆ„Ç≠„É£„É≥„Çª„É´
                state.previewRotation = null;
                state.tempRotationStart = null;
                state.validDirections = [];
                showToast("„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü");
                updateTurnVisuals();
            }
        }
    }

    else if (state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (state.gameMode === 'PvE' && defenderId === 2) return;

        const unit = getUnitAt(clickedHex.q, clickedHex.r);
        
        if (unit && unit.owner === defenderId) {
            if (state.selectedUnit === unit) {
                state.selectedUnit = null; 
            } else {
                state.selectedUnit = unit; 
            }
            if (state.defenderMoves.find(m => m.unitId === unit.id)) {
                state.defenderMoves = state.defenderMoves.filter(m => m.unitId !== unit.id);
            }
            updateTurnVisuals();

        } else if (state.selectedUnit && !unit) {
            const isReserved = state.defenderMoves.find(m => m.toIndex === hexIndex);
            if (isReserved) {
                showToast("Êó¢„Å´ÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åô");
                return;
            }
            if (state.defenderMoves.length >= 2) {
                showToast("ÁßªÂãï„Åß„Åç„Çã„ÅÆ„ÅØ2‰Ωì„Åæ„ÅßÔºÅ");
                return;
            }

            state.defenderMoves.push({ unitId: state.selectedUnit.id, toIndex: hexIndex });
            state.selectedUnit = null; 
            updateTurnVisuals();
        }
    }
}

async function startTurnResolution() {
    state.phase = 'ANIMATION';
    updateTurnVisuals();

    try {
        for (let m of state.defenderMoves) {
            const u = state.units.find(u => u.id === m.unitId);
            if (!u) continue; 
            if (m.toIndex >= 0 && m.toIndex < state.hexes.length) {
                const target = state.hexes[m.toIndex];
                u.q = target.q; u.r = target.r;
            }
        }
        state.defenderMoves = [];
        await wait(800);

        if (state.hiddenRotation && state.hiddenRotation.indices) {
            const indices = state.hiddenRotation.indices;
            showToast("ROTATION!");
            await wait(500);
            
            let unitsOnLine = [];
            indices.forEach((hexIdx, linePos) => {
                if (!state.hexes[hexIdx]) return; 
                const h = state.hexes[hexIdx];
                const u = getUnitAt(h.q, h.r);
                if(u) unitsOnLine.push({ u, linePos });
            });
            
            const len = indices.length;
            unitsOnLine.forEach(item => {
                let nextLinePos = (len - 1) - item.linePos;
                if (indices[nextLinePos] !== undefined && state.hexes[indices[nextLinePos]]) {
                    let nextHex = state.hexes[indices[nextLinePos]];
                    item.u.q = nextHex.q; item.u.r = nextHex.r;
                }
            });
            await wait(1000);
        }

        state.units.forEach(u => {
            const idx = getHexIndex(u.q, u.r);
            if (idx === -1) return;
            const h = state.hexes[idx];
            let damage = 0;
            if (h.isCorner) damage = 250;
            else if (h.isEdge) damage = 100;

            if (damage > 0) {
                u.hp -= damage;
                addDamageEffect(u, damage);
            }
        });

        [1, 2].forEach(attackerId => {
            const myUnits = state.units.filter(u => u.owner === attackerId);
            if (myUnits.length === 3) {
                const pts = myUnits.map(u => hexToPixel(u.q, u.r));
                if (isEquilateral(pts[0], pts[1], pts[2])) {
                    const defenderId = attackerId === 1 ? 2 : 1;
                    state.units.filter(u => u.owner === defenderId).forEach(target => {
                        const ratio = getTriangleOverlapRatio(target, pts[0], pts[1], pts[2]);
                        if (ratio > 0.01) { 
                            const dmg = Math.floor(350 * ratio);
                            target.hp -= dmg;
                            addDamageEffect(target, dmg);
                        }
                    });
                }
            }
        });
        
        await wait(1500);

        const p1Lose = state.units.some(u => u.owner === 1 && u.hp <= 0);
        const p2Lose = state.units.some(u => u.owner === 2 && u.hp <= 0);
        
        if (p1Lose || p2Lose) {
            state.winner = p1Lose && p2Lose ? "DRAW" : (p1Lose ? "RED" : "BLUE");
            showResult(state.winner);
        } else {
            nextTurn();
        }

    } catch (error) {
        console.error("ÈáçÂ§ß„Å™„Ç®„É©„Éº:", error);
        showToast("ERROR RECOVERED");
        nextTurn(); 
    }
}

async function nextTurn() {
 clearInterval(state.timerInterval);

    // 1. „Éó„É¨„Ç§„É§„Éº„ÅÆÂàá„ÇäÊõø„ÅàÔºàÂÜÖÈÉ®„Éá„Éº„ÇøÊõ¥Êñ∞Ôºâ„ÅØÂøÖ„ÅöÂÖà„Å´„ÇÑ„Çã
    state.turnPlayer = state.turnPlayer.id === 1 ? P2 : P1;
    if (state.turnPlayer.id === 1) state.turn++;

    // ‚òÖ‚òÖ‚òÖ ‰øÆÊ≠£„Éù„Ç§„É≥„Éà ‚òÖ‚òÖ‚òÖ
    // „ÇÇ„ÅóÈÄö‰ø°„Å´„Çà„Å£„Å¶„ÄÅ„Åô„Åß„Å´Ê¨°„ÅÆ„Éï„Çß„Éº„Ç∫Ôºà„Ç´„Éº„ÉâÈÅ∏ÊäûÊ∏à„Åø„ÇÑÁßªÂãï„Éï„Çß„Éº„Ç∫Ôºâ„Å´ÈÄ≤„Çì„Åß„ÅÑ„Åü„Çâ„ÄÅ
    // „Åì„Åì„Åß„Éï„Çß„Éº„Ç∫„Çí 'TURN_CUTIN' „Å´Êàª„Åó„Å¶„Åó„Åæ„ÅÜ„Å®„Éê„Ç∞„Çã„Åü„ÇÅ„ÄÅÂá¶ÁêÜ„Çí‰∏≠Êñ≠„Åô„Çã„ÄÇ
    if (state.gameMode === 'ONLINE') {
        if (state.phase === 'SELECT_ROTATION' || state.phase === 'DEFENDER_MOVE') {
            console.log("Online sync: Skip phase reset");
            updateTurnVisuals(); // Ëâ≤„Å™„Å©„ÇíÊ≠£„Åó„ÅÑ„Éó„É¨„Ç§„É§„Éº„Å´Êõ¥Êñ∞„Åó„Å¶„Åä„Åè
            return;
        }
    }
    // ‚òÖ‚òÖ‚òÖ „Åì„Åì„Åæ„Åß ‚òÖ‚òÖ‚òÖ
    
    // 2. „Éï„Çß„Éº„Ç∫„Çí‰∏ÄÊôÇÁöÑ„Å´„ÄåÊºîÂá∫‰∏≠„Äç„Å´„Åó„Å¶„ÄÅÊìç‰Ωú„Çí„Éñ„É≠„ÉÉ„ÇØ„Åô„Çã
    state.phase = 'TURN_CUTIN'; 
    updateTurnVisuals(); 

    // 3. „Ç´„ÉÉ„Éà„Ç§„É≥ÊºîÂá∫„ÇíÂÜçÁîü„Åó„Å¶ÂæÖÊ©ü
    await playTurnCutIn(state.turnPlayer);

    // 4. ÂæÖÊ©ü‰∏≠„Å´ÈÄö‰ø°„Åß„Éï„Çß„Éº„Ç∫„ÅåÈÄ≤„Çì„Åß„Åó„Åæ„Å£„ÅüÂ†¥Âêà„ÅÆ„Ç¨„Éº„ÉâÔºàÊó¢Â≠ò„ÅÆÂá¶ÁêÜÔºâ
    if (state.phase !== 'TURN_CUTIN') {
        console.log("Skip phase reset due to online event");
        return; 
    }

    // 5. ÊºîÂá∫„ÅåÁµÇ„Çè„Å£„Åü„Çâ„ÄÅÂÆüÈöõ„ÅÆÊìç‰Ωú„Éï„Çß„Éº„Ç∫„Å∏ÁßªË°å
    document.getElementById('card-info').innerText = "";
    state.phase = 'SELECT_CARD';
    state.selectedCard = null;
    state.hiddenRotation = null; 
    
   document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    
    updateTurnVisuals(); 
    resetTimer(); 

    if (state.gameMode !== 'ONLINE' || state.turnPlayer.id === myPlayerId) {
        triggerPhaseGuidance();
    }

    if (state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}

function playTurnCutIn(player) {
    return new Promise(resolve => {
        // 1000„Éü„É™ÁßíÔºà1ÁßíÔºâ„ÅÆ„ÄåÈñì„Äç„Çí‰Ωú„Çã
        setTimeout(() => {
            resolve();
        }, 1000);
    });
}

function calcValidDirections(startHex) {
    state.validDirections = [];
    DIRECTIONS.forEach((d, idx) => {
        const indices = getLineIndices(startHex, state.selectedCard, idx);
        if (indices) state.validDirections.push({ dirIdx: idx, indices: indices });
    });
}
function getLineIndices(startHex, len, dirIdx) {
    let indices = [];
    let curr = startHex;
    let dir = DIRECTIONS[dirIdx];
    for(let i=0; i<len; i++) {
        let idx = getHexIndex(curr.q, curr.r);
        if (idx === -1) return null;
        indices.push(idx);
        curr = { q: curr.q + dir.dq, r: curr.r + dir.dr };
    }
    return indices;
}
function hexToPixel(q, r) {
    const x = canvas.width/2 + HEX_SIZE * (Math.sqrt(3) * (q + r/2));
    const y = canvas.height/2 + HEX_SIZE * (3/2 * r);
    return { x, y };
}
function pixelToHex(x, y) {
    const pt = { x: x - canvas.width/2, y: y - canvas.height/2 };
    const q = (Math.sqrt(3)/3 * pt.x - 1/3 * pt.y) / HEX_SIZE;
    const r = (2/3 * pt.y) / HEX_SIZE;
    return cubeRound(q, r, -q-r);
}
function cubeRound(x, y, z) {
    let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
    const x_diff = Math.abs(rx - x), y_diff = Math.abs(ry - y), z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
    else if (y_diff > z_diff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: ry };
}
function getHexIndex(q, r) { return state.hexes.findIndex(h => h.q === q && h.r === r); }
function getUnitAt(q, r) { return state.units.find(u => u.q === q && u.r === r); }
function isEquilateral(p1, p2, p3) {
    const d1 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
    const d2 = Math.hypot(p2.x-p3.x, p2.y-p3.y);
    const d3 = Math.hypot(p3.x-p1.x, p3.y-p1.y);
    const avg = (d1 + d2 + d3) / 3;
    if (avg < 10) return false;
    return Math.abs(d1 - avg) < avg * 0.1 && Math.abs(d2 - avg) < avg * 0.1 && Math.abs(d3 - avg) < avg * 0.1;
}
function getTriangleOverlapRatio(unit, t1, t2, t3) {
    const unitPos = hexToPixel(unit.q, unit.r);
    const visualRadius = HEX_SIZE * 0.7; 

    let hitCount = 0;
    let totalPoints = 0;

    if (isPointInTriangle(unitPos, t1, t2, t3)) hitCount++;
    totalPoints++;

    const rings = [
        { r: 0.4, count: 6 },
        { r: 0.8, count: 8 },
        { r: 1.0, count: 12 }
    ];

    rings.forEach(ring => {
        const r = visualRadius * ring.r;
        for(let i = 0; i < ring.count; i++) {
            const theta = (Math.PI * 2 / ring.count) * i;
            const p = {
                x: unitPos.x + r * Math.cos(theta),
                y: unitPos.y + r * Math.sin(theta)
            };
            if (isPointInTriangle(p, t1, t2, t3)) hitCount++;
            totalPoints++;
        }
    });

    return hitCount / totalPoints;
}

function isPointInTriangle(p, a, b, c) {
    const v0 = {x: c.x-a.x, y: c.y-a.y}, v1 = {x: b.x-a.x, y: b.y-a.y}, v2 = {x: p.x-a.x, y: p.y-a.y};
    const dot00 = v0.x*v0.x+v0.y*v0.y, dot01 = v0.x*v1.x+v0.y*v1.y, dot02 = v0.x*v2.x+v0.y*v2.y;
    const dot11 = v1.x*v1.x+v1.y*v1.y; 
    const dot12 = v1.x*v2.x+v1.y*v2.y; 
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v < 1);
}

function resizeCanvas() {
    const c = document.getElementById('game-area');
    canvas.width = c.clientWidth; canvas.height = c.clientHeight;
    HEX_SIZE = Math.min((canvas.width*0.95)/(7*Math.sqrt(3)), (canvas.height*0.95)/(7*1.5));
}
function showToast(msg) {
}

function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
window.addEventListener('resize', resizeCanvas);
const preventScroll = (e) => { e.preventDefault(); };
canvas.addEventListener('touchmove', preventScroll, {passive: false});

function onInputStart(e) {
    if (e.cancelable) e.preventDefault(); 

    const r = canvas.getBoundingClientRect();
    let clientX, clientY;

    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    handleInput(clientX - r.left, clientY - r.top);
}

canvas.addEventListener('touchstart', onInputStart, {passive: false});
canvas.addEventListener('mousedown', onInputStart);

resizeCanvas();

function aiFindBestCardAction() {
    let bestScore = -Infinity;
    let bestAction = { cardLen: 3, indices: null }; 

    const cardLens = [2, 3, 4];
    
    for (let len of cardLens) {
        for (let i = 0; i < state.hexes.length; i++) {
            const h = state.hexes[i];
            for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
                const indices = getLineIndices(h, len, dirIdx);
                if (!indices) continue;

                const simUnits = aiSimulateRotation(indices);
                const score = aiEvaluateBoard(simUnits);
                
                if (score > bestScore + (Math.random() * 5)) { 
                    bestScore = score;
                    bestAction = { cardLen: len, indices: indices };
                }
            }
        }
    }
    return bestAction;
}

function aiFindBestMove(excludeUnitId = null) {
    let bestScore = -Infinity;
    let bestMove = null;

    const cpuUnits = state.units.filter(u => u.owner === 2);
    
    const occupied = new Set(state.units.map(u => getHexIndex(u.q, u.r)));
    state.defenderMoves.forEach(m => occupied.add(m.toIndex));

    for (let u of cpuUnits) {
        if (excludeUnitId && u.id === excludeUnitId) continue;

        const currentIdx = getHexIndex(u.q, u.r);
        
        for (let i = 0; i < state.hexes.length; i++) {
            if (occupied.has(i)) continue;
            if (i === currentIdx) continue;

            const simUnits = state.units.map(unit => ({ ...unit }));
            const targetUnit = simUnits.find(unit => unit.id === u.id);
            const targetHex = state.hexes[i];
            targetUnit.q = targetHex.q;
            targetUnit.r = targetHex.r;

            let score = aiEvaluateBoard(simUnits);

            if (targetHex.isEdge && score < 500) { 
                 score -= 1000;
            }

            if (score > bestScore + (Math.random() * 5)) {
                bestScore = score;
                bestMove = { unitId: u.id, toIndex: i };
            }
        }
    }
    return bestMove;
}

function aiSimulateRotation(indices) {
    const simUnits = state.units.map(u => ({ ...u })); 
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        const h = state.hexes[hexIdx];
        const u = simUnits.find(unit => unit.q === h.q && unit.r === h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos; 
        let nextHex = state.hexes[indices[nextLinePos]];
        item.u.q = nextHex.q;
        item.u.r = nextHex.r;
    });
    return simUnits;
}

function aiEvaluateBoard(simUnits) {
    let score = 0;
    const cpuId = 2;
    const playerId = 1;

    simUnits.forEach(u => {
        const hIdx = getHexIndex(u.q, u.r);
        if (hIdx !== -1 && state.hexes[hIdx].isEdge) {
            if (u.owner === cpuId) score -= 2000;   
            if (u.owner === playerId) score += 300; 
        }
    });

    [cpuId, playerId].forEach(owner => {
        const myUnits = simUnits.filter(u => u.owner === owner);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.q, u.r));
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const targetId = owner === cpuId ? playerId : cpuId;
                const targets = simUnits.filter(u => u.owner === targetId);
                
                let hits = 0;
                targets.forEach(t => {
                    const ratio = getTriangleOverlapRatio(t, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) hits++;
                });

                if (owner === cpuId) {
                    if (hits > 0) {
                        score += 5000 * hits;
                    } else {
                        score -= 200;
                    }
                } else {
                    score -= 500; 
                    if (hits > 0) {
                        score -= 20000 * hits; 
                    }
                }
            }
        }
    });

    return score;
}

function showResult(winnerName) {
    const screen = document.getElementById('result-screen');
    const nameEl = document.getElementById('winner-name');
    
    if (winnerName === "DRAW") {
        nameEl.innerText = "DRAW";
        nameEl.style.color = "#fff";
    } else {
        nameEl.innerText = winnerName;
        nameEl.style.color = (winnerName === "BLUE") ? COLORS.p1 : COLORS.p2;
    }

    screen.style.display = 'flex';
    setTimeout(() => {
        screen.classList.add('show');
    }, 10);
}

function backToTitle() {
    bgm.pause();
    bgm.currentTime = 0;

    document.getElementById('settings-modal').classList.remove('active');
    document.getElementById('secret-modal').classList.remove('active');

    if (state.gameMode === 'ONLINE' && roomId) {
        const actionsRef = ref(db, roomId + '/action');
        off(actionsRef);

        const roomRef = ref(db, roomId);
        off(roomRef);

        const targetRoom = roomId; 
        roomId = null;             
        
        remove(ref(db, targetRoom))
            .then(() => console.log("ÈÉ®Â±ã„Éá„Éº„Çø„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü"))
            .catch((e) => console.error("ÂâäÈô§„Ç®„É©„Éº:", e));
    }

    const resScreen = document.getElementById('result-screen');
    resScreen.classList.remove('show');

    setTimeout(() => resScreen.style.display = 'none', 500);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    document.getElementById('turn-indicator').innerText = "";
    document.getElementById('card-info').innerHTML = "";

    document.getElementById('title-screen').style.display = 'flex';
}

function quitGame() {
    if (!confirm("„Çø„Ç§„Éà„É´ÁîªÈù¢„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü\nÔºàÁèæÂú®„ÅÆÂØæÊà¶„ÅØÁ†¥Ê£Ñ„Åï„Çå„Åæ„ÅôÔºâ")) {
        return;
    }

    state.winner = "QUIT"; 
    state.isCpuThinking = false;

    backToTitle();
}

function toggleEmoteMenu() {
    document.getElementById('emote-menu').classList.toggle('show');
}

function drawEmotes() {
}

function sendEmote(emoji, forceOwnerId = null) {
    const now = Date.now();
    if (!forceOwnerId && now - state.lastEmoteTime < 3000) { 
        showToast("Â∞ë„ÄÖ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ...");
        return; 
    }
    if (!forceOwnerId) state.lastEmoteTime = now;

    document.getElementById('emote-menu').classList.remove('show');

    if (state.gameMode === 'ONLINE' && !forceOwnerId) {
        sendAction('EMOTE', { value: emoji });
    }

    let ownerId;

    if (forceOwnerId) {
        ownerId = forceOwnerId;
    } else {
        if (state.gameMode === 'PvE') ownerId = 1;
        else ownerId = state.turnPlayer.id;
    }

    const el = document.createElement('div');
    el.innerText = emoji;
    
    el.style.position = 'fixed';
    el.style.zIndex = '9999';
    el.style.fontSize = '40px';
    el.style.fontWeight = 'bold';
    el.style.pointerEvents = 'none';
    el.style.textShadow = '0 4px 10px rgba(0,0,0,0.5)';
    el.style.fontFamily = "Arial, sans-serif";

    const topPosition = '120px';

    if (ownerId === 1) {
        el.style.left = '40px'; 
        el.style.top = topPosition;
        el.style.transformOrigin = 'center left';
    } else {
        el.style.right = '40px';
        el.style.top = topPosition;
        el.style.transformOrigin = 'center right';
    }

    document.body.appendChild(el);

    const anim = el.animate([
        { transform: 'scale(0) translateY(20px)', opacity: 0 },
        { transform: 'scale(1.2) translateY(0)', opacity: 1, offset: 0.1 },
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.2 },
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.7 },
        { transform: 'scale(1.0) translateY(-50px)', opacity: 0 }
    ], {
        duration: 1500,
        easing: 'ease-out'
    });

    anim.onfinish = () => el.remove();
}

let roomId = null;
let myPlayerId = 0; 

window.startOnlineGame = function() { 
    if (bgm.paused) {
        bgm.play().catch(()=>{});
    }

    const inputRoom = document.getElementById('room-input').value.trim();

    if (!inputRoom) {
        alert("ÂêàË®ÄËëâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
        return;
    }
    
    const sanitizedRoomId = inputRoom.replace(/[.#$\[\]\/]/g, '');

    if (!sanitizedRoomId) {
        alert("„Åù„ÅÆÂêàË®ÄËëâ„ÅØ‰Ωø„Åà„Åæ„Åõ„ÇìÔºàÁ¶ÅÊ≠¢Ë®òÂè∑„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ");
        return;
    }

    roomId = "rooms_v2/" + sanitizedRoomId;
    
    const myName = document.getElementById('username-input').value.trim() || "PLAYER";

    const roomRef = ref(db, roomId);
    get(roomRef).then((snapshot) => {
        if (!snapshot.exists()) {
            createRoom(myName);
        } else {
            const data = snapshot.val();
            if (!data.p1) {
                joinRoom(myName, 1);
            } else if (!data.p2) {
                joinRoom(myName, 2);
            } else {
                alert("„Åù„ÅÆÈÉ®Â±ã„ÅØÊ∫ÄÂì°„Åß„ÅôÔºÅÂà•„ÅÆÂêàË®ÄËëâ„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
            }
        }
    }).catch((error) => {
        console.error(error);
        alert("ÈÄö‰ø°„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü");
    });
};

function createRoom(name) {
    myPlayerId = Math.random() < 0.5 ? 1 : 2;
    
    const myComment = document.getElementById('comment-input').value.trim() || "...";

    const roomData = {
        p1: myPlayerId === 1 ? name : null,
        p1Comment: myPlayerId === 1 ? myComment : null,
        
        p2: myPlayerId === 2 ? name : null,
        p2Comment: myPlayerId === 2 ? myComment : null,
        
        status: "waiting",
        turn: 1,
        lastUpdate: Date.now()
    };

    const roomRef = ref(db, roomId);
    set(roomRef, roomData);

    onDisconnect(roomRef).remove(); 

    waitForOpponent();
}

function joinRoom(name, joinAsId) {
    myPlayerId = joinAsId;

    const myComment = document.getElementById('comment-input').value.trim() || "...";

    const updates = {};
    updates[`p${myPlayerId}`] = name;
    updates[`p${myPlayerId}Comment`] = myComment;
    updates["status"] = "ready";
    
    const roomRef = ref(db, roomId);

    update(roomRef, updates)
        .then(() => {
            startGameOnline(); 
        });

    onDisconnect(roomRef).remove();
}

function waitForOpponent() {
    const inputVal = document.getElementById('room-input').value;
    document.getElementById('display-room-id').innerText = inputVal;

    document.getElementById('secret-modal').classList.remove('active');
    document.getElementById('waiting-modal').classList.add('active');

    const waitTargetId = myPlayerId === 1 ? 2 : 1;
    const waitRef = ref(db, roomId + `/p${waitTargetId}`);
    
    onValue(waitRef, (snapshot) => {
        if (snapshot.exists()) {
            document.getElementById('waiting-modal').classList.remove('active');
            showToast("Áõ∏Êâã„ÅåÂèÇÂä†„Åó„Åæ„Åó„ÅüÔºÅ");
            
            setTimeout(() => {
                startGameOnline(); 
            }, 500); 
        }
    });
}

window.shareInviteLink = async function() {
    const inputVal = document.getElementById('room-input').value;
    const baseUrl = window.location.href.split('?')[0];
    const inviteUrl = `${baseUrl}?room=${inputVal}`;
    
    const shareData = {
        title: 'HONEY NOW',
        text: `ÂêàË®ÄËëâ„Äå${inputVal}„Äç„ÅßÂØæÊà¶„Åó„Çà„ÅÜÔºÅ`,
        url: inviteUrl,
    };

    if (navigator.share) {
        try {
            await navigator.share(shareData); 
        } catch (err) {
        }
    } else {
        navigator.clipboard.writeText(inviteUrl).then(() => {
            showToast("URL„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ");
        }).catch(() => {
            showToast("ÊâãÂãï„Åß„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
            prompt("„Åì„ÅÆURL„Çí„Ç≥„Éî„Éº„Åó„Å¶ÈÄÅ„Å£„Å¶„Å≠", inviteUrl);
        });
    }
};

window.cancelWait = function() {
    if (roomId) {
        remove(ref(db, roomId));
        roomId = null;
    }
    document.getElementById('waiting-modal').classList.remove('active');
    document.getElementById('title-screen').style.display = 'flex';
};

// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
// 2„Å§ÁõÆ„ÅÆË¶ÅÊ≥®ÊÑèÁÆáÊâÄ: startGameOnline
// ‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†
function startGameOnline() {
    state.gameMode = 'ONLINE';
    state.turn = 1;
    state.turnPlayer = P1;
    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    
    document.getElementById('title-screen').style.display = 'none';

    get(ref(db, roomId)).then((snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        const p1Name = data.p1 || "PLAYER 1";
        const p1Comment = data.p1Comment || "..."; 
        const p2Name = data.p2 || "PLAYER 2";
        const p2Comment = data.p2Comment || "..."; 

        if (myPlayerId === 1) {
            document.getElementById('p1-label').innerText = p1Name;
            document.getElementById('p1-comment').innerText = p1Comment; 
            document.getElementById('p2-label').innerText = p2Name;
            document.getElementById('p2-comment').innerText = p2Comment; 
        } else {
            document.getElementById('p1-label').innerText = p1Name; 
            document.getElementById('p1-comment').innerText = p1Comment; 
            document.getElementById('p2-label').innerText = p2Name;
            document.getElementById('p2-comment').innerText = p2Comment; 
        }

        let myColorName, myColorCode, enemyName;
        
        if (myPlayerId === 1) {
            myColorName = "BLUE";
            myColorCode = COLORS.p1;
            enemyName = p2Name;
        } else {
            myColorName = "RED";
            myColorCode = COLORS.p2;
            enemyName = p1Name;
        }

        playStartAnimation(myColorName, myColorCode, enemyName, () => {
            
            initBoardUnits();
            resizeCanvas();
            updateTurnVisuals();
            gameLoop();
            resetTimer();
            startOnlineListener();
            
        });

    }).catch((err) => {
        console.error("ÈñãÂßã„Ç®„É©„Éº:", err);
        alert("ÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
        backToTitle();
    });
} // startGameOnline ÁµÇ‰∫Ü

function resetTimer() {
    clearInterval(state.timerInterval);
    state.timeLeft = 30; 
    updateTimerDisplay();

    state.timerInterval = setInterval(() => {
        state.timeLeft--;
        updateTimerDisplay();

        const timeLimit = (state.gameMode === 'ONLINE') ? -2 : 0;

        if (state.timeLeft <= timeLimit) {
            clearInterval(state.timerInterval);
            handleTimeout(); 
        }
    }, 1000);
}

function updateTimerDisplay() {
    const el = document.getElementById('timer-display');
    if (!el) return;
    
    el.innerText = Math.max(0, state.timeLeft);
    
    if (state.timeLeft <= 10) {
        el.classList.add('danger');
    } else {
        el.classList.remove('danger');
    }
}

function handleTimeout() {
    if (state.gameMode === 'ONLINE') {
        const isMyTurn = (state.phase === 'DEFENDER_MOVE') 
            ? (state.turnPlayer.id !== myPlayerId) 
            : (state.turnPlayer.id === myPlayerId);

        if (!isMyTurn) return; 
    }
    
    if (state.isCpuThinking) return;
    showToast("TIME UP!");
    
    if (state.phase === 'SELECT_CARD') {
        uiSelectCard(2);
    } else if (state.phase === 'SELECT_ROTATION') {
         if (state.validDirections.length > 0) {
            const valid = state.validDirections[0];
            state.hiddenRotation = { indices: valid.indices };
            if (state.gameMode === 'ONLINE') sendAction('ROTATE', { indices: valid.indices });
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals(); 
        } else {
            state.phase = 'SELECT_CARD';
            resetTimer(); 
        }
    } else if (state.phase === 'DEFENDER_MOVE') {
        uiConfirm();
    }
}

function sendAction(type, data) {
    if (state.gameMode !== 'ONLINE') return;
    
    push(ref(db, roomId + "/action"), {
        type: type,
        sender: myPlayerId,
        ...data,
        timestamp: Date.now()
    });
}

window.openSettings = function() {
    document.getElementById('settings-modal').classList.add('active');
};
window.closeSettings = function() {
    document.getElementById('settings-modal').classList.remove('active');
};
window.changeVolume = function(val) {
    bgm.volume = parseFloat(val);
    if(bgm.paused) bgm.play().catch(()=>{});
};
window.openSecretModal = function() {
    document.getElementById('secret-modal').classList.add('active');
    setTimeout(() => {
        document.getElementById('room-input').focus();
    }, 100);
};
window.closeSecretModal = function() {
    document.getElementById('secret-modal').classList.remove('active');
};

function startOnlineListener() {
    const actionsRef = ref(db, roomId + '/action');
    
    onChildAdded(actionsRef, (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        if (data.sender === myPlayerId) return;

        if (data.type === 'SELECT_CARD') {
            uiSelectCard(data.value, true); 
            showToast("Áõ∏Êâã„Åå„Ç´„Éº„Éâ„ÇíÈÅ∏Êäû‰∏≠...");
        } else if (data.type === 'ROTATE') {
            state.hiddenRotation = { indices: data.indices };
            state.phase = 'DEFENDER_MOVE';
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("ROTATION SET!");
            updateTurnVisuals();
            resetTimer(); 
        } else if (data.type === 'MOVE') {
            state.defenderMoves = data.moves;
            showToast("Áõ∏Êâã„ÅåÁßªÂãï„Åó„Åæ„Åó„Åü");
            startTurnResolution();
        } else if (data.type === 'EMOTE') {
            sendEmote(data.value, data.sender);
        }
    });

    const roomRef = ref(db, roomId);
    onValue(roomRef, (snapshot) => {
        // ‚òÖ„Åì„Åì‰øÆÊ≠£ÔºÅ && !state.winner „ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ
        if (state.gameMode === 'ONLINE' && !snapshot.exists() && !state.winner) {
            if (roomId) { 
                alert("ÂØæÊà¶„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„ÅüÔºàÁõ∏Êâã„ÅåÈÄÄÂá∫„Åó„Åæ„Åó„ÅüÔºâ");
                off(ref(db, roomId + '/action'));
                off(ref(db, roomId));
                roomId = null; 
                state.gameMode = 'TITLE'; 
                backToTitle();
            }
        }
    });
}

window.startGame = startGame;
window.uiSelectCard = uiSelectCard;
window.uiConfirm = uiConfirm;
window.quitGame = quitGame;
window.backToTitle = backToTitle;
window.toggleEmoteMenu = toggleEmoteMenu;
window.sendEmote = sendEmote;

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        bgm.pause();
    } else {
        const isTitleHidden = document.getElementById('title-screen').style.display === 'none';
        const isResultHidden = document.getElementById('result-screen').style.display === 'none';
        if (isTitleHidden && isResultHidden) {
            bgm.play().catch(e => console.log("BGMÂÜçÈñã„Ç®„É©„Éº:", e));
        }
    }
});

window.addEventListener('DOMContentLoaded', () => {
    const params = new URLSearchParams(window.location.search);
    const inviteRoom = params.get('room');
    if (inviteRoom) {
        document.getElementById('room-input').value = inviteRoom;
        document.getElementById('username-input').focus();
        showToast("ÊãõÂæÖ„Ç≥„Éº„Éâ„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ");
    }
});

</script>
</body>
</html>
