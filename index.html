<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>HONEY NOW</title>

    <style>
/* å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
body {
    margin: 0; padding: 0;
    
    color: #fff;
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    display: flex; flex-direction: column;
    position: fixed; width: 100%; height: 100svh;
    touch-action: none; -webkit-text-size-adjust: 100%;
    overflow: hidden; 

    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none; 
}

/* èƒŒæ™¯ç”»åƒï¼ˆé›²ï¼‰ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šä¸€ç•ªå¥¥ */
#bg-image-layer {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: -2; /* ä¸€ç•ªå¾Œã‚ */
    background-image: url('bg_game.png');
    background-size: cover;
    background-position: center;
}

/* è‰²ï¼ˆèµ¤ãƒ»é’ï¼‰ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šç”»åƒã®æ‰‹å‰ */
#bg-color-layer {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: -1; /* ç”»åƒã‚ˆã‚Šã¯æ‰‹å‰ã€ã‚²ãƒ¼ãƒ ã‚ˆã‚Šã¯å¾Œã‚ */
    transition: background-color 1.0s ease; /* ã˜ã‚ã£ã¨è‰²ãŒå¤‰ã‚ã‚‹ */
    
    /* â˜…é‡è¦ï¼šã“ã‚Œã‚’è¨­å®šã™ã‚‹ã¨ã€ç”»åƒã¨è‰²ãŒã‚«ãƒƒã‚³ã‚ˆãæ··ã–ã‚Šã¾ã™ */
    mix-blend-mode: overlay; 
    opacity: 0.8; /* è‰²ã®æ¿ƒã•ã‚’èª¿æ•´ï¼ˆ0.5ã€œ1.0ãã‚‰ã„ã§å¥½ã¿ã‚’æ¢ã£ã¦ãã ã•ã„ï¼‰ */
}

/* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
#title-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: none;
    z-index: 200;
}

/* èƒŒæ™¯ç”»åƒå°‚ç”¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
.bg-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-image: url('bg_title.png');
    background-size: cover;
    background-position: center;
    z-index: -1;
}

/* ãƒ­ã‚´ã®è¨­å®š */
#game-logo {
    width: 100%; max-width: 450px; height: auto;
    margin-bottom: 10px;
    animation: floating 3s ease-in-out infinite;
    filter: drop-shadow(0 10px 10px rgba(0,0,0,0.3));
}
@keyframes floating {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}

/* æ­¯è»Šã‚¢ã‚¤ã‚³ãƒ³ */
#gear-btn {
    position: absolute;
    top: max(20px, env(safe-area-inset-top));
    left: 20px;
    width: 50px; height: 50px;
    cursor: pointer;
    transition: transform 0.5s;
    filter: drop-shadow(0 2px 5px rgba(0,0,0,0.5));
    z-index: 10;
}
#gear-btn:hover { transform: rotate(180deg); }

/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ç¾¤ */
.menu-container {
    display: flex; flex-direction: column;
    gap: 20px; width: 100%; align-items: center;
}

/* æœ¨ã®ãƒœã‚¿ãƒ³ */
.wooden-btn {
    width: 240px; height: 90px;
    background-image: url('btn_wood.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    display: flex; justify-content: center; align-items: center;
    cursor: pointer; transition: transform 0.1s;
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.4));
}
.wooden-btn:active {
    /* é‡è¦: æŠ¼ã—ãŸç¬é–“ã¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ãªã„ï¼ˆå³åº§ã«åå¿œã•ã›ã‚‹ï¼‰ */
    transition: none !important;
    
    /* å‹•ãã‚’å¤§ããã™ã‚‹ï¼ˆ5px -> 8pxï¼‰ */
    transform: scale(0.95) translateY(8px);
    
    /* å½±ã‚’å®Œå…¨ã«æ¶ˆã—ã¦ã€åœ°é¢ã«ã‚ã‚Šè¾¼ã‚“ã æ„Ÿã‚’å‡ºã™ */
    filter: drop-shadow(0 0 0 rgba(0,0,0,0)) brightness(0.7);
}

.wooden-btn .btn-text {
    font-size: 32px; font-weight: 900; color: #fff;
    text-shadow: 2px 2px 0 #5d3a1a, -1px -1px 0 #5d3a1a, 0 0 10px rgba(0,0,0,0.5);
    font-family: 'Arial Black', sans-serif; letter-spacing: 2px;
    position: relative; top: -2px;
}
.wooden-btn.small { position: relative; width: 180px; height: 60px; margin-top: 15px;
left: 70px;}
.wooden-btn.small .btn-text { font-size: 24px; }

/* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€šè¨­å®š */
.modal-overlay {
    display: none;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
    justify-content: center; align-items: center; z-index: 300;
}
.modal-overlay.active { display: flex; }

.modal-box {
    background: rgba(255, 255, 255, 0.95);
    padding: 30px; border-radius: 20px;
    width: 80%; max-width: 320px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 4px solid #ffd700; color: #333;
}
.modal-box h2 {
    margin: 0 0 20px 0; color: #ff8c00; font-weight: 900;
    font-size: 28px; letter-spacing: 2px; text-shadow: 2px 2px 0 #fff;
}
.modal-box label {
    display: block; text-align: left; font-weight: bold;
    margin-top: 15px; font-size: 14px; color: #666;
}
.modal-box input[type="text"] {
    width: 100%; padding: 10px; font-size: 18px;
    border: 2px solid #ccc; border-radius: 10px; margin-top: 5px;
    box-sizing: border-box; text-align: center;
    background: #f9f9f9; color: #333;
}
input[type=range] { width: 100%; margin: 10px 0 20px 0; cursor: pointer; }

.close-btn {
    background: #ff8c00; color: #fff; border: none;
    padding: 10px 30px; font-size: 18px; border-radius: 30px;
    font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #cc7000; margin-top: 10px;
}
.close-btn:active { transform: translateY(4px); box-shadow: none; }
.text-btn {
    background: none; border: none; color: #888;
    font-weight: bold; margin-top: 15px; cursor: pointer; text-decoration: underline;
}

/* ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ»ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ */
/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
header {
    /* â˜…å¤‰æ›´ç‚¹ï¼šãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã€Œæµ®ã‹ã›ã€ã¦ã€ç›¤é¢ã‚¨ãƒªã‚¢ã‚’ä¸Šã¾ã§åºƒã’ã‚‹ */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 10; /* ç›¤é¢ã‚ˆã‚Šæ‰‹å‰ï¼ˆä¸Šï¼‰ã«è¡¨ç¤ºã™ã‚‹ */

    /* ä»¥ä¸‹ã¯ãã®ã¾ã¾ */
    padding: 20px; 
    padding-top: max(40px, env(safe-area-inset-top));
    background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0));
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    pointer-events: none;
}

.score-board {
    display: flex; justify-content: center; align-items: flex-start;
    width: 100%; height: 60px; padding: 0 10px; box-sizing: border-box; position: relative;
}
/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
.player-badge {
    position: absolute;
    /* ä¸Šã‹ã‚‰ã®ä½ç½® */
    top: 10px; 
    
    z-index: 100;
    display: flex; flex-direction: column; justify-content: center;
    width: 85px; min-height: 40px; align-items: flex-start; text-align: left;
    padding: 5px 8px; border-radius: 6px; 
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.3); 
    backdrop-filter: blur(4px); transition: all 0.3s;
}

/* å·¦ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆé’ï¼‰ã®ä½ç½® */
.player-badge.p1 { 
    left: -5px; /* å·¦ç«¯ã‹ã‚‰ã®è·é›¢ */
    box-shadow: 0 0 8px rgba(0, 204, 255, 0.2) inset; 
    border-color: rgba(0, 204, 255, 0.4); 
}

/* å³ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆèµ¤ï¼‰ã®ä½ç½® */
.player-badge.p2 { 
    right: 35px; /* å³ç«¯ã‹ã‚‰ã®è·é›¢ */
    box-shadow: 0 0 8px rgba(255, 51, 102, 0.2) inset; 
    border-color: rgba(255, 51, 102, 0.4); 
}

.badge-name { 
    font-size: 13px; font-weight: 900; letter-spacing: 0.5px; 
    width: 100%; word-break: break-word; line-height: 1.1; 
    margin-bottom: 5px; 
}

.badge-comment { font-size: 9px; color: #ccc; word-break: break-word; line-height: 1.2; opacity: 0.9; }

/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
#turn-indicator {
    /* ãƒãƒ¼ã‚¸ãƒ³ã§ä½ç½®ã‚’å¾®èª¿æ•´ï¼ˆä¸Šã€å·¦å³ã€ä¸‹ï¼‰ */
    margin: 0px 0 0 0; 
    margin-right: 30px;
    font-size: 40px; font-weight: 900; 
    text-shadow: 0 0 20px currentColor; 
    letter-spacing: 4px; line-height: 1; 
}
#phase-badge { position: relative; left: -15px; height: 24px; line-height: 24px; margin-bottom: 5px; font-size: 16px; font-weight: 800; text-transform: uppercase; letter-spacing: 8px; opacity: 0.8; text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 100%; text-align: center; transform: translate(0px, -6px);}
#card-info { position: relative; left: 5px; color: #ffd700; height: 40px; display: flex; align-items: center; justify-content: center; margin-top: 10px; margin-right: 35px}
#card-info svg { height: 100%; width: auto; fill: currentColor; }

/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
#timer-display {
    position: absolute;
    
    /* ä¸Šã‹ã‚‰ã®ä½ç½® */
    top: 80px; 
    
    /* ã“ã‚Œã§ç”»é¢ã®å·¦å³ä¸­å¤®ã«ãªã‚Šã¾ã™ */
    left: 46%;
    transform: translateX(-50%);
    
    font-size: 30px; font-weight: 900; color: #fff; 
    text-shadow: 0 0 10px rgba(0,0,0,0.8); 
    font-family: 'Courier New', Courier, monospace; 
    z-index: 100; transition: color 0.3s;
}

#timer-display.danger { color: #ff3333; text-shadow: 0 0 15px #ff0000; animation: pulse 0.5s infinite alternate; }
@keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }

/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
#game-area {
    flex: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;

    /* â˜…è¿½åŠ ï¼šä¸‹ã«ä½™ç™½ã‚’ä½œã£ã¦ã€ä¸­å¿ƒç‚¹ã‚’ä¸Šã«ãšã‚‰ã™ */
    padding-bottom: 0px; 
padding-top: 40px;
    box-sizing: border-box; /* ä½™ç™½ã‚’å«ã‚ã¦ã‚µã‚¤ã‚ºè¨ˆç®—ã™ã‚‹è¨­å®š */
}

canvas { filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5)); position: relative; top: -2px; }

/* â†“â†“â†“ ä¿®æ­£å¾Œ â†“â†“â†“ */
footer {
    position: fixed; bottom: 0; left: 0; width: 100%; z-index: 100;
    box-sizing: border-box;
    padding: 20px;
    padding-bottom: max(50px, env(safe-area-inset-bottom));
    display: flex; flex-direction: column; gap: 0;

    /* â˜…å¤‰æ›´ï¼šãƒ•ãƒƒã‚¿ãƒ¼è‡ªä½“ã¯ã€Œé€æ˜ã€ã«ã™ã‚‹ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚ãªã—ï¼‰ */
    background: none; 
    backdrop-filter: none;
    border-top: none; 

    pointer-events: none;
}

/* â˜…å¤‰æ›´ï¼šã“ã®ã€Œbeforeã€ã§ã€èƒŒæ™¯ã€‘ã¨ã€ç·šã€‘ã®ä¸¡æ–¹ã‚’ä½œã‚Šã¾ã™ */
footer::before {
    content: "";
    position: absolute;
    
    /* ä¸Šã‹ã‚‰20pxä¸‹ã’ãŸä½ç½®ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ */
    top: 10px; 
    left: 0;
    
    /* ç”»é¢ä¸‹ã¾ã§ã¯ã¿å‡ºã™ã‚ˆã†ã«å¤§ããç¢ºä¿ */
    width: 100%;
    height: 100%; 
    
    /* â˜…ã“ã“ã§ã€Œãƒ™ã‚¿å¡—ã‚Šã®é»’ï¼ˆåŠé€æ˜ï¼‰ã€ã‚’æŒ‡å®š */
    background: rgba(0, 0, 0, 0.5);
    
    /* ãã®é»’èƒŒæ™¯ã®ä¸€ç•ªä¸Šã«ã€Œç™½ã„ç·šã€ã‚’å¼•ã */
    border-top: 1px solid rgba(255, 255, 255, 0.3);
    
    /* ãƒœã‚¿ãƒ³ã‚ˆã‚Šå¥¥ã«è¡¨ç¤º */
    z-index: -1; 
}

/* ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ï¼ˆå¤‰æ›´ãªã—ï¼‰ */
#action-area {
    width: 100%; height: 80px; 
    display: flex; justify-content: center; align-items: center;
    pointer-events: auto; 
}

#card-panel { width: 100%; display: flex; justify-content: center; gap: 15px; }
.card { background: linear-gradient(145deg, #2a2a2a, #333); border: 2px solid #555; color: #aaa; padding: 5px 0; width: 30%; display: flex; justify-content: center; align-items: center; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s; position: relative; z-index: 1;}
.card svg { height: 28px; width: auto; fill: currentColor; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); max-width: 95%; position: relative; left: 5px; }
.card.selected { border-color: #ffd700; background: linear-gradient(145deg, #ffd700, #ffaa00); color: #000; transform: translateY(-5px); box-shadow: 0 10px 15px rgba(255, 215, 0, 0.3); }

#main-btn { font-family: 'Arial Black', sans-serif; font-size: 24px; width: 100%; padding: 18px; background: linear-gradient(90deg, #ff8c00, #ff0080); color: #fff; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 4px 15px rgba(255, 0, 128, 0.4); transition: transform 0.1s; }
#main-btn:disabled { background: #444; color: #888; box-shadow: none; cursor: not-allowed; }
#main-btn:active {
    /* é‡è¦: å³åº§ã«åå¿œã•ã›ã‚‹ */
    transition: none !important;
    
    /* æ·±ãæ²ˆã‚ã‚‹ */
    transform: translateY(6px);
    
    /* å¤–ã®å½±ã‚’æ¶ˆã—ã€ä»£ã‚ã‚Šã«ã€Œå†…å´ã®å½±ã€ã‚’ã¤ã‘ã¦å‡¹ã¿ã‚’è¡¨ç¾ã™ã‚‹ */
    box-shadow: inset 0 3px 10px rgba(0,0,0,0.5) !important;
    
    /* æš—ãã™ã‚‹ */
    filter: brightness(0.7);
}

#result-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
#result-screen.show { opacity: 1; pointer-events: auto; }
.result-label { font-size: 24px; color: #fff; letter-spacing: 10px; margin-bottom: 10px; opacity: 0.8; }
#winner-name { font-size: 60px; font-weight: 900; text-shadow: 0 0 30px currentColor; letter-spacing: 5px; transform: scale(0.5); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
#result-screen.show #winner-name { transform: scale(1); }
.mode-btn { padding: 15px 40px; font-size: 20px; font-weight: bold; color: #fff; background: transparent; border: 2px solid #fff; border-radius: 50px; cursor: pointer; transition: all 0.2s; }

#quit-btn { position: absolute; top: max(10px, env(safe-area-inset-top)); left: 10px; z-index: 150; background: rgba(0, 0, 0, 0.5); color: rgba(255, 255, 255, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 20px; padding: 5px 15px; font-size: 14px; font-weight: bold; cursor: pointer; backdrop-filter: blur(4px); transition: all 0.2s; }
#title-screen[style*="flex"] ~ #quit-btn { display: none; }

#toast { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s; pointer-events: none; white-space: nowrap; border: 1px solid rgba(255,255,255,0.2); z-index: 400; }

#emote-container { position: fixed; bottom: 160px; right: 20px; z-index: 150; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: none; }
#emote-btn { pointer-events: auto; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #fff, #ddd); border: none; font-size: 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; transition: transform 0.1s; }
#emote-btn:active { transform: scale(0.9); }
#emote-menu { background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(5px); padding: 10px; border-radius: 15px; display: flex; flex-wrap: wrap; width: 140px; gap: 8px; justify-content: center; border: 1px solid rgba(255,255,255,0.2); opacity: 0; transform: scale(0.8) translateY(20px); pointer-events: none; transition: all 0.2s; }
#emote-menu.show { opacity: 1; transform: scale(1) translateY(0); pointer-events: auto; }
.emote-item { font-size: 28px; cursor: pointer; transition: transform 0.1s; user-select: none; }
.emote-item:hover { transform: scale(1.2); }

/* é–‹å§‹ã‚«ãƒƒãƒˆã‚¤ãƒ³ */
#ready-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex; justify-content: center; align-items: center;
    z-index: 500; /* æœ€å‰é¢ã« */
    opacity: 0; pointer-events: none; transition: opacity 0.3s;
}
#ready-screen.active { opacity: 1; pointer-events: auto; }

.ready-content {
    text-align: center; transform: scale(0.8); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
#ready-screen.active .ready-content { transform: scale(1); }

.ready-label { font-size: 20px; color: #fff; letter-spacing: 5px; opacity: 0.8; margin-bottom: 10px; }
#player-role-text {
    font-size: 60px; font-weight: 900; letter-spacing: 5px; margin-bottom: 20px;
    text-shadow: 0 0 30px currentColor;
}
.vs-text { font-size: 30px; font-weight: bold; color: #888; margin-bottom: 10px; font-style: italic; }
#enemy-name-display { font-size: 40px; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }

/* --- ã‚¬ã‚¤ãƒ‰æ¼”å‡ºç”¨ --- */
@keyframes attention-pulse {
    0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); transform: scale(1); }
    50% { box-shadow: 0 0 0 15px rgba(255, 215, 0, 0); transform: scale(1.05); }
    100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); transform: scale(1); }
}

/* ã‚«ãƒ¼ãƒ‰ãŒæ³¨ç›®ã•ã‚Œã‚‹æ™‚ã®ã‚¯ãƒ©ã‚¹ */
.card.suggest-glow {
    animation: attention-pulse 1s ease-out infinite;
    border-color: #ffd700;
    z-index: 10;
}

    </style>
</head>
<body>
    <div id="bg-image-layer"></div>
    <div id="bg-color-layer"></div>

<div id="result-screen" style="display: none;">
    <div class="result-label">WINNER</div>
    <div id="winner-name">BLUE</div>
    <button class="mode-btn" onclick="backToTitle()" style="margin-top: 40px;">TITLE</button>
</div>

<button id="quit-btn" onclick="quitGame()">TOP</button>

<div id="title-screen">
    <div class="bg-layer"></div>

<img src="icon_gear.png" id="gear-btn" onclick="playSe('title'); openSettings()">

    <img src="logo.png" id="game-logo" alt="HONEY NOW">

    <div class="menu-container">
<div class="wooden-btn" onclick="playSe('title'); openSecretModal()">
            <span class="btn-text">ONLINE</span>
        </div>

     <div class="wooden-btn" onclick="playSe('title'); startGame('PvE')">
            <span class="btn-text">CPU</span>
        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SETTINGS</h2>
            
            <label>NAME</label>
            <input type="text" id="username-input" placeholder="PLAYER" maxlength="6">
            
            <label>COMMENT</label>
            <input type="text" id="comment-input" placeholder="..." maxlength="30">
            
<div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px;">
    <label style="margin:0;">BGM VOLUME</label>
    <div id="mute-bgm-btn" onclick="toggleMute('bgm')" style="font-weight:bold; color:#00ccff; cursor:pointer; font-size:14px; border:1px solid #00ccff; padding:2px 8px; border-radius:4px;">
        ğŸ”Š ON
    </div>
</div>
<input type="range" id="bgm-slider" min="0" max="1" step="0.1" value="0.1" oninput="changeBgmVolume(this.value)">

<div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
    <label style="margin:0;">SE VOLUME</label>
    <div id="mute-se-btn" onclick="toggleMute('se')" style="font-weight:bold; color:#ff3366; cursor:pointer; font-size:14px; border:1px solid #ff3366; padding:2px 8px; border-radius:4px;">
        ğŸ”Š ON
    </div>
</div>
<input type="range" id="se-slider" min="0" max="1" step="0.1" value="0.5" oninput="changeSeVolume(this.value)">

<button class="close-btn" onclick="playSe('title'); closeSettings()">OK</button>
        </div>
    </div>

    <div id="secret-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SECRET WORD</h2>
            <p style="font-size:12px; margin-bottom:10px;">åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ã­</p>
            
            <input type="text" id="room-input" placeholder="ENTER WORD" maxlength="10">
            
<div class="wooden-btn small" onclick="playSe('title'); startOnlineGame()">
                <span class="btn-text">GO!</span>
            </div>
            
<button class="text-btn" onclick="playSe('title'); closeSecretModal()">CANCEL</button>
        </div>
    </div>
</div>

<div id="ready-screen">
    <div class="ready-content">
        <div class="ready-label">YOU ARE</div>
        <div id="player-role-text">BLUE</div>
        <div class="vs-text">VS</div>
        <div id="enemy-name-display">CPU</div>
    </div>
</div>

<div id="waiting-modal" class="modal-overlay">
    <div class="modal-box">
        <h2>WAITING...</h2>
        <p style="font-size:14px; margin-bottom:5px;">åˆè¨€è‘‰</p>
        <div id="display-room-id" style="font-size:24px; font-weight:900; color:#00ccff; margin-bottom:20px; letter-spacing:2px;"></div>
        
        <div class="wooden-btn small" onclick="shareInviteLink()">
            <span class="btn-text" style="font-size:18px;">INVITE</span>
        </div>
        
        <button class="text-btn" onclick="cancelWait()">CANCEL</button>
    </div>
</div>

<header>
    <div class="score-board">
        <div class="player-badge p1">
            <div class="badge-name" id="p1-label">PLAYER</div>
            <div class="badge-comment" id="p1-comment">READY?</div>
        </div>
        
        <div id="turn-indicator">BLUE</div>
        
        <div class="player-badge p2">
            <div class="badge-name" id="p2-label">CPU</div>
            <div class="badge-comment" id="p2-comment">...</div>
        </div>
    </div>

    <div id="card-info"></div>
    <div id="phase-badge">PICK CARD</div>

    <div id="timer-display">30</div>
</header>

<div id="game-area">
    <canvas id="board"></canvas>
    <div id="toast"></div>
</div>

<div id="emote-container">
    <div id="emote-menu">
        <div class="emote-item" onclick="sendEmote('ğŸ˜€')">ğŸ˜€</div>
        <div class="emote-item" onclick="playSe('battle');sendEmote('ğŸ¤”')">ğŸ¤”</div>
        <div class="emote-item" onclick="playSe('battle');sendEmote('ğŸ˜±')">ğŸ˜±</div>
        <div class="emote-item" onclick="playSe('battle');sendEmote('ğŸ˜')">ğŸ˜</div>
        <div class="emote-item" onclick="playSe('battle');sendEmote('ğŸ‘')">ğŸ‘</div>
        <div class="emote-item" onclick="playSe('battle');sendEmote('ğŸ˜¡')">ğŸ˜¡</div>
    </div>
 <button id="emote-btn" onclick="playSe('battle'); toggleEmoteMenu()">ğŸ’¬</button>
</div>

<footer>
    <div id="action-area">
        <div id="card-panel">
            <div class="card" onclick="uiSelectCard(2)">
                <svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
            
            <div class="card" onclick="uiSelectCard(3)">
                <svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>

            <div class="card" onclick="uiSelectCard(4)">
                <svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(61.96, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
        </div>

        <button id="main-btn" onclick="uiConfirm()" disabled>GO!</button>
    </div>
</footer>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
  import { getDatabase, ref, set, push, onValue, update, remove, get, child, onDisconnect, onChildAdded, off } 
  from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDswxDswxU_DU-DdhYI8KsANtVeYVP6NN4",
    authDomain: "honeynow-7fe79.firebaseapp.com",
    databaseURL: "https://honeynow-7fe79-default-rtdb.firebaseio.com",
    projectId: "honeynow-7fe79",
    storageBucket: "honeynow-7fe79.firebasestorage.app",
    messagingSenderId: "745229921816",
    appId: "1:745229921816:web:345524bda3da61f8c7dd6d",
    measurementId: "G-RTEVBEYH3M"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);

const BOARD_RADIUS = 3;

const bgm = new Audio('bgm.mp3');
bgm.loop = true;

// â– â– â–  SEï¼ˆåŠ¹æœéŸ³ï¼‰ã®å®šç¾© â– â– â– 
const seTitle = new Audio('se_title.mp3');   // ã‚¿ã‚¤ãƒˆãƒ«ç”¨
const seBattle = new Audio('se_battle.mp3'); // ãƒãƒˆãƒ«ç”¨
const seCancel = new Audio('se_cancel.mp3'); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç”¨
// â˜…è¿½åŠ ï¼šå›è»¢ï¼ˆãƒã‚¹ã‚«ãƒ¼ãƒ‰å®Ÿè¡Œï¼‰ç”¨ã®éŸ³
const seRotate = new Audio('se_rotate.mp3'); 

const seMove = new Audio('se_move.mp3');    
const seDamage = new Audio('se_damage.mp3'); 


// â– â– â–  éŸ³é‡ç®¡ç†ç”¨å¤‰æ•° â– â– â– 
let bgmVolume = 0.1;
let seVolume = 0.5; // SEã®åˆæœŸéŸ³é‡

// SEå†ç”Ÿç”¨é–¢æ•°ï¼ˆBGMè˜‡ç”Ÿæ©Ÿèƒ½ã¤ãï¼‰
function playSe(name) {
    let target = null;
    if (name === 'title') target = seTitle;
    if (name === 'battle') target = seBattle;
    if (name === 'cancel') target = seCancel;
    if (name === 'rotate') target = seRotate;
    if (name === 'move') target = seMove;
    if (name === 'damage') target = seDamage;
    
    if (target) {
        target.currentTime = 0; 
        target.volume = seVolume; 
        target.play().catch(()=>{});

        // â–¼â–¼â–¼ â˜…è¿½åŠ ï¼šBGMã®è˜‡ç”Ÿæªç½® â–¼â–¼â–¼
        // ã€ŒBGMãŒæ­¢ã¾ã£ã¦ã„ã‚‹ã€ã‹ã¤ã€ŒéŸ³é‡è¨­å®šãŒ0ã‚ˆã‚Šå¤§ãã„ã€å ´åˆ
        if (bgm.paused && bgmVolume > 0) {
            console.log("BGM stopped by SE, restarting...");
            bgm.play().catch(()=>{});
        }
    }
}


// â– â– â–  ã‚·ãƒ³ãƒ—ãƒ«ã§å®‰å®šã—ãŸã‚ªãƒ¼ãƒ‡ã‚£ã‚ªç®¡ç† â– â– â– 

// BGMéŸ³é‡å¤‰æ›´ç”¨
window.changeBgmVolume = function(val) {
    bgmVolume = parseFloat(val);
    bgm.volume = bgmVolume; // å˜ç´”ã«volumeãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å…¥ã‚Œã‚‹ã ã‘ã§OK
    
    // å†ç”Ÿä¸­ã§ãªã‘ã‚Œã°å†ç”Ÿï¼ˆéŸ³é‡ãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆï¼‰
    if (bgm.paused && bgmVolume > 0) {
        bgm.play().catch(()=>{});
    }

    // ãƒŸãƒ¥ãƒ¼ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    const btn = document.getElementById('mute-bgm-btn');
    if (btn) {
        if (bgmVolume === 0) {
            btn.innerText = "ğŸ”‡ MUTE"; btn.style.opacity = "0.5";
        } else {
            btn.innerText = "ğŸ”Š ON"; btn.style.opacity = "1";
        }
    }
};

// SEéŸ³é‡å¤‰æ›´ç”¨
window.changeSeVolume = function(val) {
    seVolume = parseFloat(val);
    playSe('title'); // ç¢ºèªéŸ³

    const btn = document.getElementById('mute-se-btn');
    if (btn) {
        if (seVolume === 0) {
            btn.innerText = "ğŸ”‡ MUTE"; btn.style.opacity = "0.5";
        } else {
            btn.innerText = "ğŸ”Š ON"; btn.style.opacity = "1";
        }
    }
};

// ä¸€æ‹¬ãƒŸãƒ¥ãƒ¼ãƒˆæ©Ÿèƒ½
window.toggleMute = function(type) {
    if (type === 'bgm') {
        const slider = document.getElementById('bgm-slider');
        const current = parseFloat(slider.value);
        if (current > 0) {
            slider.setAttribute('data-prev', current);
            slider.value = 0;
            changeBgmVolume(0);
        } else {
            const prev = parseFloat(slider.getAttribute('data-prev')) || 0.1;
            slider.value = prev;
            changeBgmVolume(prev);
        }
    } else if (type === 'se') {
        const slider = document.getElementById('se-slider');
        const current = parseFloat(slider.value);
        if (current > 0) {
            slider.setAttribute('data-prev', current);
            slider.value = 0;
            changeSeVolume(0);
        } else {
            const prev = parseFloat(slider.getAttribute('data-prev')) || 0.5;
            slider.value = prev;
            changeSeVolume(prev);
        }
    }
};

const COLORS = {
    // ãƒ¦ãƒ‹ãƒƒãƒˆæœ¬ä½“ã®è‰²ï¼ˆæ¿ƒã„ã‚ãƒ»åŠé€æ˜ï¼‰
    p1: 'rgba(65, 105, 225, 0.8)', 
    p1Bg: '#4169E1', 
    // â˜…è¿½åŠ ï¼šä¸‰è§’å½¢ã®ä¸­èº«ã®è‰²ï¼ˆã‹ãªã‚Šè–„ãã™ã‚‹ 0.2 ãã‚‰ã„ï¼‰
    p1Triangle: 'rgba(0, 100, 220, 0.2)',

    // ãƒ¦ãƒ‹ãƒƒãƒˆæœ¬ä½“ã®è‰²
    p2: 'rgba(220, 20, 60, 0.8)', 
    p2Bg: '#DC143C',
    // â˜…è¿½åŠ ï¼šä¸‰è§’å½¢ã®ä¸­èº«ã®è‰²
    p2Triangle: 'rgba(220, 20, 60, 0.2)',
    
    hex: 'rgba(255, 215, 0, 0.1)',  hexEdge: '#333',
    damageZone: 'rgba(0, 0, 0, 0.3)', damageStroke: '#ff3333',
    previewLine: 'rgba(255, 255, 0, 0.8)', guideMarker: 'rgba(255, 255, 255, 0.3)'
};

const P1 = { id: 1, name: 'BLUE', color: COLORS.p1, bg: COLORS.p1Bg };
const P2 = { id: 2, name: 'RED', color: COLORS.p2, bg: COLORS.p2Bg };
const DIRECTIONS = [{dq:1,dr:0}, {dq:1,dr:-1}, {dq:0,dr:-1}, {dq:-1,dr:0}, {dq:-1,dr:1}, {dq:0,dr:1}];

let state = {
    gameMode: null,
    turn: 1,
    turnPlayer: P1,
    phase: 'TITLE', 
    hexes: [],
    units: [],
    selectedCard: null,
    tempRotationStart: null,
    validDirections: [], 
    hiddenRotation: null,
    defenderMoves: [],
    selectedUnit: null,
    winner: null,
    frameCount: 0,
    isCpuThinking: false,
    emotes: [],
    damageEffects: [],
    timeLeft: 30,
    timerInterval: null,
    lastEmoteTime: 0,
    previewRotation: null,
    showUnitGuidance: false,
    pendingActions: []

};

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
let HEX_SIZE = 30;

// â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
// 1ã¤ç›®ã®è¦æ³¨æ„ç®‡æ‰€: startGame
// â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
function startGame(mode) {

    state.gameMode = mode;
 
    if (bgm.paused) {
        bgm.play().catch(e => console.log("BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:", e));
    }

    const inputName = document.getElementById('username-input').value.trim();
    const inputComment = document.getElementById('comment-input').value.trim();

    // â˜…â˜…â˜… ä¿®æ­£: PvEã§ã‚‚ãƒ©ãƒ³ãƒ€ãƒ ã«IDã‚’æ±ºã‚ã‚‹ â˜…â˜…â˜…
    if (mode === 'PvE') {
        myPlayerId = Math.random() < 0.5 ? 1 : 2; // 50%ã§1(é’)ã‹2(èµ¤)
    } else {
        myPlayerId = 1; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ä¸Šã®ä»®ç½®ã
    }

    // åå‰è¨­å®šï¼šè‡ªåˆ†ãŒ1ãªã‚‰P1ãŒè‡ªåˆ†ã€è‡ªåˆ†ãŒ2ãªã‚‰P2ãŒè‡ªåˆ†
    const p1Name = (myPlayerId === 1) ? (inputName || "PLAYER") : "CPU";
    const p1Comment = (myPlayerId === 1) ? (inputComment || "...") : "...";
    
    const p2Name = (myPlayerId === 2) ? (inputName || "PLAYER") : "CPU";
    const p2Comment = (myPlayerId === 2) ? (inputComment || "...") : "...";

    document.getElementById('title-screen').style.display = 'none';

    // è‡ªåˆ†ã®è‰²æƒ…å ±ã‚’ã‚»ãƒƒãƒˆ
    let myColorName, myColorCode, enemyName;
    if (myPlayerId === 1) {
        myColorName = "BLUE"; myColorCode = COLORS.p1; enemyName = p2Name;
    } else {
        myColorName = "RED"; myColorCode = COLORS.p2; enemyName = p1Name;
    }

    playStartAnimation(myColorName, myColorCode, enemyName, () => {
        
        document.getElementById('p1-label').innerText = p1Name;
        document.getElementById('p1-comment').innerText = p1Comment;
        document.getElementById('p2-label').innerText = p2Name;
        document.getElementById('p2-comment').innerText = p2Comment;

        initBoardUnits();
        state.turn = 1;
        state.turnPlayer = P1; // å¿…ãšé’(P1)ã‹ã‚‰é–‹å§‹
        state.phase = 'SELECT_CARD';
        state.winner = null;
        state.isCpuThinking = false;

        updateTurnVisuals();
        showToast("GAME START!");
        
        resizeCanvas();
        gameLoop();
        resetTimer(); 

        // â˜…â˜…â˜… è¿½åŠ : ã‚‚ã—è‡ªåˆ†ãŒèµ¤(P2)ãªã‚‰ã€é–‹å¹•ã™ãã«CPU(é’)ã«æ€è€ƒã•ã›ã‚‹ â˜…â˜…â˜…
        if (mode === 'PvE' && myPlayerId === 2) {
             triggerPhaseGuidance(); // ã‚¬ã‚¤ãƒ‰ã¯å‡ºã™ãŒ
             triggerCpuAction();     // ã™ãCPUãŒå‹•ã
        } else {
             triggerPhaseGuidance(); 
        }
    });
}

function playStartAnimation(myColorName, myColorCode, enemyName, callback) {
    const screen = document.getElementById('ready-screen');
    const roleText = document.getElementById('player-role-text');
    const enemyText = document.getElementById('enemy-name-display');

    roleText.innerText = myColorName;
    roleText.style.color = myColorCode;
    enemyText.innerText = enemyName;

    screen.classList.add('active');

    setTimeout(() => {
        screen.classList.remove('active');
        if (callback) callback();
    }, 2000);
}

function initBoardUnits() {
    state.hexes = [];
    for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        let r1 = Math.max(-BOARD_RADIUS, -q - BOARD_RADIUS);
        let r2 = Math.min(BOARD_RADIUS, -q + BOARD_RADIUS);
        for (let r = r1; r <= r2; r++) {
            const dist = (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
            const isEdge = dist === BOARD_RADIUS;
            
            const isCorner = (Math.abs(q) === BOARD_RADIUS && r === 0) ||
                             (Math.abs(r) === BOARD_RADIUS && q === 0) ||
                             (Math.abs(q) === BOARD_RADIUS && r === -q);

            state.hexes.push({ q, r, isEdge, isCorner });
        }
    }
    const initialPositions = [
        { q: 2, r: 0, owner: 1 }, { q: 0, r: 2, owner: 2 },
        { q: -2, r: 2, owner: 1 }, { q: -2, r: 0, owner: 2 },
        { q: 0, r: -2, owner: 1 }, { q: 2, r: -2, owner: 2 }
    ];
    state.units = [];
    initialPositions.forEach((pos, i) => {
        state.units.push({
            id: `u${i}`, owner: pos.owner, q: pos.q, r: pos.r, hp: 1000,
            animQ: pos.q, animR: pos.r
        });
    });
}

function gameLoop() {
    state.frameCount++;
    state.units.forEach(u => {
        u.animQ += (u.q - u.animQ) * 0.2;
        u.animR += (u.r - u.animR) * 0.2;
    });

    // â˜…â˜…â˜… è¿½åŠ ï¼šæºœã¾ã£ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã“ã“ã§æ¶ˆåŒ–ã—ã¾ã™ â˜…â˜…â˜…
    processPendingActions();

    draw();
    if (!state.winner) requestAnimationFrame(gameLoop);
}

// â˜…â˜…â˜… æ–°è¦è¿½åŠ ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®‰å…¨ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å–ã‚Šå‡ºã™é–¢æ•° â˜…â˜…â˜…
function processPendingActions() {
    // 1. å‡¦ç†å¾…ã¡ãŒãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
    if (!state.pendingActions || state.pendingActions.length === 0) return;

    // 2. ã€Œä»Šã€å‡¦ç†ã—ã¦ã„ã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‹ï¼Ÿã€ã‚’ãƒã‚§ãƒƒã‚¯
    // ã‚«ãƒƒãƒˆã‚¤ãƒ³ä¸­(TURN_CUTIN)ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­(ANIMATION)ã€CPUæ€è€ƒä¸­ã€å‹è² ãŒã¤ã„ãŸå¾Œã¯å‡¦ç†ã—ãªã„
    if (state.phase === 'TURN_CUTIN' || 
        state.phase === 'ANIMATION' || 
        state.isCpuThinking || 
        state.winner) {
        return; 
    }

    // 3. å®‰å…¨ãªã‚‰ã€ä¸€ç•ªå¤ã„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’1ã¤å–ã‚Šå‡ºã—ã¦å®Ÿè¡Œ
    const data = state.pendingActions.shift(); // å…ˆé ­ã‚’å–ã‚Šå‡ºã™
    executeAction(data);
}

// â˜…â˜…â˜… æ–°è¦è¿½åŠ ï¼šå®Ÿéš›ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ï¼ˆå…ƒã€…ãƒªã‚¹ãƒŠãƒ¼ã«ã‚ã£ãŸä¸­èº«ã‚’ç§»å‹•ï¼‰ â˜…â˜…â˜…
function executeAction(data) {
    if (data.type === 'SELECT_CARD') {
        uiSelectCard(data.value, true); 
        showToast("ç›¸æ‰‹ãŒã‚«ãƒ¼ãƒ‰ã‚’é¸æŠä¸­...");
    
    } else if (data.type === 'ROTATE') {
        state.hiddenRotation = { indices: data.indices };
        state.phase = 'DEFENDER_MOVE';
        state.tempRotationStart = null;
        state.validDirections = [];
        showToast("ROTATION SET!");
        updateTurnVisuals();
        resetTimer(); 

    } else if (data.type === 'MOVE') {
        state.defenderMoves = data.moves;
        showToast("ç›¸æ‰‹ãŒç§»å‹•ã—ã¾ã—ãŸ");
        startTurnResolution();
    
    } else if (data.type === 'EMOTE') {
        sendEmote(data.value, data.sender);
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    state.hexes.forEach(h => {
        const {x, y} = hexToPixel(h.q, h.r);
        
        let color = COLORS.hex;      
        let stroke = COLORS.hexEdge; 
        let lineWidth = 1;

        // ã¾ãšå¤–å‘¨ï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¾ãƒ¼ãƒ³ï¼‰ã®è‰²ã«ã™ã‚‹
        if (h.isEdge) { 
            stroke = COLORS.damageStroke; 
            lineWidth = 2; 
            color = COLORS.damageZone; 
        }

        // â–¼â–¼â–¼ â˜…è¿½åŠ ã“ã“ã‹ã‚‰â˜… â–¼â–¼â–¼
        // ã‚‚ã—ã€Œè§’ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã€ãªã‚‰ã€ã•ã‚‰ã«è‰²ã‚’ä¸Šæ›¸ãã™ã‚‹ï¼
        if (h.isCorner) {
            stroke = '#8B0000'; // æ ç·šã®è‰²ï¼ˆä¾‹ï¼šã‚´ãƒ¼ãƒ«ãƒ‰ï¼‰
            color = 'rgba(0, 0, 0, 0.9)'; // ä¸­èº«ã®è‰²ï¼ˆä¾‹ï¼šåŠé€æ˜ã®é»„è‰²ï¼‰
            lineWidth = 3; // æ ç·šã‚’å°‘ã—å¤ªãã™ã‚‹
        }

        // å›è»¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã®è‰²
        if (state.hiddenRotation && state.phase === 'ANIMATION' && state.hiddenRotation.indices.includes(getHexIndex(h.q, h.r))) {
             color = 'rgba(250, 225, 0, 0.5)';
        }
        
        drawHex(x, y, HEX_SIZE * 0.95, color, stroke, lineWidth);
        
        if (state.phase === 'DEFENDER_MOVE' && state.selectedUnit && !state.isCpuThinking) {
            if (!getUnitAt(h.q, h.r)) {
                ctx.beginPath(); ctx.arc(x, y, HEX_SIZE * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.guideMarker; ctx.fill();
            }
        }
    });

    // --- ã“ã“ã‹ã‚‰ä¸‹ã¯å¤‰æ›´ãªã— ---

    if (state.phase === 'SELECT_ROTATION') {

        if (state.tempRotationStart) {
            const startPos = hexToPixel(state.tempRotationStart.q, state.tempRotationStart.r);
            drawHex(startPos.x, startPos.y, HEX_SIZE * 0.9, '#ffd700', '#fff', 3);
            
            state.validDirections.forEach(dirObj => {
                dirObj.indices.forEach(idx => {
                    if(state.hexes[idx] === state.tempRotationStart) return;
                    const h = state.hexes[idx];
                    const p = hexToPixel(h.q, h.r);
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    drawHex(p.x, p.y, HEX_SIZE * 0.85, '#ffd700', null, 0); 
                    ctx.restore();
                });
                const lastIdx = dirObj.indices[dirObj.indices.length - 1];
                const lastHex = state.hexes[lastIdx];
                const endP = hexToPixel(lastHex.q, lastHex.r);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath(); ctx.arc(endP.x, endP.y, 4, 0, Math.PI*2); ctx.fill();
            });
        }

        if (state.previewRotation) {
            const indices = state.previewRotation.indices;
            indices.forEach(idx => {
                const h = state.hexes[idx];
                const p = hexToPixel(h.q, h.r);
                ctx.save();
                ctx.shadowColor = "#fff";
                ctx.shadowBlur = 20;
                drawHex(p.x, p.y, HEX_SIZE * 0.9, 'rgba(255, 255, 200, 0.8)', '#fff', 4);
                ctx.restore();
            });
        }
    }

    [1, 2].forEach(ownerId => {
        const myUnits = state.units.filter(u => u.owner === ownerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.animQ, u.animR));
            const isEq = isEquilateral(pts[0], pts[1], pts[2]);
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y); ctx.lineTo(pts[2].x, pts[2].y); ctx.closePath();
            const color = ownerId === 1 ? COLORS.p1 : COLORS.p2;
            if (isEq) {
                ctx.strokeStyle = color; ctx.lineWidth = 4;
                ctx.shadowColor = color; ctx.shadowBlur = 20; ctx.stroke();
                
                ctx.fillStyle = (ownerId === 1) ? COLORS.p1Triangle : COLORS.p2Triangle;
                
                ctx.fill();
            } else {

                ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.shadowBlur = 0; ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }
    });

    // â– â– â–  ä¿®æ­£ï¼šHPãƒãƒ¼ã‚’å¸¸ã«ç·‘è‰²ã«ã™ã‚‹ç‰ˆ â– â– â– 
    state.units.forEach(u => {
        const {x, y} = hexToPixel(u.animQ, u.animR);
        let color = u.owner === 1 ? COLORS.p1 : COLORS.p2;
        
        if (u.hitFlash > 0) {
             color = '#fff'; 
             u.hitFlash--;
        }

        // ç§»å‹•å…ˆã®ç‚¹ç·š
        const move = state.defenderMoves.find(m => m.unitId === u.id);
        if (move) {
            const destHex = state.hexes[move.toIndex];
            const destPos = hexToPixel(destHex.q, destHex.r);
            ctx.save();
            ctx.globalAlpha = 0.4; 
            drawHex(destPos.x, destPos.y, HEX_SIZE * 0.7, null, color, 2); 
            ctx.restore();
            ctx.beginPath();
            ctx.moveTo(x, y);
            const midX = (x + destPos.x) / 2;
            const midY = (y + destPos.y) / 2 - 30; 
            ctx.quadraticCurveTo(midX, midY, destPos.x, destPos.y);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]); 
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // é¸æŠä¸­ã®å¼·èª¿
        if (state.selectedUnit && state.selectedUnit.id === u.id) {
            ctx.beginPath(); ctx.arc(x, y, HEX_SIZE, 0, Math.PI*2);
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.stroke();
        }

        // ç™½æ ï¼ˆç´°ã‚ï¼‰
        drawHex(x, y, HEX_SIZE * 0.7, color, 'rgba(255,255,255,0.9)', 1.5);


        // â– â– â–  HPã‚²ãƒ¼ã‚¸ï¼šå¸¸ã«ç·‘è‰² â– â– â– 
        const hpPct = Math.max(0, u.hp / 1000);
        
        // â˜…å¤‰æ›´ï¼šæ¡ä»¶åˆ†å²ã‚’æ¶ˆã—ã¦ã€å¸¸ã«ç·‘è‰²ã«å›ºå®šã—ã¾ã—ãŸ
        const hpColor = 'rgba(0, 255, 0, 0.6)';
        
        const barWidth = 3; 
        const barRadius = HEX_SIZE * 0.85; 

        // èƒŒæ™¯
        drawHex(x, y, barRadius, null, 'rgba(0,0,0,0.2)', barWidth);

        const perimeter = barRadius * 6; 
        
        ctx.beginPath();
        // åæ™‚è¨ˆå›ã‚Šï¼ˆå³ã‹ã‚‰æ¸›ã‚‹ï¼‰
        for (let i = 0; i < 7; i++) { 
            const angle = -Math.PI / 2 - (2 * Math.PI / 6 * i);
            const px = x + barRadius * Math.cos(angle);
            const py = y + barRadius * Math.sin(angle);
            if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        
        ctx.setLineDash([perimeter * hpPct, perimeter]); 
        
        ctx.strokeStyle = hpColor;
        ctx.lineWidth = barWidth;
        ctx.lineCap = 'round';
        ctx.stroke();
        
        ctx.setLineDash([]); 
    });
   
    if (state.showUnitGuidance && state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1; 
        const elapsed = Date.now() - (state.guidanceStartTime || 0);
        const duration = 3000; 
        
        if (elapsed > duration) {
            state.showUnitGuidance = false; 
            return;
        }
        const fade = Math.pow(1.0 - (elapsed / duration), 2); 
        const pulse = (Date.now() % 1000) / 1000; 
        const radius = HEX_SIZE * (1.0 + pulse * 0.8);
        const alpha = (1.0 - pulse) * fade; 

        state.units.forEach(u => {
            if (u.owner === defenderId) {
                const {x, y} = hexToPixel(u.animQ, u.animR);
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`; 
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x, y, HEX_SIZE, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.8 * fade})`; 
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });
    }
}

function addDamageEffect(unit, damage) {
    unit.hitFlash = 10; 
}

function drawHex(x, y, size, fill, stroke, lw) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = 2 * Math.PI / 6 * i + Math.PI/6;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}

function updateTurnVisuals() {
    const p = state.turnPlayer;
    
    const colorLayer = document.getElementById('bg-color-layer');
    if (colorLayer) {
        colorLayer.style.backgroundColor = p.bg;
    }
    
    const indicator = document.getElementById('turn-indicator');
    const badge = document.getElementById('phase-badge');
    const cardPanel = document.getElementById('card-panel');
    const mainBtn = document.getElementById('main-btn');

    indicator.innerText = p.name; 
    indicator.style.color = p.color;

    // â˜…â˜…â˜… ä¿®æ­£ç‚¹: PvEã§ã‚‚IDã‚’ä½¿ã£ã¦æ­£ã—ãåˆ¤å®šã™ã‚‹ã‚ˆã†ã«çµ±ä¸€ â˜…â˜…â˜…
    let isMyTurn = false;
    if (state.gameMode === 'PvE' || state.gameMode === 'ONLINE') {
        isMyTurn = (p.id === myPlayerId); 
    } else {
        isMyTurn = true; // Titleç”»é¢ãªã©
    }

    if (state.isCpuThinking) {
        cardPanel.style.pointerEvents = 'none';
        mainBtn.disabled = true;
        badge.innerText = "WAIT"; 
        badge.style.color = "#aaa";
        
        // CPUæ€è€ƒä¸­ã¯ã‚«ãƒ¼ãƒ‰ãƒ‘ãƒãƒ«ã‚’éš ã™
        if (state.phase === 'SELECT_CARD') cardPanel.style.display = 'none';
        return;
    }
    
    else if (state.phase === 'TURN_CUTIN') {
        badge.innerText = "";
        cardPanel.style.display = 'none'; // ã‚«ãƒƒãƒˆã‚¤ãƒ³ä¸­ã¯æ“ä½œãƒ‘ãƒãƒ«ã‚’æ¶ˆã™
        mainBtn.style.display = 'none';
        return; // ã“ã‚Œä»¥ä¸Šã®å‡¦ç†ã¯ã—ãªã„
    }

    cardPanel.style.pointerEvents = 'auto';

    if (state.phase === 'SELECT_CARD') {
        // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã®æ™‚ã ã‘ãƒ‘ãƒãƒ«ã‚’å‡ºã™
        if (isMyTurn) {
            badge.innerText = "PICK CARD";
            badge.style.color = "#fff";
            cardPanel.style.display = 'flex';
        } else {
            badge.innerText = "OPPONENT TURN";
            badge.style.color = "#888";
            cardPanel.style.display = 'none'; // ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³ã¯éš ã™
        }
        mainBtn.style.display = 'none';
        
    } else if (state.phase === 'SELECT_ROTATION') {
        badge.innerText = ""; 
        badge.style.color = "#fff";

        if (state.previewRotation) {
            cardPanel.style.display = 'none';
            mainBtn.style.display = 'block';
            mainBtn.disabled = false;
            mainBtn.innerText = "OK";
        } else {
            // å›è»¢è»¸ã‚’é¸ã‚“ã§ã„ã‚‹æœ€ä¸­ã‚‚ã€è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã§ãªã‘ã‚Œã°éš ã™
            cardPanel.style.display = isMyTurn ? 'flex' : 'none';
            mainBtn.style.display = 'none';
        }
        
    } else if (state.phase === 'DEFENDER_MOVE') {
        badge.innerText = "MOVE"; 
        badge.style.color = "#fff"; 

        cardPanel.style.display = 'none'; mainBtn.style.display = 'block';
        
        const defender = state.turnPlayer.id === 1 ? P2 : P1;
        mainBtn.innerText = "GO";
        mainBtn.disabled = false;
        
        indicator.innerText = defender.name;
        indicator.style.color = defender.color;
        
        const colorLayer = document.getElementById('bg-color-layer');
        if (colorLayer) colorLayer.style.backgroundColor = defender.bg;
        
    } else {

        badge.innerText = "";

        cardPanel.style.display = 'none';
        mainBtn.style.display = 'none';
    }

    let activeId = state.turnPlayer.id;

    if (state.phase === 'DEFENDER_MOVE') {
        activeId = (state.turnPlayer.id === 1) ? 2 : 1;
    }

    const p1Badge = document.querySelector('.player-badge.p1');
    const p2Badge = document.querySelector('.player-badge.p2');

    if (activeId === 1) {
        // 1(é’)ã®ã‚¿ãƒ¼ãƒ³
        p1Badge.style.opacity = '1';
        p1Badge.style.transform = 'scale(1.05)'; // å°‘ã—å¤§ããå¼·èª¿
        p1Badge.style.zIndex = '110';
        
        p2Badge.style.opacity = '0.4'; // 2(èµ¤)ã¯è–„ã
        p2Badge.style.transform = 'scale(1)';
        p2Badge.style.zIndex = '100';
    } else {
        // 2(èµ¤)ã®ã‚¿ãƒ¼ãƒ³
        p1Badge.style.opacity = '0.4'; // 1(é’)ã¯è–„ã
        p1Badge.style.transform = 'scale(1)';
        p1Badge.style.zIndex = '100';
        
        p2Badge.style.opacity = '1';
        p2Badge.style.transform = 'scale(1.05)';
        p2Badge.style.zIndex = '110';
    }
}

// â– â– â–  ä¿®æ­£ç®‡æ‰€ï¼štriggerCpuAction â– â– â– 
async function triggerCpuAction() {
    if (state.gameMode !== 'PvE' || state.winner) return;
    
    // CPUã®IDã‚’ç‰¹å®šï¼ˆè‡ªåˆ†ãŒ1ãªã‚‰CPUã¯2ã€è‡ªåˆ†ãŒ2ãªã‚‰CPUã¯1ï¼‰
    const cpuId = (myPlayerId === 1) ? 2 : 1;

    // CPUãŒã‚„ã‚‹ã¹ãç•ªã‹ãƒã‚§ãƒƒã‚¯
    const isCpuAttacker = (state.turnPlayer.id === cpuId);
    const isCpuDefender = (state.turnPlayer.id !== cpuId && state.phase === 'DEFENDER_MOVE');

    // è‡ªåˆ†ã®ç•ªã˜ã‚ƒãªã„ãªã‚‰ä½•ã‚‚ã—ãªã„
    if (!isCpuAttacker && !isCpuDefender) return;

    state.isCpuThinking = true;
    updateTurnVisuals();

    await wait(1000);

    // â– â– â–  ãƒ‘ã‚¿ãƒ¼ãƒ³A: ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆCPUãŒæ”»æ’ƒå´ã®ã¨ãï¼‰ â– â– â– 
    if (state.phase === 'SELECT_CARD') {
        const bestAction = aiFindBestCardAction();
        const choice = bestAction.cardLen;
        uiSelectCard(choice, true);
        showToast(`CPU SELECT: ${choice}é€£`);
        await wait(1500);
        
        if (bestAction.indices) {
            state.hiddenRotation = { indices: bestAction.indices };
            state.phase = 'DEFENDER_MOVE';
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("CPUãŒå›è»¢ã‚’ã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
            updateTurnVisuals();    
            triggerPhaseGuidance(); 

            // â˜…â˜…â˜… ä¿®æ­£ç‚¹: ã“ã“ã«ã‚ã£ãŸ setTimeout ã‚’å‰Šé™¤ã—ã¾ã—ãŸï¼ â˜…â˜…â˜…
            // ã“ã‚Œã§CPUã¯æº€è¶³ã—ã¦åœæ­¢ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¥åŠ›å¾…ã¡ã«ãªã‚Šã¾ã™ã€‚
            
        } else {
            // ä¸‡ãŒä¸€ã®æ‰‹
            const cards = [2,3,4];
            uiSelectCard(cards[0], true);
        }
    } 
    // â– â– â–  ãƒ‘ã‚¿ãƒ¼ãƒ³B: é§’ã‚’å‹•ã‹ã™ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆCPUãŒé˜²å¾¡å´ã®ã¨ãï¼‰ â– â– â– 
    else if (state.phase === 'DEFENDER_MOVE') {
        let move1 = aiFindBestMove();
        if (move1) {
            state.defenderMoves.push({ unitId: move1.unitId, toIndex: move1.toIndex });
            
            // 1ä½“ç›®ã‚’å‹•ã‹ã—ãŸçŠ¶æ…‹ã§ã€2ä½“ç›®ã‚’æ¢ã™
            const u = state.units.find(u => u.id === move1.unitId);
            const originalQ = u.q; const originalR = u.r;
            const targetHex = state.hexes[move1.toIndex];
            u.q = targetHex.q; u.r = targetHex.r;

            let move2 = aiFindBestMove(move1.unitId);
            if (move2) {
                state.defenderMoves.push({ unitId: move2.unitId, toIndex: move2.toIndex });
            }
            // è¨ˆç®—ç”¨ã®ä»®ç§»å‹•ã‚’æˆ»ã™
            u.q = originalQ; u.r = originalR;
        }

        showToast("CPUãŒç§»å‹•ã—ã¾ã—ãŸ");
        await wait(500);
        startTurnResolution();
    }

    state.isCpuThinking = false;
    updateTurnVisuals();
}

function uiSelectCard(len, fromCpu = false) {
    if (state.isCpuThinking && !fromCpu) return;
    
    // â˜…ã“ã“ã‚’å¤‰æ›´ï¼šCPUä»¥å¤–ã®æ“ä½œãªã‚‰éŸ³ã‚’é³´ã‚‰ã™
    if (!fromCpu) {
        playSe('battle'); 
    }

    if (state.gameMode === 'ONLINE' && !fromCpu) {
        sendAction('SELECT_CARD', { value: len });
    }

    state.selectedCard = len;
    
    const svgs = {
        2: `<svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        3: `<svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        4: `<svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(61.96, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`
    };
    document.getElementById('card-info').innerHTML = svgs[len];

    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.card')[len-2].classList.add('selected');
    
    state.phase = 'SELECT_ROTATION';
    state.tempRotationStart = null;
    state.validDirections = [];
    state.previewRotation = null; 
    
    if (!fromCpu) {
        showToast("è»¸ã‚’é¸ã‚“ã§ãã ã•ã„");
    }
    updateTurnVisuals();
    
    if (!fromCpu && state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}

async function uiConfirm() {

    playSe('battle');

    if (state.isCpuThinking) return;
     clearInterval(state.timerInterval);

    if (state.gameMode === 'ONLINE') {

        const isMyPhase = 
            (state.phase === 'DEFENDER_MOVE' && (state.turnPlayer.id === 1 ? 2 : 1) === myPlayerId) ||
            (state.phase === 'SELECT_ROTATION' && state.turnPlayer.id === myPlayerId);
        
        if (!isMyPhase) return;
    }

    if (state.phase === 'SELECT_ROTATION' && state.previewRotation) {
        state.hiddenRotation = state.previewRotation;

        if (state.gameMode === 'ONLINE') {
            sendAction('ROTATE', { indices: state.hiddenRotation.indices });
        }

        state.previewRotation = null;
        state.tempRotationStart = null;
        state.validDirections = [];

        // 1. ä¸€æ—¦ UI ã‚’æ¶ˆã—ã¦ã€Œé–“ã€ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
        const prevPhase = state.phase; // å¿µã®ãŸã‚
        state.phase = 'TURN_CUTIN';    // ã“ã‚Œã§ updateTurnVisuals ãŒ UI ã‚’æ¶ˆã™
        updateTurnVisuals();

        // 2. 1ç§’å¾…ã¤ï¼ˆã‚¿ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆã¨åŒã˜æ¼”å‡ºï¼‰
        await playTurnCutIn(state.turnPlayer);

        if (state.phase !== 'TURN_CUTIN') {
            return;
        }

        state.phase = 'DEFENDER_MOVE';
        updateTurnVisuals();
        showToast("ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º");
        resetTimer();


        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        const isMyDefender = (state.gameMode === 'ONLINE') ? (defenderId === myPlayerId) : (state.gameMode === 'PvE' ? defenderId === 1 : true);

        if (isMyDefender) {
            triggerPhaseGuidance();
        }

        if (state.gameMode === 'PvE') triggerCpuAction();
        return;
    }

    if (state.phase === 'DEFENDER_MOVE') {
        if (state.gameMode === 'ONLINE') {
            sendAction('MOVE', { moves: state.defenderMoves });
        }
        startTurnResolution();
    }
}

// â˜… æ–°è¦è¿½åŠ æ©Ÿèƒ½
async function triggerPhaseGuidance() {
    // 1. UIãŒè¡¨ç¤ºã•ã‚Œã¦ã‹ã‚‰ã€Œä¸€å‘¼å¸ï¼ˆ0.5ç§’ï¼‰ã€å¾…ã¤
    await wait(500);

    // 2. ãƒ•ã‚§ãƒ¼ã‚ºã«åˆã‚ã›ã¦å…‰ã‚‰ã›ã‚‹
    if (state.phase === 'SELECT_CARD') {
        // ã‚«ãƒ¼ãƒ‰ã‚’å…¨éƒ¨å…‰ã‚‰ã›ã‚‹
        const cards = document.querySelectorAll('.card');
        cards.forEach(c => c.classList.add('suggest-glow'));
        
        // 3ç§’å¾Œã«æ¶ˆã™ï¼ˆé§’ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ™‚é–“ã«åˆã‚ã›ã‚‹ï¼‰
        setTimeout(() => {
            cards.forEach(c => c.classList.remove('suggest-glow'));
        }, 3000);

    } else if (state.phase === 'DEFENDER_MOVE') {
        // é§’ã‚’å…‰ã‚‰ã›ã‚‹ãƒ•ãƒ©ã‚°ON
        state.showUnitGuidance = true;
        
        // â˜…â˜…â˜… è¿½åŠ ï¼šä»Šã“ã®ç¬é–“ã‚’ã€Œé–‹å§‹æ™‚é–“ã€ã¨ã—ã¦è¨˜éŒ²ã™ã‚‹ â˜…â˜…â˜…
        state.guidanceStartTime = Date.now(); 
    }

}

function handleInput(x, y) {
    if (state.phase === 'TITLE' || state.phase === 'ANIMATION' || state.phase === 'TURN_CUTIN' || state.winner || state.isCpuThinking) return;

    if (state.gameMode === 'ONLINE') {
        if (state.phase === 'DEFENDER_MOVE') {
            const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
            if (defenderId !== myPlayerId) return;
        } else {
            if (state.turnPlayer.id !== myPlayerId) return;
        }
    }

    const coords = pixelToHex(x, y);
    const hexIndex = getHexIndex(coords.q, coords.r);
    
    // â–  ä½•ã‚‚ãªã„ã¨ã“ã‚ã‚’ã‚¯ãƒªãƒƒã‚¯ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«æ“ä½œï¼‰
    if (hexIndex === -1) {
        if (state.phase === 'SELECT_ROTATION' && state.tempRotationStart) {
            playSe('cancel'); // â˜…è¿½åŠ : ã‚­ãƒ£ãƒ³ã‚»ãƒ«éŸ³
            
            state.previewRotation = null;
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
            updateTurnVisuals();
        }
        return;
    }

    const clickedHex = state.hexes[hexIndex];

    // â–  å›è»¢ãƒ•ã‚§ãƒ¼ã‚ºã®æ“ä½œ
    if (state.phase === 'SELECT_ROTATION') {
        if (!state.tempRotationStart) {
            // è»¸ã‚’é¸æŠã—ãŸæ™‚
            playSe('battle'); // â˜…è¿½åŠ 
            
            state.tempRotationStart = clickedHex;
            calcValidDirections(clickedHex);
            if (state.validDirections.length === 0) {
                showToast("å›è»¢ä¸å¯"); 
                playSe('cancel'); // â˜…è¿½åŠ : ç„¡åŠ¹ãªæ™‚ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«éŸ³
                state.tempRotationStart = null;
            }
        
        } else {
            // è»¸ã‚’å†ã‚¯ãƒªãƒƒã‚¯ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰
            if (state.tempRotationStart === clickedHex) {
                playSe('cancel'); // â˜…è¿½åŠ 
                
                state.previewRotation = null;
                state.tempRotationStart = null;
                state.validDirections = [];
                showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
                updateTurnVisuals();
                return;
            }

            const clickedIndex = getHexIndex(clickedHex.q, clickedHex.r);
            const valid = state.validDirections.find(v => v.indices.includes(clickedIndex));

            if (valid) {
                playSe('battle'); // â˜…è¿½åŠ 
                
                state.previewRotation = { indices: valid.indices };
                showToast("OKãƒœã‚¿ãƒ³ã§ç¢ºå®š");
                updateTurnVisuals(); 
            } 
            else {
                playSe('cancel'); // â˜…è¿½åŠ 
                
                state.previewRotation = null;
                state.tempRotationStart = null;
                state.validDirections = [];
                showToast("ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
                updateTurnVisuals();
            }
        }
    }

    // â–  ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚ºã®æ“ä½œ
    else if (state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (defenderId !== myPlayerId) return;

        const unit = getUnitAt(clickedHex.q, clickedHex.r);
        
        if (unit && unit.owner === defenderId) {
            if (state.selectedUnit === unit) {
                playSe('cancel'); // â˜…è¿½åŠ 
                state.selectedUnit = null; 
            } else {
                playSe('battle'); // â˜…è¿½åŠ 
                state.selectedUnit = unit; 
            }
            if (state.defenderMoves.find(m => m.unitId === unit.id)) {
                state.defenderMoves = state.defenderMoves.filter(m => m.unitId !== unit.id);
            }
            updateTurnVisuals();

        } else if (state.selectedUnit && !unit) {
            const isReserved = state.defenderMoves.find(m => m.toIndex === hexIndex);
            if (isReserved) {
                showToast("æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã¾ã™");
                return;
            }
            if (state.defenderMoves.length >= 2) {
                showToast("ç§»å‹•ã§ãã‚‹ã®ã¯2ä½“ã¾ã§ï¼");
                return;
            }

            playSe('battle'); // â˜…è¿½åŠ 
            state.defenderMoves.push({ unitId: state.selectedUnit.id, toIndex: hexIndex });
            state.selectedUnit = null; 
            updateTurnVisuals();
        }
    }
}

async function startTurnResolution() {
    state.phase = 'ANIMATION';
    

    state.selectedUnit = null; 

    updateTurnVisuals();

    try {
      // â˜…è¿½åŠ ï¼šç§»å‹•ã™ã‚‹ã‚³ãƒãŒã‚ã‚Œã°ç§»å‹•éŸ³ã‚’é³´ã‚‰ã™
        if (state.defenderMoves.length > 0) {
            playSe('move');
        }

        for (let m of state.defenderMoves) {
            const u = state.units.find(u => u.id === m.unitId);
            if (!u) continue; 
            if (m.toIndex >= 0 && m.toIndex < state.hexes.length) {
                const target = state.hexes[m.toIndex];
                u.q = target.q; u.r = target.r;
            }
        }
        state.defenderMoves = [];
        await wait(800);

        if (state.hiddenRotation && state.hiddenRotation.indices) {
            const indices = state.hiddenRotation.indices;
            
            playSe('rotate');
            
            showToast("ROTATION!");
            await wait(250);
            
            let unitsOnLine = [];
            indices.forEach((hexIdx, linePos) => {
                if (!state.hexes[hexIdx]) return; 
                const h = state.hexes[hexIdx];
                const u = getUnitAt(h.q, h.r);
                if(u) unitsOnLine.push({ u, linePos });
            });
            
            const len = indices.length;
            unitsOnLine.forEach(item => {
                let nextLinePos = (len - 1) - item.linePos;
                if (indices[nextLinePos] !== undefined && state.hexes[indices[nextLinePos]]) {
                    let nextHex = state.hexes[indices[nextLinePos]];
                    item.u.q = nextHex.q; item.u.r = nextHex.r;
                }
            });
            await wait(1000);
        }

        // â˜…è¿½åŠ ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸ãŒã‚ã£ãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        let hasDamage = false;

        state.units.forEach(u => {
            const idx = getHexIndex(u.q, u.r);
            if (idx === -1) return;
            const h = state.hexes[idx];
            let damage = 0;
            if (h.isCorner) damage = 250;
            else if (h.isEdge) damage = 100;

            if (damage > 0) {
                u.hp -= damage;
                addDamageEffect(u, damage);
                hasDamage = true; // â˜…è¿½åŠ ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚ã‚Šï¼
            }
        });

        [1, 2].forEach(attackerId => {
            const myUnits = state.units.filter(u => u.owner === attackerId);
            if (myUnits.length === 3) {
                // è«–ç†åº§æ¨™ã‚’ä½¿ã£ã¦è¨ˆç®—
                const pts = myUnits.map(u => hexToLogicalPixel(u.q, u.r));
                if (isEquilateral(pts[0], pts[1], pts[2])) {
                    const defenderId = attackerId === 1 ? 2 : 1;
                    state.units.filter(u => u.owner === defenderId).forEach(target => {
                        const ratio = getTriangleOverlapRatio(target, pts[0], pts[1], pts[2]);
                        if (ratio > 0.01) { 
                            const dmg = Math.floor(350 * ratio);
                            target.hp -= dmg;
                            addDamageEffect(target, dmg);
                            hasDamage = true; // â˜…è¿½åŠ ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚ã‚Šï¼
                        }
                    });
                }
            }
        });
        
        // â˜…è¿½åŠ ï¼šèª°ã‹1äººã§ã‚‚ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¦ã„ã‚Œã°ã‚¬ãƒ©ã‚¹éŸ³ï¼
        if (hasDamage) {
            playSe('damage');
        }
        
        await wait(1500);

        const p1Lose = state.units.some(u => u.owner === 1 && u.hp <= 0);
        const p2Lose = state.units.some(u => u.owner === 2 && u.hp <= 0);
        
        if (p1Lose || p2Lose) {
            state.winner = p1Lose && p2Lose ? "DRAW" : (p1Lose ? "RED" : "BLUE");
            showResult(state.winner);
        } else {
            nextTurn();
        }

    } catch (error) {
        console.error("é‡å¤§ãªã‚¨ãƒ©ãƒ¼:", error);
        showToast("ERROR RECOVERED");
        nextTurn(); 
    }
}

async function nextTurn() {
 clearInterval(state.timerInterval);

    // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆ‡ã‚Šæ›¿ãˆï¼ˆå†…éƒ¨ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼‰ã¯å¿…ãšå…ˆã«ã‚„ã‚‹
    state.turnPlayer = state.turnPlayer.id === 1 ? P2 : P1;
    if (state.turnPlayer.id === 1) state.turn++;

    // â˜…â˜…â˜… ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ â˜…â˜…â˜…
    // ã‚‚ã—é€šä¿¡ã«ã‚ˆã£ã¦ã€ã™ã§ã«æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆã‚«ãƒ¼ãƒ‰é¸æŠæ¸ˆã¿ã‚„ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚ºï¼‰ã«é€²ã‚“ã§ã„ãŸã‚‰ã€
    // ã“ã“ã§ãƒ•ã‚§ãƒ¼ã‚ºã‚’ 'TURN_CUTIN' ã«æˆ»ã—ã¦ã—ã¾ã†ã¨ãƒã‚°ã‚‹ãŸã‚ã€å‡¦ç†ã‚’ä¸­æ–­ã™ã‚‹ã€‚
    if (state.gameMode === 'ONLINE') {
        if (state.phase === 'SELECT_ROTATION' || state.phase === 'DEFENDER_MOVE') {
            console.log("Online sync: Skip phase reset");
            updateTurnVisuals(); // è‰²ãªã©ã‚’æ­£ã—ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ›´æ–°ã—ã¦ãŠã
            return;
        }
    }
    // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…
    
    // 2. ãƒ•ã‚§ãƒ¼ã‚ºã‚’ä¸€æ™‚çš„ã«ã€Œæ¼”å‡ºä¸­ã€ã«ã—ã¦ã€æ“ä½œã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹
    state.phase = 'TURN_CUTIN'; 
    updateTurnVisuals(); 

    // 3. ã‚«ãƒƒãƒˆã‚¤ãƒ³æ¼”å‡ºã‚’å†ç”Ÿã—ã¦å¾…æ©Ÿ
    await playTurnCutIn(state.turnPlayer);

    // 4. å¾…æ©Ÿä¸­ã«é€šä¿¡ã§ãƒ•ã‚§ãƒ¼ã‚ºãŒé€²ã‚“ã§ã—ã¾ã£ãŸå ´åˆã®ã‚¬ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ã®å‡¦ç†ï¼‰
    if (state.phase !== 'TURN_CUTIN') {
        console.log("Skip phase reset due to online event");
        return; 
    }

    // 5. æ¼”å‡ºãŒçµ‚ã‚ã£ãŸã‚‰ã€å®Ÿéš›ã®æ“ä½œãƒ•ã‚§ãƒ¼ã‚ºã¸ç§»è¡Œ
    document.getElementById('card-info').innerText = "";
    state.phase = 'SELECT_CARD';
    state.selectedCard = null;
    state.hiddenRotation = null; 
    
    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    
    updateTurnVisuals(); 
    resetTimer(); 

    // â˜…â˜…â˜… ä¿®æ­£: è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã®æ™‚ã ã‘ã‚¬ã‚¤ãƒ‰ã‚’å‡ºã™ â˜…â˜…â˜…
    if (state.turnPlayer.id === myPlayerId) {
        triggerPhaseGuidance();
    }

    // â˜…â˜…â˜… ä¿®æ­£: ç›¸æ‰‹(CPU)ã®ã‚¿ãƒ¼ãƒ³ãªã‚‰CPUã‚’èµ·å‹• â˜…â˜…â˜…
    if (state.gameMode === 'PvE' && state.turnPlayer.id !== myPlayerId) {
        triggerCpuAction();
    }
}

function playTurnCutIn(player) {
    return new Promise(resolve => {
        // 1000ãƒŸãƒªç§’ï¼ˆ1ç§’ï¼‰ã®ã€Œé–“ã€ã‚’ä½œã‚‹
        setTimeout(() => {
            resolve();
        }, 1000);
    });
}

function calcValidDirections(startHex) {
    state.validDirections = [];
    DIRECTIONS.forEach((d, idx) => {
        const indices = getLineIndices(startHex, state.selectedCard, idx);
        if (indices) state.validDirections.push({ dirIdx: idx, indices: indices });
    });
}
function getLineIndices(startHex, len, dirIdx) {
    let indices = [];
    let curr = startHex;
    let dir = DIRECTIONS[dirIdx];
    for(let i=0; i<len; i++) {
        let idx = getHexIndex(curr.q, curr.r);
        if (idx === -1) return null;
        indices.push(idx);
        curr = { q: curr.q + dir.dq, r: curr.r + dir.dr };
    }
    return indices;
}
function hexToPixel(q, r) {
    const x = canvas.width/2 + HEX_SIZE * (Math.sqrt(3) * (q + r/2));
    const y = canvas.height/2 + HEX_SIZE * (3/2 * r);
    return { x, y };
}

function hexToLogicalPixel(q, r) {
    const LOGICAL_WIDTH = 1000;
    const LOGICAL_HEIGHT = 1000;
    const LOGICAL_HEX_SIZE = 50;
    
    const x = LOGICAL_WIDTH/2 + LOGICAL_HEX_SIZE * (Math.sqrt(3) * (q + r/2));
    const y = LOGICAL_HEIGHT/2 + LOGICAL_HEX_SIZE * (3/2 * r);
    return { x, y, size: LOGICAL_HEX_SIZE }; // ã‚µã‚¤ã‚ºã‚‚è¿”ã™
}

function pixelToHex(x, y) {
    const pt = { x: x - canvas.width/2, y: y - canvas.height/2 };
    const q = (Math.sqrt(3)/3 * pt.x - 1/3 * pt.y) / HEX_SIZE;
    const r = (2/3 * pt.y) / HEX_SIZE;
    return cubeRound(q, r, -q-r);
}
function cubeRound(x, y, z) {
    let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
    const x_diff = Math.abs(rx - x), y_diff = Math.abs(ry - y), z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
    else if (y_diff > z_diff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: ry };
}
function getHexIndex(q, r) { return state.hexes.findIndex(h => h.q === q && h.r === r); }
function getUnitAt(q, r) { return state.units.find(u => u.q === q && u.r === r); }
function isEquilateral(p1, p2, p3) {
    const d1 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
    const d2 = Math.hypot(p2.x-p3.x, p2.y-p3.y);
    const d3 = Math.hypot(p3.x-p1.x, p3.y-p1.y);
    const avg = (d1 + d2 + d3) / 3;
    if (avg < 10) return false;
    return Math.abs(d1 - avg) < avg * 0.1 && Math.abs(d2 - avg) < avg * 0.1 && Math.abs(d3 - avg) < avg * 0.1;
}
function getTriangleOverlapRatio(unit, t1, t2, t3) {
    // â˜…å¤‰æ›´ï¼šè«–ç†åº§æ¨™ã‚’ä½¿ã£ã¦ã€ãƒ¦ãƒ‹ãƒƒãƒˆã®ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹
    const logical = hexToLogicalPixel(unit.q, unit.r);
    const unitPos = { x: logical.x, y: logical.y };
    const visualRadius = logical.size * 0.7; 

    let hitCount = 0;

    let totalPoints = 0;

    if (isPointInTriangle(unitPos, t1, t2, t3)) hitCount++;
    totalPoints++;

    const rings = [
        { r: 0.4, count: 6 },
        { r: 0.8, count: 8 },
        { r: 1.0, count: 12 }
    ];

    rings.forEach(ring => {
        const r = visualRadius * ring.r;
        for(let i = 0; i < ring.count; i++) {
            const theta = (Math.PI * 2 / ring.count) * i;
            const p = {
                x: unitPos.x + r * Math.cos(theta),
                y: unitPos.y + r * Math.sin(theta)
            };
            if (isPointInTriangle(p, t1, t2, t3)) hitCount++;
            totalPoints++;
        }
    });

    return hitCount / totalPoints;
}

function isPointInTriangle(p, a, b, c) {
    const v0 = {x: c.x-a.x, y: c.y-a.y}, v1 = {x: b.x-a.x, y: b.y-a.y}, v2 = {x: p.x-a.x, y: p.y-a.y};
    const dot00 = v0.x*v0.x+v0.y*v0.y, dot01 = v0.x*v1.x+v0.y*v1.y, dot02 = v0.x*v2.x+v0.y*v2.y;
    const dot11 = v1.x*v1.x+v1.y*v1.y; 
    const dot12 = v1.x*v2.x+v1.y*v2.y; 
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v < 1);
}

function resizeCanvas() {
    const c = document.getElementById('game-area');
    canvas.width = c.clientWidth; canvas.height = c.clientHeight;
    HEX_SIZE = Math.min((canvas.width*0.95)/(7*Math.sqrt(3)), (canvas.height*0.95)/(7*1.5));
}

function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
window.addEventListener('resize', resizeCanvas);
const preventScroll = (e) => { e.preventDefault(); };
canvas.addEventListener('touchmove', preventScroll, {passive: false});

function onInputStart(e) {
    if (e.cancelable) e.preventDefault(); 

    const r = canvas.getBoundingClientRect();
    let clientX, clientY;

    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }

    handleInput(clientX - r.left, clientY - r.top);
}

canvas.addEventListener('touchstart', onInputStart, {passive: false});
canvas.addEventListener('mousedown', onInputStart);

resizeCanvas();

// 1. æœ€é©ãªã‚«ãƒ¼ãƒ‰ã¨å›è»¢ã‚’æ±ºã‚ã‚‹è„³ã¿ã
function aiFindBestCardAction() {
    let bestScore = -Infinity;
    let bestAction = { cardLen: 3, indices: null }; 
    
    // ã‚¨ãƒ©ãƒ¼é˜²æ­¢ã®ä¿é™ºï¼šã¨ã‚Šã‚ãˆãšæœ‰åŠ¹ãªå›è»¢ã‚’1ã¤ç¢ºä¿ã—ã¦ãŠã
    const fallbackDir = state.validDirections && state.validDirections.length > 0 ? state.validDirections[0] : null;
    if (fallbackDir) {
        bestAction.indices = fallbackDir.indices;
    }

    const cardLens = [2, 3, 4];
    
    // 2,3,4é€£ã™ã¹ã¦ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    for (let len of cardLens) {
        for (let i = 0; i < state.hexes.length; i++) {
            const h = state.hexes[i];
            for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
                const indices = getLineIndices(h, len, dirIdx);
                if (!indices) continue; // ç›¤é¢å¤–ãªã‚‰ç„¡è¦–

                const simUnits = aiSimulateRotation(indices);
                const score = aiEvaluateBoard(simUnits);
                
                // å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’å…¥ã‚Œã¦äººé–“å‘³ã‚’å‡ºã™
                if (score > bestScore + (Math.random() * 5)) { 
                    bestScore = score;
                    bestAction = { cardLen: len, indices: indices };
                }
            }
        }
    }
    
    // ä¿é™ºï¼šã‚‚ã—è¨ˆç®—çµæœãŒãŠã‹ã—ãã¦ã‚‚ã€æ­¢ã¾ã‚‰ãªã„ã‚ˆã†ã«é©å½“ãªæ‰‹ã‚’æ¢ã™
    if (!bestAction.indices) {
        for (let i = 0; i < state.hexes.length; i++) {
            const valid = getLineIndices(state.hexes[i], 3, 0);
            if (valid) {
                bestAction.indices = valid;
                bestAction.cardLen = 3;
                break;
            }
        }
    }

    return bestAction;
}

// 2. æœ€é©ãªç§»å‹•å…ˆã‚’æ±ºã‚ã‚‹è„³ã¿ãï¼ˆâ˜…ã“ã“ãŒæ¶ˆãˆã¦ã„ã¾ã—ãŸï¼ï¼‰
function aiFindBestMove(excludeUnitId = null) {
    let bestScore = -Infinity;
    let bestMove = null;

    // è‡ªåˆ†ã®è‰²ï¼ˆCPUã®è‰²ï¼‰ã‚’åˆ¤å®š
    const cpuId = (myPlayerId === 1) ? 2 : 1;
    const cpuUnits = state.units.filter(u => u.owner === cpuId);
    
    // ã™ã§ã«èª°ã‹ãŒã„ã‚‹å ´æ‰€ã‚„ã€ç§»å‹•äºˆç´„æ¸ˆã¿ã®å ´æ‰€ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
    const occupied = new Set(state.units.map(u => getHexIndex(u.q, u.r)));
    state.defenderMoves.forEach(m => occupied.add(m.toIndex));

    for (let u of cpuUnits) {
        if (excludeUnitId && u.id === excludeUnitId) continue; // ã•ã£ãå‹•ã‹ã—ãŸé§’ã¯é™¤å¤–

        const currentIdx = getHexIndex(u.q, u.r);
        
        // å…¨ãƒã‚¹ã¸ç§»å‹•ã—ã¦ã¿ã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        for (let i = 0; i < state.hexes.length; i++) {
            if (occupied.has(i)) continue; // èª°ã‹ã„ã‚‹
            if (i === currentIdx) continue; // ä»Šã„ã‚‹å ´æ‰€

            // ä»®æƒ³çš„ã«å‹•ã‹ã—ã¦ã¿ã‚‹
            const simUnits = state.units.map(unit => ({ ...unit }));
            const targetUnit = simUnits.find(unit => unit.id === u.id);
            const targetHex = state.hexes[i];
            targetUnit.q = targetHex.q;
            targetUnit.r = targetHex.r;

            let score = aiEvaluateBoard(simUnits);

            // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¾ãƒ¼ãƒ³ï¼ˆç«¯ã£ã“ï¼‰ã«ã¯æ¥µåŠ›è¡Œã‹ãªã„ã‚ˆã†ã«ã™ã‚‹
            if (targetHex.isEdge && score < 500) { 
                 score -= 1000;
            }

            if (score > bestScore + (Math.random() * 5)) {
                bestScore = score;
                bestMove = { unitId: u.id, toIndex: i };
            }
        }
    }
    return bestMove;
}

// 3. å›è»¢ã—ãŸã‚‰ã©ã†ãªã‚‹ã‹è¨ˆç®—ã™ã‚‹è£œåŠ©è„³ã¿ã
function aiSimulateRotation(indices) {
    let simUnits = state.units.map(u => ({ ...u }));
    
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        if (!state.hexes[hexIdx]) return;
        const h = state.hexes[hexIdx];
        const u = simUnits.find(unit => unit.q === h.q && unit.r === h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos;
        if (indices[nextLinePos] !== undefined && state.hexes[indices[nextLinePos]]) {
            let nextHex = state.hexes[indices[nextLinePos]];
            item.u.q = nextHex.q;
            item.u.r = nextHex.r;
        }
    });

    return simUnits;
}

// 4. ç›¤é¢ã®è‰¯ã—æ‚ªã—ã‚’ç‚¹æ•°åŒ–ã™ã‚‹è©•ä¾¡è„³ã¿ã
function aiEvaluateBoard(simUnits) {
    let score = 0;
    
    const cpuId = (myPlayerId === 1) ? 2 : 1;
    const playerId = myPlayerId;

    simUnits.forEach(u => {
        const hIdx = getHexIndex(u.q, u.r);
        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¾ãƒ¼ãƒ³ã«ã„ã‚‹ã¨æ¸›ç‚¹
        if (hIdx !== -1 && state.hexes[hIdx].isEdge) {
            if (u.owner === cpuId) score -= 2000;   
            if (u.owner === playerId) score += 300; 
        }
    });

    // ä¸‰è§’å½¢ï¼ˆãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ã‚¢ã‚¿ãƒƒã‚¯ï¼‰ã®è©•ä¾¡
    [cpuId, playerId].forEach(owner => {
        const myUnits = simUnits.filter(u => u.owner === owner);
        if (myUnits.length === 3) {
            // â˜…å¤‰æ›´ï¼šAIã®è¨ˆç®—ã‚‚è«–ç†åº§æ¨™ã§è¡Œã†
            const pts = myUnits.map(u => hexToLogicalPixel(u.q, u.r));
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const targetId = owner === cpuId ? playerId : cpuId;
                const targets = simUnits.filter(u => u.owner === targetId);
                
                let hits = 0;
                targets.forEach(t => {
                    const ratio = getTriangleOverlapRatio(t, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) hits++;
                });

                if (owner === cpuId) {
                    if (hits > 0) score += 5000 * hits; // æ”»æ’ƒãƒ’ãƒƒãƒˆã¯å¤§åŠ ç‚¹
                    else score -= 200; // ç©ºæŒ¯ã‚Šã¯éš™ã«ãªã‚‹ã®ã§å°‘ã—æ¸›ç‚¹
                } else {
                    score -= 500; // æ•µã«ä¸‰è§’å½¢ã‚’ä½œã‚‰ã‚Œã‚‹ã®ã¯å±é™º
                    if (hits > 0) score -= 20000 * hits; // è‡ªåˆ†ãŒæ’ƒãŸã‚Œã‚‹ã®ã¯æœ€æ‚ª
                }
            }
        }
    });

    return score;
}


function showResult(winnerName) {
    const screen = document.getElementById('result-screen');
    const nameEl = document.getElementById('winner-name');
    
    if (winnerName === "DRAW") {
        nameEl.innerText = "DRAW";
        nameEl.style.color = "#fff";
    } else {
        nameEl.innerText = winnerName;
        nameEl.style.color = (winnerName === "BLUE") ? COLORS.p1 : COLORS.p2;
    }

    screen.style.display = 'flex';
    setTimeout(() => {
        screen.classList.add('show');
    }, 10);
}

// â– â– â–  ä¿®æ­£ç®‡æ‰€ï¼šbackToTitle â– â– â– 
function backToTitle() {
    bgm.pause();
    bgm.currentTime = 0;

    state.pendingActions = []; 

    state.isCpuThinking = false;
    document.getElementById('settings-modal').classList.remove('active');
    document.getElementById('secret-modal').classList.remove('active');

    if (state.gameMode === 'ONLINE' && roomId) {
        const actionsRef = ref(db, roomId + '/action');
        off(actionsRef);

        const roomRef = ref(db, roomId);
        off(roomRef);

        const targetRoom = roomId; 
        roomId = null;             
        
        remove(ref(db, targetRoom))
            .then(() => console.log("éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"))
            .catch((e) => console.error("å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", e));
    }

    const resScreen = document.getElementById('result-screen');
    resScreen.classList.remove('show');

    setTimeout(() => resScreen.style.display = 'none', 500);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    document.getElementById('turn-indicator').innerText = "";
    document.getElementById('card-info').innerHTML = "";

    document.getElementById('title-screen').style.display = 'flex';
}

function quitGame() {
    if (!confirm("ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å¯¾æˆ¦ã¯ç ´æ£„ã•ã‚Œã¾ã™ï¼‰")) {
        return;
    }

    state.winner = "QUIT"; 
    state.isCpuThinking = false;

    backToTitle();
}

function toggleEmoteMenu() {
    document.getElementById('emote-menu').classList.toggle('show');
}

function sendEmote(emoji, forceOwnerId = null) {
    const now = Date.now();
    if (!forceOwnerId && now - state.lastEmoteTime < 3000) { 
        showToast("å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...");
        return; 
    }
    if (!forceOwnerId) state.lastEmoteTime = now;

    document.getElementById('emote-menu').classList.remove('show');

    if (state.gameMode === 'ONLINE' && !forceOwnerId) {
        sendAction('EMOTE', { value: emoji });
    }

    let ownerId;

    if (forceOwnerId) {
        ownerId = forceOwnerId;
    } else {
        if (state.gameMode === 'PvE') ownerId = 1;
        else ownerId = state.turnPlayer.id;
    }

    const el = document.createElement('div');
    el.innerText = emoji;
    
    el.style.position = 'fixed';
    el.style.zIndex = '9999';
    el.style.fontSize = '40px';
    el.style.fontWeight = 'bold';
    el.style.pointerEvents = 'none';
    el.style.textShadow = '0 4px 10px rgba(0,0,0,0.5)';
    el.style.fontFamily = "Arial, sans-serif";

    const topPosition = '120px';

    if (ownerId === 1) {
        el.style.left = '40px'; 
        el.style.top = topPosition;
        el.style.transformOrigin = 'center left';
    } else {
        el.style.right = '40px';
        el.style.top = topPosition;
        el.style.transformOrigin = 'center right';
    }

    document.body.appendChild(el);

    const anim = el.animate([
        { transform: 'scale(0) translateY(20px)', opacity: 0 },
        { transform: 'scale(1.2) translateY(0)', opacity: 1, offset: 0.1 },
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.2 },
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.7 },
        { transform: 'scale(1.0) translateY(-50px)', opacity: 0 }
    ], {
        duration: 1500,
        easing: 'ease-out'
    });

    anim.onfinish = () => el.remove();
}

let roomId = null;
let myPlayerId = 0; 

window.startOnlineGame = function() { 
    if (bgm.paused) {
        bgm.play().catch(()=>{});
    }

    const inputRoom = document.getElementById('room-input').value.trim();

    if (!inputRoom) {
        alert("åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
    }
    
    const sanitizedRoomId = inputRoom.replace(/[.#$\[\]\/]/g, '');

    if (!sanitizedRoomId) {
        alert("ãã®åˆè¨€è‘‰ã¯ä½¿ãˆã¾ã›ã‚“ï¼ˆç¦æ­¢è¨˜å·ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼‰");
        return;
    }

    roomId = "rooms_v2/" + sanitizedRoomId;
    
    const myName = document.getElementById('username-input').value.trim() || "PLAYER";

    const roomRef = ref(db, roomId);
    get(roomRef).then((snapshot) => {
        if (!snapshot.exists()) {
            createRoom(myName);
        } else {
            const data = snapshot.val();
            if (!data.p1) {
                joinRoom(myName, 1);
            } else if (!data.p2) {
                joinRoom(myName, 2);
            } else {
                alert("ãã®éƒ¨å±‹ã¯æº€å“¡ã§ã™ï¼åˆ¥ã®åˆè¨€è‘‰ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚");
            }
        }
    }).catch((error) => {
        console.error(error);
        alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
    });
};

function showToast(msg) {
    // é€šçŸ¥ã‚’å‡ºã•ãªã„ã‚ˆã†ã«ã™ã‚‹
    return;
}

function createRoom(name) {
    myPlayerId = Math.random() < 0.5 ? 1 : 2;
    
    const myComment = document.getElementById('comment-input').value.trim() || "...";

    const roomData = {
        p1: myPlayerId === 1 ? name : null,
        p1Comment: myPlayerId === 1 ? myComment : null,
        
        p2: myPlayerId === 2 ? name : null,
        p2Comment: myPlayerId === 2 ? myComment : null,
        
        status: "waiting",
        turn: 1,
        lastUpdate: Date.now()
    };

    const roomRef = ref(db, roomId);
    set(roomRef, roomData);

    onDisconnect(roomRef).remove(); 

    waitForOpponent();
}

function joinRoom(name, joinAsId) {
    myPlayerId = joinAsId;

    const myComment = document.getElementById('comment-input').value.trim() || "...";

    const updates = {};
    updates[`p${myPlayerId}`] = name;
    updates[`p${myPlayerId}Comment`] = myComment;
    updates["status"] = "ready";
    
    const roomRef = ref(db, roomId);

    update(roomRef, updates)
        .then(() => {
            startGameOnline(); 
        });

    onDisconnect(roomRef).remove();
}

function waitForOpponent() {
    const inputVal = document.getElementById('room-input').value;
    document.getElementById('display-room-id').innerText = inputVal;

    document.getElementById('secret-modal').classList.remove('active');
    document.getElementById('waiting-modal').classList.add('active');

    const waitTargetId = myPlayerId === 1 ? 2 : 1;
    const waitRef = ref(db, roomId + `/p${waitTargetId}`);
    
    onValue(waitRef, (snapshot) => {
        if (snapshot.exists()) {
            document.getElementById('waiting-modal').classList.remove('active');
            showToast("ç›¸æ‰‹ãŒå‚åŠ ã—ã¾ã—ãŸï¼");
            
            setTimeout(() => {
                startGameOnline(); 
            }, 500); 
        }
    });
}

window.shareInviteLink = async function() {
    const inputVal = document.getElementById('room-input').value;
    const baseUrl = window.location.href.split('?')[0];
    const inviteUrl = `${baseUrl}?room=${inputVal}`;
    
    const shareData = {
        title: 'HONEY NOW',
        text: `åˆè¨€è‘‰ã€Œ${inputVal}ã€ã§å¯¾æˆ¦ã—ã‚ˆã†ï¼`,
        url: inviteUrl,
    };

    if (navigator.share) {
        try {
            await navigator.share(shareData); 
        } catch (err) {
        }
    } else {
        navigator.clipboard.writeText(inviteUrl).then(() => {
            showToast("URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼");
        }).catch(() => {
            showToast("æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„");
            prompt("ã“ã®URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦é€ã£ã¦ã­", inviteUrl);
        });
    }
};

window.cancelWait = function() {
    if (roomId) {
        remove(ref(db, roomId));
        roomId = null;
    }
    document.getElementById('waiting-modal').classList.remove('active');
    document.getElementById('title-screen').style.display = 'flex';
};

// â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
// 2ã¤ç›®ã®è¦æ³¨æ„ç®‡æ‰€: startGameOnline
// â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
function startGameOnline() {
    state.gameMode = 'ONLINE';
    state.turn = 1;
    state.turnPlayer = P1;
    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    
    document.getElementById('title-screen').style.display = 'none';

    get(ref(db, roomId)).then((snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        const p1Name = data.p1 || "PLAYER 1";
        const p1Comment = data.p1Comment || "..."; 
        const p2Name = data.p2 || "PLAYER 2";
        const p2Comment = data.p2Comment || "..."; 

        if (myPlayerId === 1) {
            document.getElementById('p1-label').innerText = p1Name;
            document.getElementById('p1-comment').innerText = p1Comment; 
            document.getElementById('p2-label').innerText = p2Name;
            document.getElementById('p2-comment').innerText = p2Comment; 
        } else {
            document.getElementById('p1-label').innerText = p1Name; 
            document.getElementById('p1-comment').innerText = p1Comment; 
            document.getElementById('p2-label').innerText = p2Name;
            document.getElementById('p2-comment').innerText = p2Comment; 
        }

        let myColorName, myColorCode, enemyName;
        
        if (myPlayerId === 1) {
            myColorName = "BLUE";
            myColorCode = COLORS.p1;
            enemyName = p2Name;
        } else {
            myColorName = "RED";
            myColorCode = COLORS.p2;
            enemyName = p1Name;
        }

        playStartAnimation(myColorName, myColorCode, enemyName, () => {
            
            initBoardUnits();
            resizeCanvas();
            updateTurnVisuals();
            gameLoop();
            resetTimer();
            startOnlineListener();
            
        });

    }).catch((err) => {
        console.error("é–‹å§‹ã‚¨ãƒ©ãƒ¼:", err);
        alert("é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ");
        backToTitle();
    });
} // startGameOnline çµ‚äº†

function resetTimer() {
    clearInterval(state.timerInterval);
    state.timeLeft = 30; 
    updateTimerDisplay();

    state.timerInterval = setInterval(() => {
        state.timeLeft--;
        updateTimerDisplay();

        const timeLimit = (state.gameMode === 'ONLINE') ? -2 : 0;

        if (state.timeLeft <= timeLimit) {
            clearInterval(state.timerInterval);
            handleTimeout(); 
        }
    }, 1000);
}

function updateTimerDisplay() {
    const el = document.getElementById('timer-display');
    if (!el) return;
    
    el.innerText = Math.max(0, state.timeLeft);
    
    if (state.timeLeft <= 10) {
        el.classList.add('danger');
    } else {
        el.classList.remove('danger');
    }
}

// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®å‡¦ç†ï¼ˆä¿®æ­£ç‰ˆï¼‰
function handleTimeout() {
    // 1. CPUæ€è€ƒä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
    if (state.isCpuThinking) return;

    // 2. ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®å ´åˆã®å³å¯†ãªãƒã‚§ãƒƒã‚¯
    if (state.gameMode === 'ONLINE') {
        let currentActorId;
        
        if (state.phase === 'SELECT_CARD') {
            currentActorId = state.turnPlayer.id; 
        } else if (state.phase === 'SELECT_ROTATION') {
            currentActorId = state.turnPlayer.id; 
        } else if (state.phase === 'DEFENDER_MOVE') {
            currentActorId = (state.turnPlayer.id === 1) ? 2 : 1;
        } else {
            return;
        }

        if (currentActorId !== myPlayerId) {
            console.log("Time up on client, but waiting for opponent...");
            return;
        }
    }
    
    showToast("TIME UP!");
    
    // â–¼â–¼â–¼ ã“ã“ã‚’ä¿®æ­£ã—ã¾ã—ãŸ â–¼â–¼â–¼
    if (state.phase === 'SELECT_CARD') {
        // (1) ã¾ãšä¸€ç•ªå°ã•ã„ã‚«ãƒ¼ãƒ‰ã‚’å¼·åˆ¶é¸æŠ
        uiSelectCard(2); 

        // (2) ã•ã‚‰ã«ã€Œç½®ã‘ã‚‹å ´æ‰€ã€ã‚’è‡ªå‹•ã§æ¢ã—ã¦æ±ºå®šã—ã¦ã—ã¾ã†
        // ã™ã¹ã¦ã®ãƒã‚¹ã‚’èª¿ã¹ã¦ã€æœ€åˆã«ç½®ã‘ã‚‹å ´æ‰€ï¼ˆæ–¹å‘0ï¼‰ã§ç¢ºå®šã•ã›ã‚‹
        for (let h of state.hexes) {
            const indices = getLineIndices(h, 2, 0); // æ–¹å‘0ã§ãƒã‚§ãƒƒã‚¯
            if (indices) {
                // å›è»¢æƒ…å ±ã‚’ç¢ºå®š
                state.hiddenRotation = { indices: indices };
                if (state.gameMode === 'ONLINE') sendAction('ROTATE', { indices: indices });
                
                // æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆç§»å‹•ï¼‰ã¸å¼·åˆ¶ç§»è¡Œ
                state.phase = 'DEFENDER_MOVE';
                updateTurnVisuals();
                resetTimer(); // ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ç§»å‹•æ™‚é–“ã‚’ç¢ºä¿
                break; // ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
            }
        }

    } else if (state.phase === 'SELECT_ROTATION') {
         // å›è»¢å ´æ‰€ã‚’é¸ã‚“ã§ã„ã‚‹é€”ä¸­ã§ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—ã—ãŸå ´åˆ
         if (state.validDirections.length > 0) {
            const valid = state.validDirections[0];
            state.hiddenRotation = { indices: valid.indices };
            if (state.gameMode === 'ONLINE') sendAction('ROTATE', { indices: valid.indices });
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals();
            resetTimer(); // ç§»å‹•æ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆ
        } else {
            // ä¸‡ãŒä¸€ç½®ã‘ã‚‹å ´æ‰€ãŒãªã„å ´åˆï¼ˆãƒã‚°å›é¿ç”¨ï¼‰
            state.phase = 'SELECT_CARD';
            resetTimer(); 
        }

    } else if (state.phase === 'DEFENDER_MOVE') {
        // ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚ºã§æ™‚é–“åˆ‡ã‚Œãªã‚‰ã€ãã®ã¾ã¾ç¢ºå®šï¼ˆç§»å‹•ãªã—ï¼‰
        uiConfirm();
    }
}

function sendAction(type, data) {
    if (state.gameMode !== 'ONLINE') return;
    
    push(ref(db, roomId + "/action"), {
        type: type,
        sender: myPlayerId,
        ...data,
        timestamp: Date.now()
    });
}

window.openSettings = function() {
    document.getElementById('settings-modal').classList.add('active');
};

window.closeSettings = function() {
    document.getElementById('settings-modal').classList.remove('active');
};

window.openSecretModal = function() {
    document.getElementById('secret-modal').classList.add('active');
    setTimeout(() => {
        document.getElementById('room-input').focus();
    }, 100);
};
window.closeSecretModal = function() {
    document.getElementById('secret-modal').classList.remove('active');
};

function startOnlineListener() {
    const actionsRef = ref(db, roomId + '/action');
    
    onChildAdded(actionsRef, (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        // è‡ªåˆ†ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ç„¡è¦–
        if (data.sender === myPlayerId) return;

        // â˜…â˜…â˜… ä¿®æ­£ç‚¹ï¼šã™ãå®Ÿè¡Œã›ãšã€ã‚­ãƒ¥ãƒ¼ï¼ˆå¾…ã¡è¡Œåˆ—ï¼‰ã«è¿½åŠ ã™ã‚‹ã ã‘ã«ã™ã‚‹ â˜…â˜…â˜…
        state.pendingActions.push(data);
    });

    // â–¼ é€€å‡ºæ¤œçŸ¥ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ãã®ã¾ã¾ç¶­æŒ
    const roomRef = ref(db, roomId);
    onValue(roomRef, (snapshot) => {
        if (state.gameMode === 'ONLINE' && !snapshot.exists() && !state.winner) {
            if (roomId) { 
                alert("å¯¾æˆ¦ãŒçµ‚äº†ã—ã¾ã—ãŸï¼ˆç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸï¼‰");
                off(ref(db, roomId + '/action'));
                off(ref(db, roomId));
                roomId = null; 
                state.gameMode = 'TITLE'; 
                backToTitle();
            }
        }
    });
}

window.playSe = playSe; 
window.startGame = startGame;
window.uiSelectCard = uiSelectCard;
window.uiConfirm = uiConfirm;
window.quitGame = quitGame;
window.backToTitle = backToTitle;
window.toggleEmoteMenu = toggleEmoteMenu;
window.sendEmote = sendEmote;

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        bgm.pause();
    } else {
        const isTitleHidden = document.getElementById('title-screen').style.display === 'none';
        const isResultHidden = document.getElementById('result-screen').style.display === 'none';
        if (isTitleHidden && isResultHidden) {
            bgm.play().catch(e => console.log("BGMå†é–‹ã‚¨ãƒ©ãƒ¼:", e));
        }
    }
});

window.addEventListener('DOMContentLoaded', () => {
    const params = new URLSearchParams(window.location.search);
    const inviteRoom = params.get('room');
    if (inviteRoom) {
        document.getElementById('room-input').value = inviteRoom;
        document.getElementById('username-input').focus();
        showToast("æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼");
    }
});

</script>
</body>
</html>
