<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>HONEY NOW</title>

    <style>
/* å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
body {
    margin: 0; padding: 0;
    background-color: #050505;
    color: #fff;
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    display: flex; flex-direction: column;
    position: fixed; width: 100%; height: 100svh;
    touch-action: none; -webkit-text-size-adjust: 100%;
    overflow: hidden; transition: background-color 0.5s ease;
}

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆã“ã“ãŒãƒã‚°ã®åŸå› ã§ã—ãŸï¼‰ â–¼â–¼â–¼ */
#title-screen {
    position: absolute; /* ç”»é¢å…¨ä½“ã«é‡ã­ã‚‹ */
    top: 0; left: 0;
    width: 100%; height: 100%;
    
    display: flex; /* ä¸­èº«ã‚’ä¸­å¤®æƒãˆã«ã™ã‚‹ */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    
    background: none; /* èƒŒæ™¯è‰²ã¯æ¶ˆã™ï¼ˆç”»åƒãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä½¿ã†ãŸã‚ï¼‰ */
    z-index: 200; /* ã‚²ãƒ¼ãƒ ç”»é¢ã‚ˆã‚Šæ‰‹å‰ã« */
}

/* èƒŒæ™¯ç”»åƒå°‚ç”¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
.bg-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-image: url('bg_title.png');
    background-size: cover;
    background-position: center;
    z-index: -1;
}

/* ãƒ­ã‚´ã®è¨­å®š */
#game-logo {
    width: 60%; max-width: 450px; height: auto;
    margin-bottom: 10px;
    animation: floating 3s ease-in-out infinite;
    filter: drop-shadow(0 10px 10px rgba(0,0,0,0.3));
}
@keyframes floating {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}

/* æ­¯è»Šã‚¢ã‚¤ã‚³ãƒ³ */
#gear-btn {
    position: absolute;
    top: max(20px, env(safe-area-inset-top));
    left: 20px;
    width: 50px; height: 50px;
    cursor: pointer;
    transition: transform 0.5s;
    filter: drop-shadow(0 2px 5px rgba(0,0,0,0.5));
    z-index: 10;
}
#gear-btn:hover { transform: rotate(180deg); }

/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ç¾¤ */
.menu-container {
    display: flex; flex-direction: column;
    gap: 20px; width: 100%; align-items: center;
}

/* æœ¨ã®ãƒœã‚¿ãƒ³ */
.wooden-btn {
    width: 240px; height: 90px;
    background-image: url('btn_wood.png');
    background-size: 100% 100%;
    background-repeat: no-repeat;
    background-position: center;
    display: flex; justify-content: center; align-items: center;
    cursor: pointer; transition: transform 0.1s;
    filter: drop-shadow(0 5px 10px rgba(0,0,0,0.4));
}
.wooden-btn:active { transform: scale(0.95); }

.wooden-btn .btn-text {
    font-size: 32px; font-weight: 900; color: #fff;
    text-shadow: 2px 2px 0 #5d3a1a, -1px -1px 0 #5d3a1a, 0 0 10px rgba(0,0,0,0.5);
    font-family: 'Arial Black', sans-serif; letter-spacing: 2px;
    position: relative; top: -2px;
}
.wooden-btn.small { position: relative; width: 180px; height: 60px; margin-top: 15px;
left: 70px;}
.wooden-btn.small .btn-text { font-size: 24px; }

/* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€šè¨­å®š */
.modal-overlay {
    display: none;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
    justify-content: center; align-items: center; z-index: 300;
}
.modal-overlay.active { display: flex; }

.modal-box {
    background: rgba(255, 255, 255, 0.95);
    padding: 30px; border-radius: 20px;
    width: 80%; max-width: 320px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 4px solid #ffd700; color: #333;
}
.modal-box h2 {
    margin: 0 0 20px 0; color: #ff8c00; font-weight: 900;
    font-size: 28px; letter-spacing: 2px; text-shadow: 2px 2px 0 #fff;
}
.modal-box label {
    display: block; text-align: left; font-weight: bold;
    margin-top: 15px; font-size: 14px; color: #666;
}
.modal-box input[type="text"] {
    width: 100%; padding: 10px; font-size: 18px;
    border: 2px solid #ccc; border-radius: 10px; margin-top: 5px;
    box-sizing: border-box; text-align: center;
    background: #f9f9f9; color: #333;
}
input[type=range] { width: 100%; margin: 10px 0 20px 0; cursor: pointer; }

.close-btn {
    background: #ff8c00; color: #fff; border: none;
    padding: 10px 30px; font-size: 18px; border-radius: 30px;
    font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #cc7000; margin-top: 10px;
}
.close-btn:active { transform: translateY(4px); box-shadow: none; }
.text-btn {
    background: none; border: none; color: #888;
    font-weight: bold; margin-top: 15px; cursor: pointer; text-decoration: underline;
}

/* --- ãã®ä»–ã®æ—¢å­˜ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã€ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ãªã©ï¼‰ --- */
header {
    padding: 20px; padding-top: max(40px, env(safe-area-inset-top));
    background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0));
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    pointer-events: none;
}
.score-board {
    display: flex; justify-content: center; align-items: flex-start;
    width: 100%; height: 60px; padding: 0 10px; box-sizing: border-box; position: relative;
}
.player-badge {
    position: absolute; top: 5px; z-index: 100;
    display: flex; flex-direction: column; justify-content: center;
    width: 85px; min-height: 40px; align-items: flex-start; text-align: left;
    padding: 5px 8px; border-radius: 6px; background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.3); backdrop-filter: blur(4px); transition: all 0.3s;
}
.player-badge.p1 { left: 0; box-shadow: 0 0 8px rgba(0, 204, 255, 0.2) inset; border-color: rgba(0, 204, 255, 0.4); }
.player-badge.p2 { right: 0; box-shadow: 0 0 8px rgba(255, 51, 102, 0.2) inset; border-color: rgba(255, 51, 102, 0.4); }
.badge-name { font-size: 13px; font-weight: 900; letter-spacing: 0.5px; width: 100%; word-break: break-word; line-height: 1.1; }
.badge-comment { font-size: 9px; color: #ccc; word-break: break-word; line-height: 1.2; opacity: 0.9; }

#turn-indicator { font-size: 40px; font-weight: 900; text-shadow: 0 0 20px currentColor; letter-spacing: 4px; line-height: 1; margin: 0 10px; }
#phase-badge { position: relative; left: 3px; height: 24px; line-height: 24px; margin-bottom: 5px; font-size: 16px; font-weight: 800; text-transform: uppercase; letter-spacing: 8px; opacity: 0.8; text-shadow: 0 2px 4px rgba(0,0,0,0.8); width: 100%; text-align: center; }
#card-info { position: relative; left: 5px; color: #ffd700; height: 40px; display: flex; align-items: center; justify-content: center; margin-top: 1px; }
#card-info svg { height: 100%; width: auto; fill: currentColor; }

#timer-display { position: absolute; top: 80px; right: 180px; font-size: 30px; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.8); font-family: 'Courier New', Courier, monospace; z-index: 100; transition: color 0.3s; }
#timer-display.danger { color: #ff3333; text-shadow: 0 0 15px #ff0000; animation: pulse 0.5s infinite alternate; }
@keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }

#game-area { flex: 1; position: relative; display: flex; justify-content: center; align-items: center; overflow: hidden; }
canvas { filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5)); position: relative; top: -10px; }

footer { padding: 20px; padding-bottom: max(50px, env(safe-area-inset-bottom)); background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); display: flex; flex-direction: column; gap: 0; border-top: 1px solid rgba(255,255,255,0.1); }
#action-area { width: 100%; height: 80px; display: flex; justify-content: center; align-items: center; }
#card-panel { width: 100%; display: flex; justify-content: center; gap: 15px; }
.card { background: linear-gradient(145deg, #2a2a2a, #333); border: 2px solid #555; color: #aaa; padding: 5px 0; width: 30%; display: flex; justify-content: center; align-items: center; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: all 0.2s; }
.card svg { height: 28px; width: auto; fill: currentColor; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); max-width: 95%; position: relative; left: 5px; }
.card.selected { border-color: #ffd700; background: linear-gradient(145deg, #ffd700, #ffaa00); color: #000; transform: translateY(-5px); box-shadow: 0 10px 15px rgba(255, 215, 0, 0.3); }

#main-btn { font-family: 'Arial Black', sans-serif; font-size: 24px; width: 100%; padding: 18px; background: linear-gradient(90deg, #ff8c00, #ff0080); color: #fff; border: none; border-radius: 12px; font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 4px 15px rgba(255, 0, 128, 0.4); transition: transform 0.1s; }
#main-btn:disabled { background: #444; color: #888; box-shadow: none; cursor: not-allowed; }
#main-btn:active { transform: scale(0.98); }

#result-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; }
#result-screen.show { opacity: 1; pointer-events: auto; }
.result-label { font-size: 24px; color: #fff; letter-spacing: 10px; margin-bottom: 10px; opacity: 0.8; }
#winner-name { font-size: 60px; font-weight: 900; text-shadow: 0 0 30px currentColor; letter-spacing: 5px; transform: scale(0.5); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
#result-screen.show #winner-name { transform: scale(1); }
.mode-btn { padding: 15px 40px; font-size: 20px; font-weight: bold; color: #fff; background: transparent; border: 2px solid #fff; border-radius: 50px; cursor: pointer; transition: all 0.2s; }

#quit-btn { position: absolute; top: max(10px, env(safe-area-inset-top)); left: 10px; z-index: 150; background: rgba(0, 0, 0, 0.5); color: rgba(255, 255, 255, 0.7); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 20px; padding: 5px 15px; font-size: 14px; font-weight: bold; cursor: pointer; backdrop-filter: blur(4px); transition: all 0.2s; }
#title-screen[style*="flex"] ~ #quit-btn { display: none; }

#toast { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: #fff; padding: 10px 20px; border-radius: 30px; font-weight: bold; opacity: 0; transition: opacity 0.3s; pointer-events: none; white-space: nowrap; border: 1px solid rgba(255,255,255,0.2); z-index: 400; }

#emote-container { position: fixed; bottom: 160px; right: 20px; z-index: 150; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: none; }
#emote-btn { pointer-events: auto; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #fff, #ddd); border: none; font-size: 24px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; transition: transform 0.1s; }
#emote-btn:active { transform: scale(0.9); }
#emote-menu { background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(5px); padding: 10px; border-radius: 15px; display: flex; flex-wrap: wrap; width: 140px; gap: 8px; justify-content: center; border: 1px solid rgba(255,255,255,0.2); opacity: 0; transform: scale(0.8) translateY(20px); pointer-events: none; transition: all 0.2s; }
#emote-menu.show { opacity: 1; transform: scale(1) translateY(0); pointer-events: auto; }
.emote-item { font-size: 28px; cursor: pointer; transition: transform 0.1s; user-select: none; }
.emote-item:hover { transform: scale(1.2); }

    </style>
</head>
<body>

<div id="result-screen" style="display: none;">
    <div class="result-label">WINNER</div>
    <div id="winner-name">BLUE</div>
    <button class="mode-btn" onclick="backToTitle()" style="margin-top: 40px;">TITLE</button>
</div>

<button id="quit-btn" onclick="quitGame()">TOP</button>

<div id="title-screen">
    <div class="bg-layer"></div>

    <img src="icon_gear.png" id="gear-btn" onclick="openSettings()">

    <img src="logo.png" id="game-logo" alt="HONEY NOW">

    <div class="menu-container">
        <div class="wooden-btn" onclick="openSecretModal()">
            <span class="btn-text">ONLINE</span>
        </div>

        <div class="wooden-btn" onclick="startGame('PvE')">
            <span class="btn-text">CPU</span>
        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SETTINGS</h2>
            
            <label>NAME</label>
            <input type="text" id="username-input" placeholder="PLAYER" maxlength="6">
            
            <label>COMMENT</label>
            <input type="text" id="comment-input" placeholder="..." maxlength="30">
            
            <label>BGM VOLUME</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.1" oninput="changeVolume(this.value)">
            
            <button class="close-btn" onclick="closeSettings()">OK</button>
        </div>
    </div>

    <div id="secret-modal" class="modal-overlay">
        <div class="modal-box">
            <h2>SECRET WORD</h2>
            <p style="font-size:12px; margin-bottom:10px;">åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ã­</p>
            
            <input type="text" id="room-input" placeholder="ENTER WORD" maxlength="10">
            
            <div class="wooden-btn small" onclick="startOnlineGame()">
                <span class="btn-text">GO!</span>
            </div>
            
            <button class="text-btn" onclick="closeSecretModal()">CANCEL</button>
        </div>
    </div>
</div>

<header>
    <div class="score-board">
        <div class="player-badge p1">
            <div class="badge-name" id="p1-label">PLAYER</div>
            <div class="badge-comment" id="p1-comment">READY?</div>
        </div>
        
        <div id="turn-indicator">BLUE</div>
        
        <div class="player-badge p2">
            <div class="badge-name" id="p2-label">CPU</div>
            <div class="badge-comment" id="p2-comment">...</div>
        </div>
    </div>

    <div id="card-info"></div>
    <div id="phase-badge">PICK CARD</div>

    <div id="timer-display">30</div>
    </header>

<div id="game-area">
    <canvas id="board"></canvas>
    <div id="toast"></div>
</div>

<div id="emote-container">
    <div id="emote-menu">
        <div class="emote-item" onclick="sendEmote('ğŸ˜€')">ğŸ˜€</div>
        <div class="emote-item" onclick="sendEmote('ğŸ¤”')">ğŸ¤”</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜±')">ğŸ˜±</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜')">ğŸ˜</div>
        <div class="emote-item" onclick="sendEmote('ğŸ‘')">ğŸ‘</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜¡')">ğŸ˜¡</div>
    </div>
    <button id="emote-btn" onclick="toggleEmoteMenu()">ğŸ’¬</button>
</div>

<footer>
    <div id="action-area">
        <div id="card-panel">
            <div class="card" onclick="uiSelectCard(2)">
                <svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
            
            <div class="card" onclick="uiSelectCard(3)">
                <svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>

            <div class="card" onclick="uiSelectCard(4)">
                <svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(61.96, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
        </div>

        <button id="main-btn" onclick="uiConfirm()" disabled>GO!</button>
    </div>
    </footer>

<script type="module">
  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å®‰å®šç‰ˆã® 10.7.1 ã«çµ±ä¸€ã™ã‚‹ã®ãŒç„¡é›£ã§ã™
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
  
  // â–¼â–¼â–¼ ã“ã‚Œã‚’è¿½åŠ ï¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ã†ãŸã‚ã®éƒ¨å“ â–¼â–¼â–¼
import { getDatabase, ref, set, onValue, update, remove, get, child, onDisconnect } 
from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyDswxDswxU_DU-DdhYI8KsANtVeYVP6NN4",
    authDomain: "honeynow-7fe79.firebaseapp.com",
    
    /* â–¼â–¼â–¼ ã“ã‚Œã‚’è¿½åŠ ï¼ â–¼â–¼â–¼ */
    databaseURL: "https://honeynow-7fe79-default-rtdb.firebaseio.com",
    /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ï¼ˆæœ€å¾Œã®ã‚«ãƒ³ãƒã‚’å¿˜ã‚Œãšã«ï¼ï¼‰ â–²â–²â–² */
    
    projectId: "honeynow-7fe79",
    storageBucket: "honeynow-7fe79.firebasestorage.app",
    messagingSenderId: "745229921816",
    appId: "1:745229921816:web:345524bda3da61f8c7dd6d",
    measurementId: "G-RTEVBEYH3M"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);

  // â–¼â–¼â–¼ ã“ã‚Œã‚‚è¿½åŠ ï¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èµ·å‹• â–¼â–¼â–¼
  const db = getDatabase(app);

/** * å®šæ•°ãƒ»è¨­å®š */

const BOARD_RADIUS = 3;

/* â–¼â–¼â–¼ è¿½åŠ ï¼šBGMã®è¨­å®š â–¼â–¼â–¼ */
const bgm = new Audio('bgm.mp3'); // ãƒ•ã‚¡ã‚¤ãƒ«åã¨åˆã‚ã›ã‚‹
bgm.loop = true;   // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã™ã‚‹
bgm.volume = 0.1;  // éŸ³é‡ (0.0 ã€œ 1.0) 

const COLORS = {

    p1: '#00ccff', p1Bg: '#001a33',
    p2: '#ff3366', p2Bg: '#2a0a12',
    hex: '#222', hexEdge: '#333',
    damageZone: 'rgba(255, 50, 50, 0.2)', damageStroke: '#ff3333',
    previewLine: 'rgba(255, 255, 0, 0.8)', guideMarker: 'rgba(255, 255, 255, 0.3)'
};

const P1 = { id: 1, name: 'BLUE', color: COLORS.p1, bg: COLORS.p1Bg };
const P2 = { id: 2, name: 'RED', color: COLORS.p2, bg: COLORS.p2Bg };
const DIRECTIONS = [{dq:1,dr:0}, {dq:1,dr:-1}, {dq:0,dr:-1}, {dq:-1,dr:0}, {dq:-1,dr:1}, {dq:0,dr:1}];

/** * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ */
let state = {
    gameMode: null, // 'PvP' or 'PvE'
    turn: 1,
    turnPlayer: P1,
    phase: 'TITLE', 
    hexes: [],
    units: [],
    selectedCard: null,
    tempRotationStart: null,
    validDirections: [], 
    hiddenRotation: null,
    defenderMoves: [],
    selectedUnit: null,
    winner: null,
    frameCount: 0,
    isCpuThinking: false,
    emotes: [],
    damageEffects: [],
    
    /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¨ãƒ¢ãƒ¼ãƒˆç®¡ç† â–¼â–¼â–¼ */
    timeLeft: 30,
    timerInterval: null,
    lastEmoteTime: 0

};

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
let HEX_SIZE = 30;

/* --- åˆæœŸåŒ–ãƒ»ãƒ¢ãƒ¼ãƒ‰é¸æŠ (ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆ) --- */
function startGame(mode) {
    state.gameMode = mode;
    
    if (bgm.paused) {
        bgm.play().catch(e => console.log("BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:", e));
    }

    // 1. åå‰ã¨ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
    const inputName = document.getElementById('username-input').value.trim();

    const inputComment = document.getElementById('comment-input').value.trim();

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š
    const p1Name = inputName || (mode === 'PvE' ? "PLAYER" : "P1");
    // ã‚³ãƒ¡ãƒ³ãƒˆãŒç©ºæ¬„ãªã‚‰ "..." ã«ã™ã‚‹
    const p1Comment = inputComment || "..."; 

    const p2Name = mode === 'PvE' ? "CPU" : "P2";
    const p2Comment = "..."; // CPUã¯å¸¸ã«ç„¡è¨€

    // 2. ç”»é¢ï¼ˆæ ã®ä¸­ï¼‰ã«åæ˜ 
    document.getElementById('p1-label').innerText = p1Name;
    document.getElementById('p1-comment').innerText = p1Comment;

    document.getElementById('p2-label').innerText = p2Name;
    document.getElementById('p2-comment').innerText = p2Comment;

    // --- ã“ã“ã‹ã‚‰ä¸‹ã¯æ—¢å­˜ã¨åŒã˜ ---
    document.getElementById('title-screen').style.display = 'none';

    initBoardUnits();
    state.turn = 1;

    state.turnPlayer = P1;
    state.turnPlayer.nameDisplay = p1Name; 

    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    updateTurnVisuals();
    showToast("GAME START!");
    resizeCanvas();
    gameLoop();
    resetTimer(); // â˜…è¿½åŠ 


}

function initBoardUnits() {
    state.hexes = [];
    for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        let r1 = Math.max(-BOARD_RADIUS, -q - BOARD_RADIUS);
        let r2 = Math.min(BOARD_RADIUS, -q + BOARD_RADIUS);
        for (let r = r1; r <= r2; r++) {
            const dist = (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
            const isEdge = dist === BOARD_RADIUS;
            
            // â–¼â–¼â–¼ ä¿®æ­£: è§’ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã®åˆ¤å®šã‚’è¿½åŠ  â–¼â–¼â–¼
            // (q,r)åº§æ¨™ã®ç‰¹å¾´ã‹ã‚‰6ã¤ã®è§’ã‚’ç‰¹å®šã—ã¾ã™
            const isCorner = (Math.abs(q) === BOARD_RADIUS && r === 0) ||
                             (Math.abs(r) === BOARD_RADIUS && q === 0) ||
                             (Math.abs(q) === BOARD_RADIUS && r === -q);

            state.hexes.push({ q, r, isEdge, isCorner });
        }
    }
    const initialPositions = [
        { q: 2, r: 0, owner: 1 }, { q: 0, r: 2, owner: 2 },
        { q: -2, r: 2, owner: 1 }, { q: -2, r: 0, owner: 2 },
        { q: 0, r: -2, owner: 1 }, { q: 2, r: -2, owner: 2 }
    ];
    state.units = [];
    initialPositions.forEach((pos, i) => {
        state.units.push({
            id: `u${i}`, owner: pos.owner, q: pos.q, r: pos.r, hp: 1000,
            animQ: pos.q, animR: pos.r
        });
    });
}

/* --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— --- */
function gameLoop() {
    state.frameCount++;
    state.units.forEach(u => {
        u.animQ += (u.q - u.animQ) * 0.2;
        u.animR += (u.r - u.animR) * 0.2;
    });
    draw();
    if (!state.winner) requestAnimationFrame(gameLoop);
}

/* --- æç”»ãƒ­ã‚¸ãƒƒã‚¯ (æ¼”å‡ºå¼·åŒ–ãƒ»ã‚·ã‚§ã‚¤ã‚¯ãªã—ç‰ˆ) --- */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ã‚°ãƒªãƒƒãƒ‰æç”»ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    state.hexes.forEach(h => {
        const {x, y} = hexToPixel(h.q, h.r);
        let color = COLORS.hex;
        let stroke = COLORS.hexEdge;
        let lineWidth = 1;
        if (h.isEdge) { stroke = COLORS.damageStroke; lineWidth = 2; }
        if (state.hiddenRotation && state.phase === 'ANIMATION' && state.hiddenRotation.indices.includes(getHexIndex(h.q, h.r))) {
             color = '#444';
        }
        drawHex(x, y, HEX_SIZE * 0.95, color, stroke, lineWidth);
        
        // ç§»å‹•ã‚¬ã‚¤ãƒ‰
        if (state.phase === 'DEFENDER_MOVE' && state.selectedUnit && !state.isCpuThinking) {
            if (!getUnitAt(h.q, h.r)) {
                ctx.beginPath(); ctx.arc(x, y, HEX_SIZE * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.guideMarker; ctx.fill();
            }
        }
    });

    // å›è»¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    if (state.phase === 'SELECT_ROTATION' && state.tempRotationStart) {
        const startPos = hexToPixel(state.tempRotationStart.q, state.tempRotationStart.r);
        drawHex(startPos.x, startPos.y, HEX_SIZE * 0.9, '#ffd700', '#fff', 3);
        state.validDirections.forEach(dirObj => {
            dirObj.indices.forEach(idx => {
                if(state.hexes[idx] === state.tempRotationStart) return;
                const h = state.hexes[idx];
                const p = hexToPixel(h.q, h.r);
                ctx.save();
                ctx.globalAlpha = 0.5;
                drawHex(p.x, p.y, HEX_SIZE * 0.85, '#ffd700', null, 0); 
                ctx.restore();
            });
            const lastIdx = dirObj.indices[dirObj.indices.length - 1];
            const lastHex = state.hexes[lastIdx];
            const endP = hexToPixel(lastHex.q, lastHex.r);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath(); ctx.arc(endP.x, endP.y, 4, 0, Math.PI*2); ctx.fill();
        });
    }

    // ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    [1, 2].forEach(ownerId => {
        const myUnits = state.units.filter(u => u.owner === ownerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.animQ, u.animR));
            const isEq = isEquilateral(pts[0], pts[1], pts[2]);
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y); ctx.lineTo(pts[2].x, pts[2].y); ctx.closePath();
            const color = ownerId === 1 ? COLORS.p1 : COLORS.p2;
            if (isEq) {
                ctx.strokeStyle = color; ctx.lineWidth = 4;
                ctx.shadowColor = color; ctx.shadowBlur = 20; ctx.stroke();
                ctx.fillStyle = color + '22'; ctx.fill();
            } else {
                ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.shadowBlur = 0; ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }
    });

    // ãƒ¦ãƒ‹ãƒƒãƒˆæç”»
    state.units.forEach(u => {
        const {x, y} = hexToPixel(u.animQ, u.animR);
        let color = u.owner === 1 ? COLORS.p1 : COLORS.p2;
        
        // â–¼â–¼â–¼ è¿½åŠ : ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸç¬é–“ã«ç™½ãå…‰ã‚‰ã›ã‚‹ â–¼â–¼â–¼
        if (u.hitFlash > 0) {
             color = '#fff'; 
             u.hitFlash--; // ã‚¿ã‚¤ãƒãƒ¼ã‚’æ¸›ã‚‰ã™
        }

        // ç§»å‹•ç·š
        const move = state.defenderMoves.find(m => m.unitId === u.id);
        if (move) {
            const destHex = state.hexes[move.toIndex];
            const destPos = hexToPixel(destHex.q, destHex.r);
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(destPos.x, destPos.y);
            ctx.strokeStyle = '#fff'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        let size = HEX_SIZE * 0.7; let stroke = '#fff'; let lw = 2;
        if (state.selectedUnit && state.selectedUnit.id === u.id) {
            size *= 1.1; stroke = '#ffd700'; lw = 4;
            ctx.beginPath(); ctx.arc(x, y, HEX_SIZE, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke();
        }
        drawHex(x, y, size, color, stroke, lw);
        // HP
        const hpPct = u.hp / 1000;
        ctx.fillStyle = '#000'; ctx.fillRect(x - 15, y - 5, 30, 4);
        ctx.fillStyle = hpPct > 0.5 ? '#0f0' : '#f00'; ctx.fillRect(x - 15, y - 5, 30 * Math.max(0, hpPct), 4);
    });
    
    drawEmotes();
}

/* â–¼â–¼â–¼ ä¿®æ­£: ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡º (å…‰ã‚‹ã ã‘) â–¼â–¼â–¼ */
function addDamageEffect(unit, damage) {
    // æ•°å­—ãŒå‡ºã‚‹å‡¦ç†ã¯å‰Šé™¤ã—ã¾ã—ãŸ

    // ãƒ¦ãƒ‹ãƒƒãƒˆã‚’å…‰ã‚‰ã›ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚»ãƒƒãƒˆ
    unit.hitFlash = 10; 
}


function drawHex(x, y, size, fill, stroke, lw) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = 2 * Math.PI / 6 * i + Math.PI/6;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}
function drawArrowHead(x, y) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill(); }

/* --- UIåˆ¶å¾¡ & CPUãƒ­ã‚¸ãƒƒã‚¯ --- */
function updateTurnVisuals() {
    const p = state.turnPlayer;
    
    // èƒŒæ™¯è‰²ã¯ãã®ã¾ã¾
    document.body.style.backgroundColor = p.bg;
    
    const indicator = document.getElementById('turn-indicator');
    const badge = document.getElementById('phase-badge');
    const cardPanel = document.getElementById('card-panel');
    const mainBtn = document.getElementById('main-btn');

    // â–¼â–¼â–¼ ä¿®æ­£: åå‰ã ã‘ã‚’è¡¨ç¤ºï¼ˆTURNã¯æ¶ˆã™ï¼‰ â–¼â–¼â–¼
    indicator.innerText = p.name; 
    indicator.style.color = p.color;

    // CPUã‚¿ãƒ¼ãƒ³ä¸­ã¯æ“ä½œç„¡åŠ¹
    if (state.isCpuThinking) {
        cardPanel.style.pointerEvents = 'none';
        mainBtn.disabled = true;
        // â–¼â–¼â–¼ ä¿®æ­£: ã‚·ãƒ³ãƒ—ãƒ«ã« â–¼â–¼â–¼
        badge.innerText = "WAIT"; 
        badge.style.color = "#aaa";
        return;
    }
    cardPanel.style.pointerEvents = 'auto';

    // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ï¼ˆæ”»æ’ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼‰
    if (state.phase === 'SELECT_CARD') {
        // â–¼â–¼â–¼ ä¿®æ­£: çŸ­ã„å˜èªã¸ â–¼â–¼â–¼
        badge.innerText = "PICK CARD";
        badge.style.color = "#fff";
        cardPanel.style.display = 'flex'; mainBtn.style.display = 'none';
        
    } else if (state.phase === 'SELECT_ROTATION') {
        // â–¼â–¼â–¼ ä¿®æ­£: ç‹™ãˆï¼ã¨ã„ã†ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ â–¼â–¼â–¼
        badge.innerText = "AIMING"; 
        badge.style.color = "#fff";
        cardPanel.style.display = 'flex'; mainBtn.style.display = 'none';
        
    } else if (state.phase === 'DEFENDER_MOVE') {
        // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ï¼ˆå›é¿ãƒ•ã‚§ãƒ¼ã‚ºï¼‰
        // â–¼â–¼â–¼ ä¿®æ­£: ç·Šæ€¥æ„Ÿã‚’å‡ºã™ â–¼â–¼â–¼
        badge.innerText = "MOVE"; 
        badge.style.color = "#ff3333"; // èµ¤æ–‡å­—ã§è­¦å‘Šæ„Ÿ

        cardPanel.style.display = 'none'; mainBtn.style.display = 'block';
        
        const defender = state.turnPlayer.id === 1 ? P2 : P1;
        
        // ãƒœã‚¿ãƒ³ã®æ–‡å­—ã‚‚å¤‰æ›´
        mainBtn.innerText = "GO";
        
        mainBtn.disabled = false;
        
        // æ‰‹ç•ªè¡¨ç¤ºã‚’é˜²å¾¡å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã«å¤‰æ›´
        indicator.innerText = defender.name;
        indicator.style.color = defender.color;
        document.body.style.backgroundColor = defender.bg;
        
    } else {
        badge.innerText = "";
    }
}

// CPUã®è¡Œå‹•å‡¦ç† (å¼·åŒ–ç‰ˆ: åŒã˜ãƒ¦ãƒ‹ãƒƒãƒˆã®é€£ç¶šç§»å‹•ç¦æ­¢)
async function triggerCpuAction() {
    if (state.gameMode !== 'PvE' || state.winner) return;
    
    const isCpuAttacker = (state.turnPlayer.id === 2);
    const isCpuDefender = (state.turnPlayer.id === 1 && state.phase === 'DEFENDER_MOVE');

    if (!isCpuAttacker && !isCpuDefender) return;

    state.isCpuThinking = true;
    updateTurnVisuals();

    await wait(1000);

    // --- æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º ---
    if (state.phase === 'SELECT_CARD') {
        const bestAction = aiFindBestCardAction();
        const choice = bestAction.cardLen;
        uiSelectCard(choice, true);
        showToast(`CPU SELECT: ${choice}é€£`);
        await wait(1500);
        
        if (bestAction.indices) {
            state.hiddenRotation = { indices: bestAction.indices };
            state.phase = 'DEFENDER_MOVE';
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("CPUãŒå›è»¢ã‚’ã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
            updateTurnVisuals();
        } else {
            const cards = [2,3,4];
            uiSelectCard(cards[0], true);
        }
    } 
    // --- é˜²å¾¡/ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º ---
    else if (state.phase === 'DEFENDER_MOVE') {
        // 1å›ç›®ã®ç§»å‹•
        let move1 = aiFindBestMove(); // å¼•æ•°ãªã—ï¼åˆ¶é™ãªã—
        if (move1) {
            state.defenderMoves.push({ unitId: move1.unitId, toIndex: move1.toIndex });
            
            // ä»®æƒ³åæ˜ 
            const u = state.units.find(u => u.id === move1.unitId);
            const originalQ = u.q; const originalR = u.r;
            const targetHex = state.hexes[move1.toIndex];
            u.q = targetHex.q; u.r = targetHex.r;

            // 2å›ç›®ã®ç§»å‹• (â˜…ä¿®æ­£: move1.unitId ã‚’æ¸¡ã—ã¦é™¤å¤–ã•ã›ã‚‹)
            let move2 = aiFindBestMove(move1.unitId);
            if (move2) {
                state.defenderMoves.push({ unitId: move2.unitId, toIndex: move2.toIndex });
            }

            // åº§æ¨™æˆ»ã—
            u.q = originalQ; u.r = originalR;
        }

        showToast("CPUãŒç§»å‹•ã—ã¾ã—ãŸ");
        await wait(500);
        startTurnResolution();
    }

    state.isCpuThinking = false;
    updateTurnVisuals();
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›
function uiSelectCard(len, fromCpu = false) {
    if (state.isCpuThinking && !fromCpu) return;
    
    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãªã‚‰ç›¸æ‰‹ã«é€ä¿¡ â–¼â–¼â–¼
    // (fromCpuãƒ•ãƒ©ã‚°ãŒã‚ã‚‹ï¼ç›¸æ‰‹ã‹ã‚‰ã®é€šä¿¡ã§å‹•ã„ã¦ã„ã‚‹æ™‚ã¯ã€å†é€ä¿¡ã—ãªã„)
    if (state.gameMode === 'ONLINE' && !fromCpu) {
        sendAction('SELECT_CARD', { value: len });
    }
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    state.selectedCard = len;
    
    // ... (ä»¥ä¸‹ã€æ—¢å­˜ã®ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤ºã‚³ãƒ¼ãƒ‰ãªã©ã¯ãã®ã¾ã¾) ...
    const svgs = {
        2: `<svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        3: `<svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        4: `<svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(61.96, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`
    };
    document.getElementById('card-info').innerHTML = svgs[len];

    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.card')[len-2].classList.add('selected');
    state.phase = 'SELECT_ROTATION';

    state.tempRotationStart = null;
    state.validDirections = [];
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ™‚ã ã‘ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    if (!fromCpu) {
        showToast("è»¸ã‚’é¸ã‚“ã§ãã ã•ã„");
    }
    updateTurnVisuals();
    
    // PvE CPUãƒˆãƒªã‚¬ãƒ¼ (ã“ã“ã¯å¤‰æ›´ãªã—)
    if (!fromCpu && state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}

function uiConfirm() {
    if (state.isCpuThinking) return;

    // â˜…è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§è‡ªåˆ†ã®ç•ªã˜ã‚ƒãªã„ãªã‚‰æŠ¼ã›ãªã„
    if (state.gameMode === 'ONLINE') {
        // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºã®æ±ºå®šãƒœã‚¿ãƒ³ãªã®ã§ã€é˜²å¾¡å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼(myPlayerId)ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (defenderId !== myPlayerId) return;
    }

    if (state.phase === 'DEFENDER_MOVE') {
        // â–¼â–¼â–¼ è¿½åŠ ï¼šç§»å‹•å†…å®¹ã‚’é€ä¿¡ â–¼â–¼â–¼
        if (state.gameMode === 'ONLINE') {
            sendAction('MOVE', { moves: state.defenderMoves });
        }
        // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

        startTurnResolution();
    }
}

function handleInput(x, y) {
    if (state.phase === 'TITLE' || state.phase === 'ANIMATION' || state.winner || state.isCpuThinking) return;

    // â˜…è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã®æ™‚ã¯æ“ä½œã•ã›ãªã„
    if (state.gameMode === 'ONLINE' && state.turnPlayer.id !== myPlayerId && state.phase !== 'DEFENDER_MOVE') return;
    // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚º(DEFENDER_MOVE)ã®æ™‚ã¯ã€é˜²å¾¡å´ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ãŒæ“ä½œã§ãã‚‹
    if (state.gameMode === 'ONLINE' && state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (defenderId !== myPlayerId) return;
    }

    const coords = pixelToHex(x, y);
    const hexIndex = getHexIndex(coords.q, coords.r);
    
    if (hexIndex === -1) return;
    const clickedHex = state.hexes[hexIndex];

    // å›è»¢è¨­å®š
    if (state.phase === 'SELECT_ROTATION') {
        if (!state.tempRotationStart) {
            state.tempRotationStart = clickedHex;
            calcValidDirections(clickedHex);
            if (state.validDirections.length === 0) {
                showToast("å›è»¢ä¸å¯"); state.tempRotationStart = null;
            }
        } else {
            const clickedIndex = getHexIndex(clickedHex.q, clickedHex.r);
            const valid = state.validDirections.find(v => v.indices.includes(clickedIndex));

            if (valid) {
                // ç¢ºå®šï¼
                state.hiddenRotation = { indices: valid.indices };
                
                // â–¼â–¼â–¼ è¿½åŠ ï¼šå›è»¢ã‚’é€ä¿¡ â–¼â–¼â–¼
                if (state.gameMode === 'ONLINE') {
                    sendAction('ROTATE', { indices: valid.indices });
                }
                // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²


                state.tempRotationStart = null;
                state.validDirections = [];
                state.phase = 'DEFENDER_MOVE';
                
                updateTurnVisuals();
                showToast("ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º");

                /* â–¼â–¼â–¼ è¿½åŠ ï¼šé˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºã«ãªã£ãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ â–¼â–¼â–¼ */
                resetTimer();
                
                if (state.gameMode === 'PvE') triggerCpuAction();
            }
else {
                // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                state.tempRotationStart = clickedHex;
                calcValidDirections(clickedHex);
                if (state.validDirections.length === 0) {
                    state.tempRotationStart = null;
                }
            }
        }
    }

    // ç§»å‹•è¨­å®š
    else if (state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        // CPUã‚„ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®ç›¸æ‰‹ã®é§’ã¯è§¦ã‚Œãªã„
        if (state.gameMode === 'PvE' && defenderId === 2) return;

        const unit = getUnitAt(clickedHex.q, clickedHex.r);
        
        // è‡ªåˆ†ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸ã‚“ã å ´åˆ
        if (unit && unit.owner === defenderId) {
            if (state.selectedUnit === unit) {
                state.selectedUnit = null;
            } else {
                state.selectedUnit = unit;
            }
            if (state.defenderMoves.find(m => m.unitId === unit.id)) {
                state.defenderMoves = state.defenderMoves.filter(m => m.unitId !== unit.id);
            }

        // ç©ºããƒã‚¹ã‚’é¸ã‚“ã å ´åˆ
        } else if (state.selectedUnit && !unit) {
            const isReserved = state.defenderMoves.find(m => m.toIndex === hexIndex);
            if (isReserved) {
                showToast("æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã¾ã™");
                return;
            }
            if (state.defenderMoves.length >= 2) {
                showToast("ç§»å‹•ã§ãã‚‹ã®ã¯2ä½“ã¾ã§ï¼");
                return;
            }

            state.defenderMoves.push({ unitId: state.selectedUnit.id, toIndex: hexIndex });
            state.selectedUnit = null;
        }
        updateTurnVisuals();
    }
}

// ã‚¿ãƒ¼ãƒ³è§£æ±º
async function startTurnResolution() {
    state.phase = 'ANIMATION';
    updateTurnVisuals();

    // 1. ç§»å‹•
    for (let m of state.defenderMoves) {
        const u = state.units.find(u => u.id === m.unitId);
        const target = state.hexes[m.toIndex];
        u.q = target.q; u.r = target.r;
    }
    state.defenderMoves = [];
    await wait(800);

    // 2. å›è»¢
    const indices = state.hiddenRotation.indices;
    showToast("ROTATION!");
    await wait(500);
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        const h = state.hexes[hexIdx];
        const u = getUnitAt(h.q, h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos;
        let nextHex = state.hexes[indices[nextLinePos]];
        item.u.q = nextHex.q; item.u.r = nextHex.r;
    });
    await wait(1000);

    // 3. ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã“ã“ã‚’ä¸¸ã”ã¨æ›¸ãæ›ãˆï¼‰
    
    // è§’ãƒ»è¾ºã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒã‚§ãƒƒã‚¯
    state.units.forEach(u => {
        const h = state.hexes[getHexIndex(u.q, u.r)];
        
        let damage = 0;
        if (h.isCorner) {
            damage = 500; // è§’ã¯å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸
        } else if (h.isEdge) { 
            damage = 100; // è¾ºã¯å°ãƒ€ãƒ¡ãƒ¼ã‚¸
        }

        if (damage > 0) {
            u.hp -= damage;
            addDamageEffect(u, damage); // â˜…ã“ã“ã§æ¼”å‡ºå‘¼ã³å‡ºã—ï¼
        }
    });

    // ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒã‚§ãƒƒã‚¯
    [1, 2].forEach(attackerId => {
        const myUnits = state.units.filter(u => u.owner === attackerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.q, u.r));
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const defenderId = attackerId===1?2:1;
                state.units.filter(u => u.owner === defenderId).forEach(target => {
                    const ratio = getTriangleOverlapRatio(target, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) { 
                        const dmg = Math.floor(500 * ratio);
                        target.hp -= dmg;
                        addDamageEffect(target, dmg); // â˜…ã“ã“ã§ã‚‚æ¼”å‡ºå‘¼ã³å‡ºã—ï¼
                    }
                });
            }
        }
    });
    
    // showToast ã¯å‰Šé™¤ã—ã¦å‘¼ã³å‡ºã•ãªã„
    await wait(1500);


    // çµ‚äº†åˆ¤å®š
    const p1Lose = state.units.some(u => u.owner === 1 && u.hp <= 0);
    const p2Lose = state.units.some(u => u.owner === 2 && u.hp <= 0);
    
    if (p1Lose || p2Lose) {
        // â–¼â–¼â–¼ ã“ã“ã‚’å¤‰æ›´ â–¼â–¼â–¼
        state.winner = p1Lose && p2Lose ? "DRAW" : (p1Lose ? "RED" : "BLUE"); // åå‰ã ã‘ã«ã™ã‚‹
        showResult(state.winner); // ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã‚’è¡¨ç¤º
        // â–²â–²â–² å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–²
    } else {
        nextTurn();
    }
}


function nextTurn() {
    state.turnPlayer = state.turnPlayer.id === 1 ? P2 : P1;
    if (state.turnPlayer.id === 1) state.turn++;
    
    // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«ãªã£ãŸã‚‰è¡¨ç¤ºã‚’æ¶ˆã™
    document.getElementById('card-info').innerText = "";

    state.phase = 'SELECT_CARD';
    state.selectedCard = null;
    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    
    updateTurnVisuals();
    showToast(`${state.turnPlayer.name}'s TURN`);

    /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ã‚¿ã‚¤ãƒãƒ¼å§‹å‹• â–¼â–¼â–¼ */
    resetTimer();

    // CPUã‚¿ãƒ¼ãƒ³é–‹å§‹
    if (state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}


// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
function calcValidDirections(startHex) {
    state.validDirections = [];
    DIRECTIONS.forEach((d, idx) => {
        const indices = getLineIndices(startHex, state.selectedCard, idx);
        if (indices) state.validDirections.push({ dirIdx: idx, indices: indices });
    });
}
function getLineIndices(startHex, len, dirIdx) {
    let indices = [];
    let curr = startHex;
    let dir = DIRECTIONS[dirIdx];
    for(let i=0; i<len; i++) {
        let idx = getHexIndex(curr.q, curr.r);
        if (idx === -1) return null;
        indices.push(idx);
        curr = { q: curr.q + dir.dq, r: curr.r + dir.dr };
    }
    return indices;
}
function hexToPixel(q, r) {
    const x = canvas.width/2 + HEX_SIZE * (Math.sqrt(3) * (q + r/2));
    const y = canvas.height/2 + HEX_SIZE * (3/2 * r);
    return { x, y };
}
function pixelToHex(x, y) {
    const pt = { x: x - canvas.width/2, y: y - canvas.height/2 };
    const q = (Math.sqrt(3)/3 * pt.x - 1/3 * pt.y) / HEX_SIZE;
    const r = (2/3 * pt.y) / HEX_SIZE;
    return cubeRound(q, r, -q-r);
}
function cubeRound(x, y, z) {
    let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
    const x_diff = Math.abs(rx - x), y_diff = Math.abs(ry - y), z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
    else if (y_diff > z_diff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: ry };
}
function getHexIndex(q, r) { return state.hexes.findIndex(h => h.q === q && h.r === r); }
function getUnitAt(q, r) { return state.units.find(u => u.q === q && u.r === r); }
function isEquilateral(p1, p2, p3) {
    const d1 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
    const d2 = Math.hypot(p2.x-p3.x, p2.y-p3.y);
    const d3 = Math.hypot(p3.x-p1.x, p3.y-p1.y);
    const avg = (d1 + d2 + d3) / 3;
    if (avg < 10) return false;
    return Math.abs(d1 - avg) < avg * 0.1 && Math.abs(d2 - avg) < avg * 0.1 && Math.abs(d3 - avg) < avg * 0.1;
}
function getTriangleOverlapRatio(unit, t1, t2, t3) {
    const unitPos = hexToPixel(unit.q, unit.r);
    
    // â–¼ ä¿®æ­£ï¼šè¦‹ãŸç›®ã®ã‚µã‚¤ã‚º(0.7)ã«åˆ¤å®šç¯„å›²ã‚’åˆã‚ã›ã‚‹ï¼
    // ã“ã‚Œã§ã€Œè§¦ã‚Œã¦ãªã„ã®ã«å½“ãŸã£ãŸã€ç¾è±¡ãŒæ¶ˆãˆã¾ã™
    const visualRadius = HEX_SIZE * 0.7; 

    let hitCount = 0;
    let totalPoints = 0;

    // 1. ä¸­å¿ƒç‚¹ã®ãƒã‚§ãƒƒã‚¯
    if (isPointInTriangle(unitPos, t1, t2, t3)) hitCount++;
    totalPoints++;

    // 2. å‘¨å›²ã®ç‚¹ã®ãƒã‚§ãƒƒã‚¯ï¼ˆç²¾åº¦ã‚’ä¸Šã’ã‚‹ãŸã‚3æ®µéšã«å¢—é‡ï¼‰
    const rings = [
        { r: 0.4, count: 6 },   // å†…å´
        { r: 0.8, count: 8 },   // ä¸­é–“
        { r: 1.0, count: 12 }   // å¤–å‘¨ï¼ˆä¸€ç•ªé‡è¦ãªã®ã§å¤šã‚ã«ï¼‰
    ];

    rings.forEach(ring => {
        // visualRadius ã‚’åŸºæº–ã«è¨ˆç®—ã™ã‚‹ã®ã§ã€è¦‹ãŸç›®ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„
        const r = visualRadius * ring.r;
        
        for(let i = 0; i < ring.count; i++) {
            const theta = (Math.PI * 2 / ring.count) * i;
            const p = {
                x: unitPos.x + r * Math.cos(theta),
                y: unitPos.y + r * Math.sin(theta)
            };
            
            if (isPointInTriangle(p, t1, t2, t3)) hitCount++;
            totalPoints++;
        }
    });

    return hitCount / totalPoints;
}

function isPointInTriangle(p, a, b, c) {
    const v0 = {x: c.x-a.x, y: c.y-a.y}, v1 = {x: b.x-a.x, y: b.y-a.y}, v2 = {x: p.x-a.x, y: p.y-a.y};
    const dot00 = v0.x*v0.x+v0.y*v0.y, dot01 = v0.x*v1.x+v0.y*v1.y, dot02 = v0.x*v2.x+v0.y*v2.y;
    const dot11 = v1.x*v1.x+v1.y*v1.y; 
    const dot12 = v1.x*v2.x+v1.y*v2.y; 
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v < 1);
}

function resizeCanvas() {
    const c = document.getElementById('game-area');
    canvas.width = c.clientWidth; canvas.height = c.clientHeight;
    HEX_SIZE = Math.min((canvas.width*0.9)/(7*Math.sqrt(3)), (canvas.height*0.9)/(7*1.5));
}
function showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg; t.style.opacity = 1;
    setTimeout(() => t.style.opacity = 0, 2000);
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
window.addEventListener('resize', resizeCanvas);
// ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Œå…¨ã«é˜²ã
const preventScroll = (e) => { e.preventDefault(); };
canvas.addEventListener('touchmove', preventScroll, {passive: false});

canvas.addEventListener('touchstart', e => {
    e.preventDefault(); // ã“ã“ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç™ºç”Ÿã‚’é˜²ã
    const r = canvas.getBoundingClientRect();
    // ã‚¿ãƒƒãƒä½ç½®ã®è£œæ­£
    handleInput(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive: false});

// æœ€åˆã«Canvasã‚µã‚¤ã‚ºã‚’è¨­å®š
resizeCanvas();

/* --- AI Logic Helpers --- */

// å…¨ã‚«ãƒ¼ãƒ‰ãƒ»å…¨å›è»¢ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦æœ€å–„æ‰‹ã‚’æ¢ã™
function aiFindBestCardAction() {
    let bestScore = -Infinity;
    let bestAction = { cardLen: 3, indices: null }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

    const cardLens = [2, 3, 4];
    
    // å…¨ã‚«ãƒ¼ãƒ‰é•·
    for (let len of cardLens) {
        // å…¨ãƒã‚¹
        for (let i = 0; i < state.hexes.length; i++) {
            const h = state.hexes[i];
            // å…¨æ–¹å‘
            for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
                const indices = getLineIndices(h, len, dirIdx);
                if (!indices) continue;

                // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒ¦ãƒ‹ãƒƒãƒˆã®åº§æ¨™ã‚’ä»®æ›´æ–°
                const simUnits = aiSimulateRotation(indices);
                
                // ç›¤é¢è©•ä¾¡
                const score = aiEvaluateBoard(simUnits);
                
                // ã‚¹ã‚³ã‚¢æ›´æ–° (ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’å°‘ã—å…¥ã‚Œã¦åŒã˜ã‚¹ã‚³ã‚¢ãªã‚‰ãƒãƒ©ã‘ã•ã›ã‚‹)
                if (score > bestScore + (Math.random() * 5)) { // åƒ…å·®ãªã‚‰å…¥ã‚Œæ›¿ãˆ
                    bestScore = score;
                    bestAction = { cardLen: len, indices: indices };
                }
            }
        }
    }
    return bestAction;
}

// å…¨ãƒ¦ãƒ‹ãƒƒãƒˆãƒ»å…¨ç§»å‹•å…ˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦æœ€å–„ã®ç§»å‹•ã‚’æ¢ã™
// å¼•æ•° excludeUnitId: è¨ˆç®—ã‹ã‚‰é™¤å¤–ã™ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆID (2å›ç›®ã®ç§»å‹•ã§ä½¿ç”¨)
function aiFindBestMove(excludeUnitId = null) {
    let bestScore = -Infinity;
    let bestMove = null;

    const cpuUnits = state.units.filter(u => u.owner === 2);
    
    // ç¾åœ¨åŸ‹ã¾ã£ã¦ã„ã‚‹å ´æ‰€
    const occupied = new Set(state.units.map(u => getHexIndex(u.q, u.r)));
    state.defenderMoves.forEach(m => occupied.add(m.toIndex));

    for (let u of cpuUnits) {
        // â˜…ä¿®æ­£: é™¤å¤–æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ‹ãƒƒãƒˆãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
        if (excludeUnitId && u.id === excludeUnitId) continue;

        const currentIdx = getHexIndex(u.q, u.r);
        
        // å…¨ç©ºããƒã‚¹ã‚’æ¢ç´¢
        for (let i = 0; i < state.hexes.length; i++) {
            if (occupied.has(i)) continue;
            if (i === currentIdx) continue;

            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            const simUnits = state.units.map(unit => ({ ...unit }));
            const targetUnit = simUnits.find(unit => unit.id === u.id);
            const targetHex = state.hexes[i];
            targetUnit.q = targetHex.q;
            targetUnit.r = targetHex.r;

            // è©•ä¾¡
            let score = aiEvaluateBoard(simUnits);

            // å¤–å‘¨å›é¿ãƒ­ã‚¸ãƒƒã‚¯
            if (targetHex.isEdge && score < 500) { 
                 score -= 1000;
            }

            if (score > bestScore + (Math.random() * 5)) {
                bestScore = score;
                bestMove = { unitId: u.id, toIndex: i };
            }
        }
    }
    return bestMove;
}

// å›è»¢çµæœã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ãƒ¦ãƒ‹ãƒƒãƒˆã®ä»®åº§æ¨™ãƒªã‚¹ãƒˆã‚’è¿”ã™
function aiSimulateRotation(indices) {
    const simUnits = state.units.map(u => ({ ...u })); // Deep Copy
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        const h = state.hexes[hexIdx];
        const u = simUnits.find(unit => unit.q === h.q && unit.r === h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos; // åè»¢
        let nextHex = state.hexes[indices[nextLinePos]];
        item.u.q = nextHex.q;
        item.u.r = nextHex.r;
    });
    return simUnits;
}

// ç›¤é¢ã®ã‚¹ã‚³ã‚¢è¨ˆç®— (ã“ã“ãŒAIã®åˆ¤æ–­åŸºæº–)
function aiEvaluateBoard(simUnits) {
    let score = 0;
    const cpuId = 2;
    const playerId = 1;

    // 1. å¤–å‘¨(Edge)ã®è©•ä¾¡
    simUnits.forEach(u => {
        const hIdx = getHexIndex(u.q, u.r);
        if (hIdx !== -1 && state.hexes[hIdx].isEdge) {
            // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€: ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’å¤§å¹…å¼·åŒ– (-300 -> -2000) â–¼â–¼â–¼
            // HPãŒæ¸›ã‚‹ã®ã‚’æ¥µç«¯ã«å«ŒãŒã‚‹ã‚ˆã†ã«è¨­å®š
            if (u.owner === cpuId) score -= 2000;   
            
            // æ•µã‚’å¤–å‘¨ã«è¿½ã„ã‚„ã‚‹ã®ã¯è‰¯ã„ã“ã¨
            if (u.owner === playerId) score += 300; 
        }
    });

    // 2. ä¸‰è§’å½¢(Triangle)ã®è©•ä¾¡
    [cpuId, playerId].forEach(owner => {
        const myUnits = simUnits.filter(u => u.owner === owner);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.q, u.r));
            // æ­£ä¸‰è§’å½¢ãŒã§ãã¦ã„ã‚‹ã‹ï¼Ÿ
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const targetId = owner === cpuId ? playerId : cpuId;
                const targets = simUnits.filter(u => u.owner === targetId);
                
                let hits = 0;
                targets.forEach(t => {
                    const ratio = getTriangleOverlapRatio(t, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) hits++;
                });

                if (owner === cpuId) {
                    // è‡ªåˆ†ã®æ”»æ’ƒãƒãƒ£ãƒ³ã‚¹
                    if (hits > 0) {
                        score += 5000 * hits; // æ”»æ’ƒæˆåŠŸã¯é«˜è©•ä¾¡
                    } else {
                        score -= 200; // ç©ºæŒ¯ã‚Šã¯å°‘ã—æ¸›ç‚¹
                    }
                } else {
                    // æ•µã®æ”»æ’ƒï¼ˆè‡ªåˆ†ãŒé£Ÿã‚‰ã†ï¼‰
                    score -= 500; 
                    if (hits > 0) {
                        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€: è¢«å¼¾ã®å›é¿å„ªå…ˆåº¦ã‚’ã•ã‚‰ã«ä¸Šã’ã‚‹ â–¼â–¼â–¼
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹çŠ¶æ…‹ã¯ã€Œæ­»ã€ã¨åŒç¾©ã¨ã—ã¦æœ€å¤§ç´šã®ãƒšãƒŠãƒ«ãƒ†ã‚£
                        score -= 20000 * hits; 
                    }
                }
            }
        }
    });

    return score;
}

/* --- ãƒªã‚¶ãƒ«ãƒˆç”»é¢åˆ¶å¾¡ (æ–°è¦è¿½åŠ ) --- */

function showResult(winnerName) {
    const screen = document.getElementById('result-screen');
    const nameEl = document.getElementById('winner-name');
    
    // è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã¨è‰²ã‚’è¨­å®š
    if (winnerName === "DRAW") {
        nameEl.innerText = "DRAW";
        nameEl.style.color = "#fff";
    } else {
        nameEl.innerText = winnerName;
        // å‹è€…ã®è‰²ã‚’é©ç”¨
        nameEl.style.color = (winnerName === "BLUE") ? COLORS.p1 : COLORS.p2;
    }

    // ç”»é¢ã‚’è¡¨ç¤º
    screen.style.display = 'flex';
    // å°‘ã—é…ã‚‰ã›ã¦ã‚¯ãƒ©ã‚¹è¿½åŠ ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
    setTimeout(() => {
        screen.classList.add('show');
    }, 10);
}

function backToTitle() {
    bgm.pause();
    bgm.currentTime = 0;

    // â–¼â–¼â–¼ è¿½åŠ ï¼šãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ãŸã‚‰å¼·åˆ¶çš„ã«é–‰ã˜ã‚‹ â–¼â–¼â–¼
    document.getElementById('settings-modal').classList.remove('active');
    document.getElementById('secret-modal').classList.remove('active');
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã ã£ãŸå ´åˆã€Firebaseã®éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ã‚’æ¶ˆã™
    if (state.gameMode === 'ONLINE' && roomId) {
        remove(ref(db, roomId))
            .then(() => console.log("éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"))
            .catch((e) => console.error("å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", e));
        
        roomId = null; // IDã‚’ãƒªã‚»ãƒƒãƒˆ
    }

    const resScreen = document.getElementById('result-screen');
    resScreen.classList.remove('show');

    setTimeout(() => resScreen.style.display = 'none', 500);

    // ã‚²ãƒ¼ãƒ å†…è¦ç´ ã®ã‚¯ãƒªã‚¢
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    document.getElementById('turn-indicator').innerText = "";
    document.getElementById('card-info').innerHTML = "";

    // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’è¡¨ç¤º
    document.getElementById('title-screen').style.display = 'flex';
}

/* --- ä¸­æ–­æ©Ÿèƒ½ (æ–°è¦è¿½åŠ ) --- */
function quitGame() {
    // èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ã®ç¢ºèª
    if (!confirm("ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å¯¾æˆ¦ã¯ç ´æ£„ã•ã‚Œã¾ã™ï¼‰")) {
        return;
    }

    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    state.winner = "QUIT"; 
    
    // CPUæ€è€ƒä¸­ãƒ•ãƒ©ã‚°ã‚‚æŠ˜ã‚‹ï¼ˆå¿µã®ãŸã‚ï¼‰
    state.isCpuThinking = false;

    // æ—¢å­˜ã®ã‚¿ã‚¤ãƒˆãƒ«æˆ»ã‚Šé–¢æ•°ã‚’å‘¼ã³å‡ºã™
    backToTitle();
}

/* --- ã‚¨ãƒ¢ãƒ¼ãƒˆæ©Ÿèƒ½ (æ–°è¦è¿½åŠ ) --- */

// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é–‹é–‰
function toggleEmoteMenu() {
    document.getElementById('emote-menu').classList.toggle('show');
}

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šCanvasã®æ ã«é–¢ä¿‚ãªãè¡¨ç¤ºã™ã‚‹æœ€å¼·ç‰ˆ â–¼â–¼â–¼ */

// 1. æç”»é–¢æ•°ã¯ã‚‚ã†ä½¿ã‚ãªã„ã®ã§ç©ºã«ã™ã‚‹
function drawEmotes() {
    // DOMè¦ç´ ã§è¡¨ç¤ºã™ã‚‹ãŸã‚ã€ã“ã“ã§ã®å‡¦ç†ã¯ä¸è¦
}

// 2. æ–°ã—ã„ã‚¨ãƒ¢ãƒ¼ãƒˆè¡¨ç¤ºå‡¦ç†
function sendEmote(emoji, forceOwnerId = null) {
    /* â–¼â–¼â–¼ è¿½åŠ ï¼š3ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆé€£æ‰“é˜²æ­¢ï¼‰ â–¼â–¼â–¼ */
    const now = Date.now();
    // ç›¸æ‰‹ã‹ã‚‰ã®å—ä¿¡(forceOwnerIdã‚ã‚Š)ã®å ´åˆã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ç„¡è¦–
    if (!forceOwnerId && now - state.lastEmoteTime < 3000) { 
        showToast("å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...");
        return; 
    }
    if (!forceOwnerId) state.lastEmoteTime = now;
    /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
    document.getElementById('emote-menu').classList.remove('show');

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãªã‚‰ç›¸æ‰‹ã«é€ä¿¡ â–¼â–¼â–¼
    // forceOwnerIdãŒãªã„ï¼è‡ªåˆ†ãŒæŠ¼ã—ãŸãƒœã‚¿ãƒ³ ã¨ã„ã†æ„å‘³
    if (state.gameMode === 'ONLINE' && !forceOwnerId) {
        sendAction('EMOTE', { value: emoji });
    }
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    let ownerId;
    // ... (ä»¥ä¸‹ãã®ã¾ã¾) ...

    if (forceOwnerId) {
        ownerId = forceOwnerId;
    } else {
        if (state.gameMode === 'PvE') ownerId = 1;
        else ownerId = state.turnPlayer.id;
    }

    // â˜…HTMLè¦ç´ ï¼ˆdivï¼‰ã‚’æ–°ã—ãä½œã‚‹
    const el = document.createElement('div');
    el.innerText = emoji;
    
    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šï¼ˆç”»é¢ã®ã©ã“ã«ã§ã‚‚å‡ºã›ã‚‹è¨­å®šï¼‰
    el.style.position = 'fixed';
    el.style.zIndex = '9999';       // ç”»é¢ã®ä½•ã‚ˆã‚Šã‚‚æ‰‹å‰ã«
    el.style.fontSize = '40px';     // å¤§ãã•
    el.style.fontWeight = 'bold';
    el.style.pointerEvents = 'none'; // ã‚¯ãƒªãƒƒã‚¯ã®é‚ªé­”ã‚’ã—ãªã„
    el.style.textShadow = '0 4px 10px rgba(0,0,0,0.5)'; // å½±ã‚’ã¤ã‘ã¦è¦‹ã‚„ã™ã
    el.style.fontFamily = "Arial, sans-serif";

    // ä½ç½®è¨­å®šï¼ˆã“ã“ã§å¥½ããªé«˜ã•ã‚’æŒ‡å®šã§ãã¾ã™ï¼ï¼‰
    const topPosition = '120px'; // â˜…ã“ã“ã‚’å¤‰ãˆã‚Œã°ã„ãã‚‰ã§ã‚‚ä¸Šã«ã§ãã¾ã™

    if (ownerId === 1) {
        // P1 (å·¦å´)
        el.style.left = '40px'; 
        el.style.top = topPosition;
        el.style.transformOrigin = 'center left'; // å·¦ã‹ã‚‰å‡ºã‚‹æ„Ÿã˜
    } else {
        // P2 (å³å´)
        el.style.right = '40px'; // å³ç«¯ã‹ã‚‰ã®è·é›¢
        el.style.top = topPosition;
        el.style.transformOrigin = 'center right'; // å³ã‹ã‚‰å‡ºã‚‹æ„Ÿã˜
    }

    // ç”»é¢ã«è¿½åŠ 
    document.body.appendChild(el);

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š (Web Animations API)
    // ãƒãƒ³ãƒƒã¨å‡ºã¦ã€ãµã‚“ã‚ã‚Šä¸Šã«æ¶ˆãˆã‚‹å‹•ã
    const anim = el.animate([
        { transform: 'scale(0) translateY(20px)', opacity: 0 },    // 0%: å°ã•ãã¦é€æ˜
        { transform: 'scale(1.2) translateY(0)', opacity: 1, offset: 0.1 }, // 10%: ãƒãƒ³ãƒƒã¨æ‹¡å¤§
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.2 }, // 20%: å…ƒã®ã‚µã‚¤ã‚ºã«
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.7 }, // 70%: å¾…æ©Ÿ
        { transform: 'scale(1.0) translateY(-50px)', opacity: 0 }  // 100%: ä¸Šã«æ˜‡ã£ã¦æ¶ˆãˆã‚‹
    ], {
        duration: 1500, // 1.5ç§’ã‹ã‘ã¦å‹•ã
        easing: 'ease-out'
    });

    // ã‚¢ãƒ‹ãƒ¡ãŒçµ‚ã‚ã£ãŸã‚‰ã‚´ãƒŸæƒé™¤ï¼ˆè¦ç´ ã‚’å‰Šé™¤ï¼‰
    anim.onfinish = () => el.remove();
}

/* â–¼â–¼â–¼ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦æ©Ÿèƒ½ (Firebaseç‰ˆãƒ»ãƒ©ãƒ³ãƒ€ãƒ é™£å–¶) â–¼â–¼â–¼ */

let roomId = null;
let myPlayerId = 0; // 1=P1(é’), 2=P2(èµ¤)

// ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ é–‹å§‹ãƒœã‚¿ãƒ³
window.startOnlineGame = function() { 
    const inputRoom = document.getElementById('room-input').value.trim();
    if (!inputRoom) {
        alert("åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
    }
    
    // â–¼â–¼â–¼ ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ â–¼â–¼â–¼
    // ä»¥å‰ï¼šè‹±æ•°å­—ä»¥å¤–ã‚’å…¨éƒ¨æ¶ˆã—ã¦ã„ãŸï¼ˆæ—¥æœ¬èªã‚‚æ¶ˆãˆã¦ã„ãŸï¼‰
    // const sanitizedRoomId = inputRoom.replace(/[^a-zA-Z0-9]/g, '');

    // ä»Šå›ï¼šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ç¦æ­¢ã•ã‚Œã¦ã„ã‚‹ã€Œ. # $ [ ] /ã€ã ã‘ã‚’æ¶ˆã™
    // ã“ã‚Œãªã‚‰ã€Œã²ã¿ã¤ã€ã€Œãƒ†ã‚¹ãƒˆã€ã€Œâ˜…ã€ãªã©ã‚‚ãã®ã¾ã¾é€šã‚Šã¾ã™
    const sanitizedRoomId = inputRoom.replace(/[.#$\[\]\/]/g, '');
    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²

    if (!sanitizedRoomId) {
        // è¨˜å·ã—ã‹å…¥åŠ›ã—ã¦ã„ãªã‹ã£ãŸå ´åˆã®å¯¾ç­–
        alert("ãã®åˆè¨€è‘‰ã¯ä½¿ãˆã¾ã›ã‚“ï¼ˆç¦æ­¢è¨˜å·ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼‰");
        return;
    }

    // ä¿å­˜å ´æ‰€ã®è¨­å®šï¼ˆå‰å›åŒæ§˜ rooms_v2 ã«ã—ã¦ãŠãã¨å®‰å…¨ã§ã™ï¼‰
    roomId = "rooms_v2/" + sanitizedRoomId;
    
    const myName = document.getElementById('username-input').value.trim() || "PLAYER";

    // éƒ¨å±‹ã‚’è¦‹ã«è¡Œã
    const roomRef = ref(db, roomId);
    get(roomRef).then((snapshot) => {
        if (!snapshot.exists()) {
            // éƒ¨å±‹ãŒãªã„ â†’ è‡ªåˆ†ãŒãƒ›ã‚¹ãƒˆ
            createRoom(myName);
        } else {
            const data = snapshot.val();
            // ç©ºã„ã¦ã„ã‚‹å¸­ã‚’æ¢ã™
            if (!data.p1) {
                joinRoom(myName, 1);
            } else if (!data.p2) {
                joinRoom(myName, 2);
            } else {
                alert("ãã®éƒ¨å±‹ã¯æº€å“¡ã§ã™ï¼åˆ¥ã®åˆè¨€è‘‰ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚");
            }
        }
    }).catch((error) => {
        console.error(error);
        alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
    });
};

// éƒ¨å±‹ã‚’ä½œã‚‹(ãƒ›ã‚¹ãƒˆ)
function createRoom(name) {
    myPlayerId = Math.random() < 0.5 ? 1 : 2;

    const roomData = {
        p1: myPlayerId === 1 ? name : null,
        p2: myPlayerId === 2 ? name : null,
        status: "waiting",
        turn: 1,
        lastUpdate: Date.now()
    };

    const roomRef = ref(db, roomId);
    set(roomRef, roomData);

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚‚ã—è½ã¡ãŸã‚‰éƒ¨å±‹ã‚’æ¶ˆã™äºˆç´„ â–¼â–¼â–¼
    onDisconnect(roomRef).remove(); 
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    waitForOpponent();
}

// éƒ¨å±‹ã«å‚åŠ ã™ã‚‹(ã‚²ã‚¹ãƒˆ)
function joinRoom(name, joinAsId) {
    myPlayerId = joinAsId;
    
    const updates = {};
    updates[`p${myPlayerId}`] = name;
    updates["status"] = "ready";
    
    const roomRef = ref(db, roomId);
    update(roomRef, updates);

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚‚ã—è½ã¡ãŸã‚‰éƒ¨å±‹ã‚’æ¶ˆã™äºˆç´„ â–¼â–¼â–¼
    onDisconnect(roomRef).remove();
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
    
    const opponentId = myPlayerId === 1 ? 2 : 1;
    get(ref(db, roomId + `/p${opponentId}`)).then((snap) => {
        startGameOnline(snap.val());
    });
}

// ç›¸æ‰‹å¾…ã¡ç”»é¢
function waitForOpponent() {
    document.getElementById('title-screen').style.display = 'none';
    
    // â–¼â–¼â–¼ ä¿®æ­£ï¼šURLç”Ÿæˆã¨ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½ â–¼â–¼â–¼
    
    // ç¾åœ¨ã®åˆè¨€è‘‰ã‚’å–å¾—ï¼ˆå…¥åŠ›æ¬„ã‹ã‚‰ã§ã¯ãªãã€roomIdã‹ã‚‰v2/ãªã©ã‚’é™¤ã„ãŸã‚‚ã®ã‚’å¾©å…ƒã—ã¦ã‚‚è‰¯ã„ãŒã€å…¥åŠ›æ¬„ãŒæ‰‹ã£å–ã‚Šæ—©ã„ï¼‰
    const inputVal = document.getElementById('room-input').value;
    
    // æ‹›å¾…ç”¨URLã‚’ä½œã‚‹ (ä»Šã®URL + ?room=åˆè¨€è‘‰)
    // æ³¨æ„ï¼šã™ã§ã«?room=ãŒã¤ã„ã¦ã„ã‚‹å ´åˆã«å¯¾å¿œã™ã‚‹ãŸã‚ã€ä¸€æ—¦æ¶ˆã—ã¦ã‹ã‚‰ä»˜ã‘ç›´ã™
    const baseUrl = window.location.href.split('?')[0];
    const inviteUrl = `${baseUrl}?room=${inputVal}`;

    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹
    navigator.clipboard.writeText(inviteUrl).then(() => {
        showToast("æ‹›å¾…URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼å‹é”ã«é€ã‚ã†ï¼");
    }).catch(err => {
        // ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ãŸå ´åˆï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãªã©ï¼‰
        console.error('ã‚³ãƒ”ãƒ¼å¤±æ•—:', err);
        showToast("å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™...");
    });

    // â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–²
    
    // è‡ªåˆ†ãŒP1ãªã‚‰P2ã‚’å¾…ã¤ã€è‡ªåˆ†ãŒP2ãªã‚‰P1ã‚’å¾…ã¤
    const waitTargetId = myPlayerId === 1 ? 2 : 1;
    const waitRef = ref(db, roomId + `/p${waitTargetId}`);
    
    onValue(waitRef, (snapshot) => {
        if (snapshot.exists()) {
            showToast("ç›¸æ‰‹ãŒå‚åŠ ã—ã¾ã—ãŸï¼");
            startGameOnline(snapshot.val()); // ã‚²ãƒ¼ãƒ é–‹å§‹ã¸
        }
    });
}

// ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†ï¼ˆå…±é€šï¼‰
function startGameOnline(opponentName) {
    state.gameMode = 'ONLINE';
    state.turn = 1;
    state.turnPlayer = P1;
    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    
    const myName = document.getElementById('username-input').value || "YOU";
    const oppName = opponentName || "OPPONENT";

    // åå‰ãƒ©ãƒ™ãƒ«ã®è¨­å®šï¼ˆè‡ªåˆ†ãŒã©ã£ã¡ã«ãªã£ã¦ã‚‚æ­£ã—ãè¡¨ç¤ºã™ã‚‹ï¼‰
    if (myPlayerId === 1) {
        // è‡ªåˆ†ï¼é’(P1)
        document.getElementById('p1-label').innerText = myName;
        document.getElementById('p2-label').innerText = oppName;
    } else {
        // è‡ªåˆ†ï¼èµ¤(P2)
        document.getElementById('p1-label').innerText = oppName;
        document.getElementById('p2-label').innerText = myName;
    }

    document.getElementById('title-screen').style.display = 'none';
    initBoardUnits();
    resizeCanvas();
    updateTurnVisuals();
    gameLoop();
    resetTimer(); // â˜…è¿½åŠ 

    
    startOnlineListener();
}

// ç›¸æ‰‹ã®æ“ä½œã‚’å—ä¿¡ã—ã¦åæ˜ ã™ã‚‹
function startOnlineListener() {
    onValue(ref(db, roomId + "/action"), (snapshot) => {
        const action = snapshot.val();
        if (!action) return;
        
        // è‡ªåˆ†ãŒé€ã£ãŸãƒ‡ãƒ¼ã‚¿ãªã‚‰ç„¡è¦–
        if (action.sender === myPlayerId) return;

        // ç›¸æ‰‹ã®æ“ä½œã‚’å†ç¾
        if (action.type === 'SELECT_CARD') {
            uiSelectCard(action.value, true); 
        } else if (action.type === 'ROTATE') {
            state.hiddenRotation = { indices: action.indices };
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals();
            showToast("ç›¸æ‰‹ãŒå›è»¢ã‚’æ±ºã‚ã¾ã—ãŸ");
        } else if (action.type === 'MOVE') {
            state.defenderMoves = action.moves;
            startTurnResolution(); 
        } 
        /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¨ãƒ¢ãƒ¼ãƒˆã®å—ä¿¡ â–¼â–¼â–¼ */
        else if (action.type === 'EMOTE') {
            // ç›¸æ‰‹(action.sender)ã¨ã—ã¦ã‚¨ãƒ¢ãƒ¼ãƒˆã‚’è¡¨ç¤º
            sendEmote(action.value, action.sender);
        }
        /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */
    });
}


/* â–¼â–¼â–¼ ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½ â–¼â–¼â–¼ */

// ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦é–‹å§‹ï¼ˆãƒ•ã‚§ãƒ¼ã‚ºãŒå¤‰ã‚ã‚‹ãŸã³ã«å‘¼ã¶ï¼‰
function resetTimer() {
    clearInterval(state.timerInterval);
    state.timeLeft = 30; // åˆ¶é™æ™‚é–“ï¼ˆç§’ï¼‰
    updateTimerDisplay();

    // 1ç§’ã”ã¨ã«æ¸›ã‚‰ã™
    state.timerInterval = setInterval(() => {
        state.timeLeft--;
        updateTimerDisplay();

        if (state.timeLeft <= 0) {
            clearInterval(state.timerInterval);
            handleTimeout(); // æ™‚é–“åˆ‡ã‚Œã®å‡¦ç†
        }
    }, 1000);
}

// ç”»é¢è¡¨ç¤ºã®æ›´æ–°
function updateTimerDisplay() {
    const el = document.getElementById('timer-display');
    if (!el) return;
    el.innerText = state.timeLeft;
    
    // æ®‹ã‚Š10ç§’ã‚’åˆ‡ã£ãŸã‚‰èµ¤ãã™ã‚‹
    if (state.timeLeft <= 10) {
        el.classList.add('danger');
    } else {
        el.classList.remove('danger');
    }
}

// æ™‚é–“åˆ‡ã‚Œã«ãªã£ãŸæ™‚ã®è‡ªå‹•æ“ä½œ
function handleTimeout() {
    // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®å ´åˆã€è‡ªåˆ†ã®æ“ä½œæ‰‹ç•ªã§ãªã‘ã‚Œã°å‹æ‰‹ã«å‹•ã‹ãªã„
    if (state.gameMode === 'ONLINE') {
        const isMyTurn = (state.phase === 'DEFENDER_MOVE') 
            ? (state.turnPlayer.id !== myPlayerId) // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºãªã‚‰é˜²å¾¡å´ï¼ˆï¼ã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã˜ã‚ƒãªã„æ–¹ï¼‰
            : (state.turnPlayer.id === myPlayerId); // æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºãªã‚‰æ”»æ’ƒå´

        if (!isMyTurn) return; // ç›¸æ‰‹ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆç›¸æ‰‹ãŒé€ä¿¡ã—ã¦ãã‚‹ã®ã‚’å¾…ã¤ï¼‰
    }
    
    // CPUæ€è€ƒä¸­ãªã‚‰ç„¡è¦–
    if (state.isCpuThinking) return;

    showToast("TIME UP!");

    // ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®å¼·åˆ¶æ“ä½œ
    if (state.phase === 'SELECT_CARD') {
        // å‹æ‰‹ã«ä¸€ç•ªå·¦ã®ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶
        uiSelectCard(2);
    } 
    else if (state.phase === 'SELECT_ROTATION') {
        // å›è»¢å¯èƒ½ãªæ–¹å‘ãŒã‚ã‚Œã°ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã«æ±ºå®šã™ã‚‹
        // ãªã‘ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¦ã‚«ãƒ¼ãƒ‰é¸æŠã«æˆ»ã‚‹ï¼ˆãŒã€ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²ããŸã‚é©å½“ã«å‡¦ç†ï¼‰
        if (state.validDirections.length > 0) {
            // å¼·åˆ¶æ±ºå®š
            const valid = state.validDirections[0];
            state.hiddenRotation = { indices: valid.indices };
            
            if (state.gameMode === 'ONLINE') sendAction('ROTATE', { indices: valid.indices });
            
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals(); // ã“ã“ã§ã‚¿ã‚¤ãƒãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹
        } else {
            // ä¸‡ãŒä¸€ç½®ã‘ãªã‹ã£ãŸã‚‰ã‚«ãƒ¼ãƒ‰é¸æŠã«æˆ»ã™
            state.phase = 'SELECT_CARD';
            resetTimer(); 
        }
    } 
    else if (state.phase === 'DEFENDER_MOVE') {
        // ç§»å‹•ã›ãšã«ç¢ºå®šã™ã‚‹
        uiConfirm();
    }
}

// è‡ªåˆ†ã®æ“ä½œã‚’é€ä¿¡ã™ã‚‹é–¢æ•°
function sendAction(type, data) {
    if (state.gameMode !== 'ONLINE') return;
    
    set(ref(db, roomId + "/action"), {
        type: type,
        sender: myPlayerId,
        ...data,
        timestamp: Date.now()
    });
}

/* â–²â–²â–² ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã“ã“ã¾ã§ â–²â–²â–² */

/* â–¼â–¼â–¼ è¿½åŠ ï¼šHTMLã®ãƒœã‚¿ãƒ³ã‹ã‚‰é–¢æ•°ã‚’å‘¼ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹è¨­å®š â–¼â–¼â–¼ */
window.startGame = startGame;
window.uiSelectCard = uiSelectCard;
window.uiConfirm = uiConfirm;
window.quitGame = quitGame;
window.backToTitle = backToTitle;
window.toggleEmoteMenu = toggleEmoteMenu;
window.sendEmote = sendEmote;

// â–¼â–¼â–¼ è¿½åŠ ï¼šç”»é¢ã‹ã‚‰é›¢ã‚ŒãŸã‚‰BGMã‚’æ­¢ã‚ã‚‹å‡¦ç† â–¼â–¼â–¼
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // ç”»é¢ãŒè¦‹ãˆãªããªã£ãŸã‚‰ï¼ˆã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã‚„ãƒ›ãƒ¼ãƒ ã«æˆ»ã£ãŸæ™‚ï¼‰
        bgm.pause();
    } else {
        // ç”»é¢ã«æˆ»ã£ã¦ããŸæ™‚
        // ã€Œã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§ã¯ãªã„ã€ã‹ã¤ã€Œãƒªã‚¶ãƒ«ãƒˆç”»é¢ã§ã¯ãªã„ã€æ™‚ã ã‘å†é–‹ã™ã‚‹
        const isTitleHidden = document.getElementById('title-screen').style.display === 'none';
        const isResultHidden = document.getElementById('result-screen').style.display === 'none';
        
        // ã‚²ãƒ¼ãƒ ä¸­ãªã‚‰BGMå†é–‹
        if (isTitleHidden && isResultHidden) {
            bgm.play().catch(e => console.log("BGMå†é–‹ã‚¨ãƒ©ãƒ¼:", e));
        }
    }
});
// â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²


// â–¼â–¼â–¼ è¿½åŠ ï¼šURLã‹ã‚‰åˆè¨€è‘‰ã‚’èª­ã¿å–ã‚‹å‡¦ç† â–¼â–¼â–¼
window.addEventListener('DOMContentLoaded', () => {
    // URLã®ã€Œ?room=...ã€ã®éƒ¨åˆ†ã‚’è¦‹ã‚‹
    const params = new URLSearchParams(window.location.search);
    const inviteRoom = params.get('room');

    if (inviteRoom) {
        // åˆè¨€è‘‰æ¬„ã«ã‚»ãƒƒãƒˆã™ã‚‹
        document.getElementById('room-input').value = inviteRoom;
        
        // åå‰å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã‚‹ï¼ˆã™ãã«åå‰ã‚’å…¥ã‚Œã¦å§‹ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
        document.getElementById('username-input').focus();
        
        // ã‚ã‹ã‚Šã‚„ã™ã„ã‚ˆã†ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºã™
        showToast("æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼åå‰ã‚’å…¥åŠ›ã—ã¦STARTï¼");
    }
});

/* --- æ–°ã—ã„UIç”¨ã®é–¢æ•° --- */

// è¨­å®šç”»é¢ã‚’é–‹ã
window.openSettings = function() {
    document.getElementById('settings-modal').classList.add('active');
    // å…¥åŠ›æ¬„ã«ä»Šã®å€¤ã‚’å…¥ã‚Œã¦ãŠã
    // (æ—¢ã«HTMLã®inputã«å…¥åŠ›ã•ã‚ŒãŸå€¤ã¯ä¿æŒã•ã‚Œã¦ã„ã¾ã™ãŒã€å¿µã®ãŸã‚)
};

// è¨­å®šç”»é¢ã‚’é–‰ã˜ã‚‹
window.closeSettings = function() {
    document.getElementById('settings-modal').classList.remove('active');
    // ã“ã“ã§åå‰ãªã©ã‚’ä¿å­˜ã™ã‚‹å‡¦ç†ã‚’å…¥ã‚Œã¦ã‚‚è‰¯ã„ã§ã™ãŒã€
    // inputã®å€¤ã¯ãã®ã¾ã¾æ®‹ã‚‹ã®ã§ã€startGameæ™‚ã«èª­ã¿è¾¼ã¾ã‚Œã¾ã™ã€‚
};

// éŸ³é‡ã‚’å¤‰ãˆã‚‹
window.changeVolume = function(val) {
    bgm.volume = parseFloat(val);
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ã—ã¦å†ç”Ÿã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã¡ã‚‡ã£ã¨é³´ã‚‰ã—ã¦ã‚‚ã„ã„ã‹ã‚‚ï¼ˆãŠå¥½ã¿ã§ï¼‰
    if(bgm.paused) bgm.play().catch(()=>{});
};

// åˆè¨€è‘‰ç”»é¢ã‚’é–‹ãï¼ˆONLINEãƒœã‚¿ãƒ³ç”¨ï¼‰
window.openSecretModal = function() {
    document.getElementById('secret-modal').classList.add('active');
    // ã™ãã«å…¥åŠ›ã§ãã‚‹ã‚ˆã†ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
    setTimeout(() => {
        document.getElementById('room-input').focus();
    }, 100);
};

// åˆè¨€è‘‰ç”»é¢ã‚’é–‰ã˜ã‚‹
window.closeSecretModal = function() {
    document.getElementById('secret-modal').classList.remove('active');
};

// ã‚ªãƒ³ãƒ©ã‚¤ãƒ³é–‹å§‹ãƒœã‚¿ãƒ³ï¼ˆåˆè¨€è‘‰ç”»é¢ã®GOãƒœã‚¿ãƒ³ã‹ã‚‰å‘¼ã°ã‚Œã‚‹ï¼‰
// æ—¢å­˜ã® window.startOnlineGame ã‚’å°‘ã—ä¿®æ­£ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
// HTMLå´ã§ onclick="startOnlineGame()" ã¨ã—ã¦ã„ã‚‹ã®ã§ã€ãã®ã¾ã¾å‹•ãã¾ã™ã€‚
// ãŸã ã—ã€ã‚‚ã—æ¥ç¶šã«æˆåŠŸã—ãŸã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ãŸã„ã®ã§ã€æ—¢å­˜ã® startOnlineGame ã®æˆåŠŸæ™‚å‡¦ç†ã«è¿½åŠ ãŒå¿…è¦ã§ã™ã€‚


</script>
</body>
</html>