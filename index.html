<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>HONEY NOW</title>

    <style>
        /* å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
body {
    margin: 0;
    padding: 0;
    background-color: #050505;
    color: #fff;
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    display: flex;
    flex-direction: column;
    
    /* â–¼â–¼â–¼ ä¿®æ­£: ã‚¬ã‚¿ã¤ãé˜²æ­¢ã®å›ºå®šè¨­å®š â–¼â–¼â–¼ */
    position: fixed;     /* ç”»é¢ã‚’å¼·åˆ¶çš„ã«å›ºå®š */
    width: 100%;         /* å¹…ã‚’å›ºå®š */
    height: 100svh;      /* ã€Œã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ãŒå‡ºã¦ã„ã‚‹æ™‚ã®é«˜ã•ã€ã§å›ºå®š */
    /* â–²â–²â–² ä¿®æ­£ã“ã“ã¾ã§ â–²â–²â–² */
    
    touch-action: none;
    -webkit-text-size-adjust: 100%;
    
    overflow: hidden;
    transition: background-color 0.5s ease;
}

        /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        .title-text {
            font-size: 40px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px #00ccff, 0 0 20px #ff3366;
            margin-bottom: 50px;
            letter-spacing: 2px;
            text-align: center;
        }
        .mode-btn {
            background: linear-gradient(90deg, #00ccff, #0088cc);
            color: #fff;
            border: 2px solid #fff;
            padding: 20px 40px;
            margin: 10px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            width: 80%;
            max-width: 300px;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
            transition: transform 0.1s, box-shadow 0.2s;
            text-transform: uppercase;
        }
        .mode-btn:active { transform: scale(0.95); }
        .mode-btn.cpu {
            background: linear-gradient(90deg, #ff3366, #cc0033);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.5);
        }

/* ãƒ˜ãƒƒãƒ€ãƒ¼ */
header {
    padding: 20px;
    padding-top: max(40px, env(safe-area-inset-top)); 
    background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0));
    border-bottom: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    pointer-events: none;
}

/* â–¼â–¼â–¼ ãƒ˜ãƒƒãƒ€ãƒ¼å†…ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ (æ–°è¦è¿½åŠ ) â–¼â–¼â–¼ */
.score-board {
    display: flex;
    justify-content: space-between; /* å·¦å³ã«é…ç½® */
    align-items: center;    /* ä¸Šä¸‹ä¸­å¤®æƒãˆ */
    width: 100%;            /* æ¨ªå¹…ã„ã£ã±ã„ */
    padding: 0 20px;        /* å·¦å³ã«å°‘ã—ä½™ç™½ */
    box-sizing: border-box; /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å«ã‚ãŸå¹…è¨ˆç®— */
}

.player-label {
    font-size: 14px;
    font-weight: bold;
    letter-spacing: 2px;
    width: 80px; /* å¹…ã‚’å›ºå®šã—ã¦ä¸­å¤®ãŒã‚ºãƒ¬ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    text-align: center;
    opacity: 0.8;
}

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã®è‰²åˆ†ã‘ */
#p1-label {
    color: #00ccff; /* é’ */
    text-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
    text-align: left; /* å·¦å¯„ã› */
}

#p2-label {
    color: #ff3366; /* èµ¤ */
    text-shadow: 0 0 10px rgba(255, 51, 102, 0.5);
    text-align: right; /* å³å¯„ã› */
}

/* æ—¢å­˜ã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã®å¾®èª¿æ•´ï¼ˆä½™ç™½ãªã©ï¼‰ */
#turn-indicator {
    /* æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯ãã®ã¾ã¾ç¶­æŒã—ã¤ã¤ã€ãƒãƒ¼ã‚¸ãƒ³ã ã‘èª¿æ•´ */
    margin: 0 10px;
}

/* â–¼â–¼â–¼ ã“ã“ãŒå¾©æ´»ã•ã›ã‚‹ãƒã‚¤ãƒ³ãƒˆ â–¼â–¼â–¼ */
#card-info {

    position: relative;
    left: 5px; 

    color: #ffd700;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: 1px;
}

#card-info svg {
    height: 100%;       
    width: auto;        
    fill: currentColor; 
    filter: none; /* å…‰ã‚‰ã›ãªã„è¨­å®š */
}


#turn-indicator {
    font-size: 40px;
    font-weight: 900;
    text-shadow: 0 0 20px currentColor;
    letter-spacing: 4px;
    line-height: 1;
}

#phase-badge {
    /* â–¼â–¼â–¼ è¿½åŠ : å·¦ã«ãšã‚‰ã™è¨­å®š â–¼â–¼â–¼ */
    position: relative;
    left: 3px;       /* ä¸Šã¨åŒã˜æ•°å­—ã«ã™ã‚‹ã¨æƒã„ã¾ã™ */
    /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */

    height: 24px;
    line-height: 24px;
    margin-bottom: 5px;

    background: transparent;
    padding: 0;
    font-size: 16px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 8px;
    opacity: 0.8;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    
    /* å¿µã®ãŸã‚ç©ºã§ã‚‚è¡¨ç¤ºé ˜åŸŸã‚’ç¶­æŒã•ã›ã‚‹ */
    display: block; 
    width: 100%;
    text-align: center;
}

        /* ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ */
        #game-area {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

canvas {
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
    

    position: relative;
    top: -10px; 
}

/* ãƒ•ãƒƒã‚¿ãƒ¼ */
footer {
    padding: 20px;
    padding-bottom: max(50px, env(safe-area-inset-bottom));
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    /* gap: 15px;  â† å‰Šé™¤ï¼ˆã¾ãŸã¯ 0 ã«å¤‰æ›´ï¼‰ */
    gap: 0;
    border-top: 1px solid rgba(255,255,255,0.1);
}

/* æ–°è¦è¿½åŠ ï¼šæ“ä½œãƒ‘ãƒãƒ«ã®é«˜ã•ã‚’å¼·åˆ¶çš„ã«å›ºå®šã™ã‚‹ */
#action-area {
    width: 100%;
    height: 80px; /* ã“ã“ãŒé‡è¦ï¼ãƒœã‚¿ãƒ³ã‚ˆã‚Šå°‘ã—å¤§ãã„ã‚µã‚¤ã‚ºã§å›ºå®š */
    display: flex;
    justify-content: center;
    align-items: center;
}

/* å¿µã®ãŸã‚ã‚«ãƒ¼ãƒ‰ãƒ‘ãƒãƒ«ã‚‚å¹…ã„ã£ã±ã„ä½¿ã†ã‚ˆã†ã«èª¿æ•´ */
#card-panel {
    width: 100%;
    /* display: flex; ã¯JSã§åˆ¶å¾¡ã•ã‚Œã‚‹ã®ã§ãã®ã¾ã¾ã§OK */
}


        #card-panel {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .card {
            background: linear-gradient(145deg, #2a2a2a, #333);
            border: 2px solid #555;
            color: #aaa;
            padding: 5px 0; /* ä½™ç™½ã‚’å°‘ã—è©°ã‚ã‚‹ */
            width: 30%;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            font-weight: 800;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        /* SVGã‚¢ã‚¤ã‚³ãƒ³ã®è¨­å®š */
.card svg {
    height: 28px;
    width: auto;
    fill: currentColor;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5));
    max-width: 95%;
    
    /* â–¼â–¼â–¼ è¿½åŠ : ã“ã‚Œã§å³ã«ãšã‚Œã¾ã™ â–¼â–¼â–¼ */
    position: relative;
    left: 5px;   /* æ•°å­—ã‚’å¢—ã‚„ã™ã¨ã‚‚ã£ã¨å³ã«è¡Œãã¾ã™ */
}


        .card.selected {
            border-color: #ffd700;
            background: linear-gradient(145deg, #ffd700, #ffaa00);
            color: #000;
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(255, 215, 0, 0.3);
        }

        #main-btn {
            font-family: 'Arial Black', sans-serif; /* å¤ªã„ãƒ•ã‚©ãƒ³ãƒˆã« */
            font-size: 24px; /* æ–‡å­—ã‚’å¤§ãã */
            width: 100%;
            /* ...ä»¥ä¸‹æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«... */
            padding: 18px;
            background: linear-gradient(90deg, #ff8c00, #ff0080);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 4px 15px rgba(255, 0, 128, 0.4);
            transition: transform 0.1s;
        }
        #main-btn:disabled {
            background: #444;
            color: #888;
            box-shadow: none;
            cursor: not-allowed;
        }
        #main-btn:active { transform: scale(0.98); }

        #toast {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
        }

/* â–¼â–¼â–¼ ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« (æ–°è¦è¿½åŠ ) â–¼â–¼â–¼ */
#result-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 300; /* ã‚¿ã‚¤ãƒˆãƒ«ã‚ˆã‚Šæ‰‹å‰ã« */
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none; /* éè¡¨ç¤ºæ™‚ã¯ã‚¯ãƒªãƒƒã‚¯ç„¡åŠ¹ */
}
#result-screen.show {
    opacity: 1;
    pointer-events: auto;
}

.result-label {
    font-size: 24px;
    color: #fff;
    letter-spacing: 10px;
    margin-bottom: 10px;
    opacity: 0.8;
}

#winner-name {
    font-size: 60px;
    font-weight: 900;
    text-shadow: 0 0 30px currentColor;
    letter-spacing: 5px;
    transform: scale(0.5);
    transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
#result-screen.show #winner-name {
    transform: scale(1);
}

/* â–¼â–¼â–¼ ä¸­æ–­ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« (æ–°è¦è¿½åŠ ) â–¼â–¼â–¼ */
#quit-btn {
    position: absolute;
    top: max(10px, env(safe-area-inset-top)); /* ã‚¹ãƒãƒ›ã®ãƒãƒƒãƒå¯¾ç­– */
    left: 10px;
    z-index: 150; /* ã‚²ãƒ¼ãƒ ç”»é¢ã‚ˆã‚Šæ‰‹å‰ã€ã‚¿ã‚¤ãƒˆãƒ«ã‚ˆã‚Šå¥¥ */
    
    background: rgba(0, 0, 0, 0.5);
    color: rgba(255, 255, 255, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 20px;
    padding: 5px 15px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    backdrop-filter: blur(4px);
    transition: all 0.2s;
}
#quit-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
}
/* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«ã„ã‚‹æ™‚ã¯ãƒœã‚¿ãƒ³ã‚’éš ã™ */
#title-screen[style*="flex"] ~ #quit-btn {
    display: none;
}

/* â–¼â–¼â–¼ åå‰å…¥åŠ›æ¬„ã®ã‚¹ã‚¿ã‚¤ãƒ« (æ–°è¦è¿½åŠ ) â–¼â–¼â–¼ */
#username-input {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid #fff;
    border-radius: 15px;
    padding: 15px;
    margin-bottom: 20px;
    color: #fff;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    width: 60%;
    max-width: 250px;
    outline: none;
    text-transform: uppercase;
    letter-spacing: 2px;
    backdrop-filter: blur(5px);
    transition: all 0.3s;
}

#username-input::placeholder {
    color: rgba(255, 255, 255, 0.5);
}

#username-input:focus {
    background: rgba(0, 204, 255, 0.2);
    border-color: #00ccff;
    box-shadow: 0 0 15px rgba(0, 204, 255, 0.5);
}

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šã‚¨ãƒ¢ãƒ¼ãƒˆæ©Ÿèƒ½ã®ã‚¹ã‚¿ã‚¤ãƒ« â–¼â–¼â–¼ */
#emote-container {
    position: fixed;
    bottom: 160px;
    right: 20px;
    z-index: 150;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    
    /* â–¼â–¼â–¼ è¿½åŠ : é€æ˜ãªæ ãŒã‚¿ãƒƒãƒã‚’é‚ªé­”ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ â–¼â–¼â–¼ */
    pointer-events: none; 
}

#emote-btn {
    /* â–¼â–¼â–¼ è¿½åŠ : ãƒœã‚¿ãƒ³ã ã‘ã¯ã‚¯ãƒªãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«æˆ»ã™ â–¼â–¼â–¼ */
    pointer-events: auto; 
    
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, #fff, #ddd);
    border: none;
    font-size: 24px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    cursor: pointer;
    transition: transform 0.1s;
}

#emote-btn:active { transform: scale(0.9); }

#emote-menu {
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
    padding: 10px;
    border-radius: 15px;
    display: flex;
    flex-wrap: wrap; /* æŠ˜ã‚Šè¿”ã— */
    width: 140px;
    gap: 8px;
    justify-content: center;
    border: 1px solid rgba(255,255,255,0.2);
    
    /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨è¨­å®š */
    opacity: 0;
    transform: scale(0.8) translateY(20px);
    pointer-events: none;
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

#emote-menu.show {
    opacity: 1;
    transform: scale(1) translateY(0);
    pointer-events: auto;
}

.emote-item {
    font-size: 28px;
    cursor: pointer;
    transition: transform 0.1s;
    user-select: none;
}
.emote-item:hover { transform: scale(1.2); }
.emote-item:active { transform: scale(0.9); }

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆç‰ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ  â–¼â–¼â–¼ */

/* 1. è¦ªæ ã®è¨­å®šï¼ˆãã®ã¾ã¾ç¶­æŒï¼‰ */
.score-board {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 60px;
    padding: 0 10px;
    box-sizing: border-box;
}

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šæ ç·šã‚’ç´°ãã—ãŸã‚³ãƒ³ãƒ‘ã‚¯ãƒˆç‰ˆ â–¼â–¼â–¼ */

/* 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ  */
.player-badge {
    position: absolute;
    top: 5px;
    z-index: 100;
    
    display: flex;
    flex-direction: column;
    justify-content: center;
    
    width: 85px;        /* ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå¹… */
    height: auto;
    min-height: 40px;
    
    align-items: flex-start; 
    text-align: left;
    
    padding: 5px 8px;
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.6);
    
    /* â–¼â–¼â–¼ å¤‰æ›´: æ ç·šã‚’ 1px ã«ç´°ãã—ã¾ã—ãŸ â–¼â–¼â–¼ */
    border: 1px solid rgba(255, 255, 255, 0.3); 
    
    backdrop-filter: blur(4px);
    transition: all 0.3s;
}

/* ä½ç½®ã‚„å½±ã®è¨­å®šï¼ˆãã®ã¾ã¾ç¶­æŒï¼‰ */
.player-badge.p1 {
    left: 0;
    /* æ ã®è‰²ã‚‚å°‘ã—ç´°ã‚ã®å°è±¡ã«åˆã‚ã›ã¦èª¿æ•´ï¼ˆå½±ã§è‰²ã‚’å‡ºã™ï¼‰ */
    box-shadow: 0 0 8px rgba(0, 204, 255, 0.2) inset;
    border-color: rgba(0, 204, 255, 0.4); /* é’ã£ã½ãå…‰ã‚‰ã›ã‚‹ */
}

.player-badge.p2 {
    right: 0;
    box-shadow: 0 0 8px rgba(255, 51, 102, 0.2) inset;
    border-color: rgba(255, 51, 102, 0.4); /* èµ¤ã£ã½ãå…‰ã‚‰ã›ã‚‹ */
}

/* æ–‡å­—ã‚µã‚¤ã‚ºè¨­å®šï¼ˆå‰å›ã®ã¾ã¾ç¶­æŒï¼‰ */
.badge-name {
    font-size: 13px;
    font-weight: 900;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
    width: 100%;
    white-space: normal;
    word-break: break-word;
    line-height: 1.1;
}

.badge-comment {
    font-size: 9px;
    color: #ccc;
    font-weight: normal;
    white-space: normal;
    word-break: break-word;
    line-height: 1.2;
    max-width: 100%;
    opacity: 0.9;
}

/* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ç”¨ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« â–¼â–¼â–¼ */
.mode-btn.online {
    background: linear-gradient(90deg, #00ff99, #00cc88); /* ç·‘è‰²ç³» */
    box-shadow: 0 0 15px rgba(0, 255, 153, 0.5);
    margin-bottom: 20px; /* å°‘ã—é›¢ã™ */
    border-color: #fff;
    width: 90%; /* ã¡ã‚‡ã£ã¨å¤§ããç›®ç«‹ãŸã›ã‚‹ */
    max-width: 320px;
}

/* åˆè¨€è‘‰ã®å…¥åŠ›æ¬„ï¼ˆåå‰å…¥åŠ›ã¨åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«ï¼‹è‰²å¤‰ãˆï¼‰ */
#room-input {
    background: rgba(0, 255, 153, 0.1);
    border: 2px solid #00ff99;
    border-radius: 15px;
    padding: 15px;
    color: #00ff99;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    width: 60%;
    max-width: 250px;
    outline: none;
    text-transform: uppercase;
    letter-spacing: 2px;
    backdrop-filter: blur(5px);
    transition: all 0.3s;
}
#room-input::placeholder {
    color: rgba(0, 255, 153, 0.5);
}
#room-input:focus {
    background: rgba(0, 255, 153, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 153, 0.5);
}

/* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¿ã‚¤ãƒãƒ¼ã®ãƒ‡ã‚¶ã‚¤ãƒ³ â–¼â–¼â–¼ */
#timer-display {
    font-size: 32px;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 10px rgba(0,0,0,0.5);
    margin-top: 5px;
    font-family: 'Courier New', Courier, monospace; /* ãƒ‡ã‚¸ã‚¿ãƒ«æ™‚è¨ˆã£ã½ã */
    transition: color 0.3s;
}

/* æ®‹ã‚Šæ™‚é–“ãŒå°‘ãªã„æ™‚ï¼ˆJSã§ã‚¯ãƒ©ã‚¹ã‚’ã¤ã‘ã¾ã™ï¼‰ */
#timer-display.danger {
    color: #ff3333;
    text-shadow: 0 0 15px #ff0000;
    animation: pulse 0.5s infinite alternate;
}

@keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.1); }
}

    </style>
</head>
<body>

<div id="result-screen" style="display: none;">
    <div class="result-label">WINNER</div>
    <div id="winner-name">BLUE</div>
    <button class="mode-btn" onclick="backToTitle()" style="margin-top: 40px;">TITLE</button>
</div>

<button id="quit-btn" onclick="quitGame()">TOP</button>

<div id="title-screen">
    <div class="title-text" style="color: #ffd700; text-shadow: 0 0 20px #ffaa00;">
        HONEY<br>
        <span style="font-size:40px; color:#fff; letter-spacing: 8px;">NOW</span>
    </div>

    <input type="text" id="username-input" placeholder="ENTER NAME" maxlength="6">
    <input type="text" id="comment-input" placeholder="COMMENT" maxlength="30" style="margin-top:10px; font-size:16px;">

    <input type="text" id="room-input" placeholder="SECRET WORD" maxlength="10" style="margin-top:20px; border-color:#00ff99; color:#00ff99;">

    <div style="margin-top: 20px; display:flex; flex-direction:column; align-items:center; width:100%;">
        
        <button class="mode-btn online" onclick="startOnlineGame()">ONLINE MATCH</button>

        <button class="mode-btn cpu" onclick="startGame('PvE')">Vs CPU</button>
    </div>
</div>

<header>
    <div class="score-board">
        <div class="player-badge p1">
            <div class="badge-name" id="p1-label">PLAYER</div>
            <div class="badge-comment" id="p1-comment">READY?</div>
        </div>
        
        <div id="turn-indicator">BLUE</div>
        
        <div class="player-badge p2">
            <div class="badge-name" id="p2-label">CPU</div>
            <div class="badge-comment" id="p2-comment">...</div>
        </div>
    </div>

    <div id="card-info"></div>
    <div id="phase-badge">PICK CARD</div>

    <div id="timer-display">30</div>
    </header>

<div id="game-area">
    <canvas id="board"></canvas>
    <div id="toast"></div>
</div>

<div id="emote-container">
    <div id="emote-menu">
        <div class="emote-item" onclick="sendEmote('ğŸ˜€')">ğŸ˜€</div>
        <div class="emote-item" onclick="sendEmote('ğŸ¤”')">ğŸ¤”</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜±')">ğŸ˜±</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜')">ğŸ˜</div>
        <div class="emote-item" onclick="sendEmote('ğŸ‘')">ğŸ‘</div>
        <div class="emote-item" onclick="sendEmote('ğŸ˜¡')">ğŸ˜¡</div>
    </div>
    <button id="emote-btn" onclick="toggleEmoteMenu()">ğŸ’¬</button>
</div>

<footer>
    <div id="action-area">
        <div id="card-panel">
            <div class="card" onclick="uiSelectCard(2)">
                <svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
            
            <div class="card" onclick="uiSelectCard(3)">
                <svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>

            <div class="card" onclick="uiSelectCard(4)">
                <svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(10, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(27.32, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(44.64, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                    <g transform="translate(61.96, 12)">
                        <path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" />
                    </g>
                </svg>
            </div>
        </div>

        <button id="main-btn" onclick="uiConfirm()" disabled>GO!</button>
    </div>
    </footer>

<script type="module">
  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å®‰å®šç‰ˆã® 10.7.1 ã«çµ±ä¸€ã™ã‚‹ã®ãŒç„¡é›£ã§ã™
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
  
  // â–¼â–¼â–¼ ã“ã‚Œã‚’è¿½åŠ ï¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ã†ãŸã‚ã®éƒ¨å“ â–¼â–¼â–¼
import { getDatabase, ref, set, onValue, update, remove, get, child, onDisconnect } 
from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyDswxDswxU_DU-DdhYI8KsANtVeYVP6NN4",
    authDomain: "honeynow-7fe79.firebaseapp.com",
    
    /* â–¼â–¼â–¼ ã“ã‚Œã‚’è¿½åŠ ï¼ â–¼â–¼â–¼ */
    databaseURL: "https://honeynow-7fe79-default-rtdb.firebaseio.com",
    /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ï¼ˆæœ€å¾Œã®ã‚«ãƒ³ãƒã‚’å¿˜ã‚Œãšã«ï¼ï¼‰ â–²â–²â–² */
    
    projectId: "honeynow-7fe79",
    storageBucket: "honeynow-7fe79.firebasestorage.app",
    messagingSenderId: "745229921816",
    appId: "1:745229921816:web:345524bda3da61f8c7dd6d",
    measurementId: "G-RTEVBEYH3M"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);

  // â–¼â–¼â–¼ ã“ã‚Œã‚‚è¿½åŠ ï¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èµ·å‹• â–¼â–¼â–¼
  const db = getDatabase(app);

/** * å®šæ•°ãƒ»è¨­å®š */

const BOARD_RADIUS = 3;

/* â–¼â–¼â–¼ è¿½åŠ ï¼šBGMã®è¨­å®š â–¼â–¼â–¼ */
const bgm = new Audio('bgm.mp3'); // ãƒ•ã‚¡ã‚¤ãƒ«åã¨åˆã‚ã›ã‚‹
bgm.loop = true;   // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã™ã‚‹
bgm.volume = 0.3;  // éŸ³é‡ (0.0 ã€œ 1.0) 

const COLORS = {

    p1: '#00ccff', p1Bg: '#001a33',
    p2: '#ff3366', p2Bg: '#2a0a12',
    hex: '#222', hexEdge: '#333',
    damageZone: 'rgba(255, 50, 50, 0.2)', damageStroke: '#ff3333',
    previewLine: 'rgba(255, 255, 0, 0.8)', guideMarker: 'rgba(255, 255, 255, 0.3)'
};

const P1 = { id: 1, name: 'BLUE', color: COLORS.p1, bg: COLORS.p1Bg };
const P2 = { id: 2, name: 'RED', color: COLORS.p2, bg: COLORS.p2Bg };
const DIRECTIONS = [{dq:1,dr:0}, {dq:1,dr:-1}, {dq:0,dr:-1}, {dq:-1,dr:0}, {dq:-1,dr:1}, {dq:0,dr:1}];

/** * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ */
let state = {
    gameMode: null, // 'PvP' or 'PvE'
    turn: 1,
    turnPlayer: P1,
    phase: 'TITLE', 
    hexes: [],
    units: [],
    selectedCard: null,
    tempRotationStart: null,
    validDirections: [], 
    hiddenRotation: null,
    defenderMoves: [],
    selectedUnit: null,
    winner: null,
    frameCount: 0,
    isCpuThinking: false,
    emotes: [],
    damageEffects: [],
    
    /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¨ãƒ¢ãƒ¼ãƒˆç®¡ç† â–¼â–¼â–¼ */
    timeLeft: 30,
    timerInterval: null,
    lastEmoteTime: 0

};

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
let HEX_SIZE = 30;

/* --- åˆæœŸåŒ–ãƒ»ãƒ¢ãƒ¼ãƒ‰é¸æŠ (ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆ) --- */
function startGame(mode) {
    state.gameMode = mode;
    
    if (bgm.paused) {
        bgm.play().catch(e => console.log("BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:", e));
    }

    // 1. åå‰ã¨ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
    const inputName = document.getElementById('username-input').value.trim();

    const inputComment = document.getElementById('comment-input').value.trim();

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š
    const p1Name = inputName || (mode === 'PvE' ? "PLAYER" : "P1");
    // ã‚³ãƒ¡ãƒ³ãƒˆãŒç©ºæ¬„ãªã‚‰ "..." ã«ã™ã‚‹
    const p1Comment = inputComment || "..."; 

    const p2Name = mode === 'PvE' ? "CPU" : "P2";
    const p2Comment = "..."; // CPUã¯å¸¸ã«ç„¡è¨€

    // 2. ç”»é¢ï¼ˆæ ã®ä¸­ï¼‰ã«åæ˜ 
    document.getElementById('p1-label').innerText = p1Name;
    document.getElementById('p1-comment').innerText = p1Comment;

    document.getElementById('p2-label').innerText = p2Name;
    document.getElementById('p2-comment').innerText = p2Comment;

    // --- ã“ã“ã‹ã‚‰ä¸‹ã¯æ—¢å­˜ã¨åŒã˜ ---
    document.getElementById('title-screen').style.display = 'none';

    initBoardUnits();
    state.turn = 1;

    state.turnPlayer = P1;
    state.turnPlayer.nameDisplay = p1Name; 

    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    updateTurnVisuals();
    showToast("GAME START!");
    resizeCanvas();
    gameLoop();
    resetTimer(); // â˜…è¿½åŠ 


}

function initBoardUnits() {
    state.hexes = [];
    for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        let r1 = Math.max(-BOARD_RADIUS, -q - BOARD_RADIUS);
        let r2 = Math.min(BOARD_RADIUS, -q + BOARD_RADIUS);
        for (let r = r1; r <= r2; r++) {
            const dist = (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
            const isEdge = dist === BOARD_RADIUS;
            
            // â–¼â–¼â–¼ ä¿®æ­£: è§’ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã®åˆ¤å®šã‚’è¿½åŠ  â–¼â–¼â–¼
            // (q,r)åº§æ¨™ã®ç‰¹å¾´ã‹ã‚‰6ã¤ã®è§’ã‚’ç‰¹å®šã—ã¾ã™
            const isCorner = (Math.abs(q) === BOARD_RADIUS && r === 0) ||
                             (Math.abs(r) === BOARD_RADIUS && q === 0) ||
                             (Math.abs(q) === BOARD_RADIUS && r === -q);

            state.hexes.push({ q, r, isEdge, isCorner });
        }
    }
    const initialPositions = [
        { q: 2, r: 0, owner: 1 }, { q: 0, r: 2, owner: 2 },
        { q: -2, r: 2, owner: 1 }, { q: -2, r: 0, owner: 2 },
        { q: 0, r: -2, owner: 1 }, { q: 2, r: -2, owner: 2 }
    ];
    state.units = [];
    initialPositions.forEach((pos, i) => {
        state.units.push({
            id: `u${i}`, owner: pos.owner, q: pos.q, r: pos.r, hp: 1000,
            animQ: pos.q, animR: pos.r
        });
    });
}

/* --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— --- */
function gameLoop() {
    state.frameCount++;
    state.units.forEach(u => {
        u.animQ += (u.q - u.animQ) * 0.2;
        u.animR += (u.r - u.animR) * 0.2;
    });
    draw();
    if (!state.winner) requestAnimationFrame(gameLoop);
}

/* --- æç”»ãƒ­ã‚¸ãƒƒã‚¯ (æ¼”å‡ºå¼·åŒ–ãƒ»ã‚·ã‚§ã‚¤ã‚¯ãªã—ç‰ˆ) --- */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ã‚°ãƒªãƒƒãƒ‰æç”»ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    state.hexes.forEach(h => {
        const {x, y} = hexToPixel(h.q, h.r);
        let color = COLORS.hex;
        let stroke = COLORS.hexEdge;
        let lineWidth = 1;
        if (h.isEdge) { stroke = COLORS.damageStroke; lineWidth = 2; }
        if (state.hiddenRotation && state.phase === 'ANIMATION' && state.hiddenRotation.indices.includes(getHexIndex(h.q, h.r))) {
             color = '#444';
        }
        drawHex(x, y, HEX_SIZE * 0.95, color, stroke, lineWidth);
        
        // ç§»å‹•ã‚¬ã‚¤ãƒ‰
        if (state.phase === 'DEFENDER_MOVE' && state.selectedUnit && !state.isCpuThinking) {
            if (!getUnitAt(h.q, h.r)) {
                ctx.beginPath(); ctx.arc(x, y, HEX_SIZE * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.guideMarker; ctx.fill();
            }
        }
    });

    // å›è»¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    if (state.phase === 'SELECT_ROTATION' && state.tempRotationStart) {
        const startPos = hexToPixel(state.tempRotationStart.q, state.tempRotationStart.r);
        drawHex(startPos.x, startPos.y, HEX_SIZE * 0.9, '#ffd700', '#fff', 3);
        state.validDirections.forEach(dirObj => {
            dirObj.indices.forEach(idx => {
                if(state.hexes[idx] === state.tempRotationStart) return;
                const h = state.hexes[idx];
                const p = hexToPixel(h.q, h.r);
                ctx.save();
                ctx.globalAlpha = 0.5;
                drawHex(p.x, p.y, HEX_SIZE * 0.85, '#ffd700', null, 0); 
                ctx.restore();
            });
            const lastIdx = dirObj.indices[dirObj.indices.length - 1];
            const lastHex = state.hexes[lastIdx];
            const endP = hexToPixel(lastHex.q, lastHex.r);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath(); ctx.arc(endP.x, endP.y, 4, 0, Math.PI*2); ctx.fill();
        });
    }

    // ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    [1, 2].forEach(ownerId => {
        const myUnits = state.units.filter(u => u.owner === ownerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.animQ, u.animR));
            const isEq = isEquilateral(pts[0], pts[1], pts[2]);
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[1].x, pts[1].y); ctx.lineTo(pts[2].x, pts[2].y); ctx.closePath();
            const color = ownerId === 1 ? COLORS.p1 : COLORS.p2;
            if (isEq) {
                ctx.strokeStyle = color; ctx.lineWidth = 4;
                ctx.shadowColor = color; ctx.shadowBlur = 20; ctx.stroke();
                ctx.fillStyle = color + '22'; ctx.fill();
            } else {
                ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.shadowBlur = 0; ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }
    });

    // ãƒ¦ãƒ‹ãƒƒãƒˆæç”»
    state.units.forEach(u => {
        const {x, y} = hexToPixel(u.animQ, u.animR);
        let color = u.owner === 1 ? COLORS.p1 : COLORS.p2;
        
        // â–¼â–¼â–¼ è¿½åŠ : ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸç¬é–“ã«ç™½ãå…‰ã‚‰ã›ã‚‹ â–¼â–¼â–¼
        if (u.hitFlash > 0) {
             color = '#fff'; 
             u.hitFlash--; // ã‚¿ã‚¤ãƒãƒ¼ã‚’æ¸›ã‚‰ã™
        }

        // ç§»å‹•ç·š
        const move = state.defenderMoves.find(m => m.unitId === u.id);
        if (move) {
            const destHex = state.hexes[move.toIndex];
            const destPos = hexToPixel(destHex.q, destHex.r);
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(destPos.x, destPos.y);
            ctx.strokeStyle = '#fff'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        let size = HEX_SIZE * 0.7; let stroke = '#fff'; let lw = 2;
        if (state.selectedUnit && state.selectedUnit.id === u.id) {
            size *= 1.1; stroke = '#ffd700'; lw = 4;
            ctx.beginPath(); ctx.arc(x, y, HEX_SIZE, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke();
        }
        drawHex(x, y, size, color, stroke, lw);
        // HP
        const hpPct = u.hp / 1000;
        ctx.fillStyle = '#000'; ctx.fillRect(x - 15, y - 5, 30, 4);
        ctx.fillStyle = hpPct > 0.5 ? '#0f0' : '#f00'; ctx.fillRect(x - 15, y - 5, 30 * Math.max(0, hpPct), 4);
    });
    
    drawEmotes();
}

/* â–¼â–¼â–¼ ä¿®æ­£: ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡º (å…‰ã‚‹ã ã‘) â–¼â–¼â–¼ */
function addDamageEffect(unit, damage) {
    // æ•°å­—ãŒå‡ºã‚‹å‡¦ç†ã¯å‰Šé™¤ã—ã¾ã—ãŸ

    // ãƒ¦ãƒ‹ãƒƒãƒˆã‚’å…‰ã‚‰ã›ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚»ãƒƒãƒˆ
    unit.hitFlash = 10; 
}


function drawHex(x, y, size, fill, stroke, lw) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = 2 * Math.PI / 6 * i + Math.PI/6;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}
function drawArrowHead(x, y) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill(); }

/* --- UIåˆ¶å¾¡ & CPUãƒ­ã‚¸ãƒƒã‚¯ --- */
function updateTurnVisuals() {
    const p = state.turnPlayer;
    
    // èƒŒæ™¯è‰²ã¯ãã®ã¾ã¾
    document.body.style.backgroundColor = p.bg;
    
    const indicator = document.getElementById('turn-indicator');
    const badge = document.getElementById('phase-badge');
    const cardPanel = document.getElementById('card-panel');
    const mainBtn = document.getElementById('main-btn');

    // â–¼â–¼â–¼ ä¿®æ­£: åå‰ã ã‘ã‚’è¡¨ç¤ºï¼ˆTURNã¯æ¶ˆã™ï¼‰ â–¼â–¼â–¼
    indicator.innerText = p.name; 
    indicator.style.color = p.color;

    // CPUã‚¿ãƒ¼ãƒ³ä¸­ã¯æ“ä½œç„¡åŠ¹
    if (state.isCpuThinking) {
        cardPanel.style.pointerEvents = 'none';
        mainBtn.disabled = true;
        // â–¼â–¼â–¼ ä¿®æ­£: ã‚·ãƒ³ãƒ—ãƒ«ã« â–¼â–¼â–¼
        badge.innerText = "WAIT"; 
        badge.style.color = "#aaa";
        return;
    }
    cardPanel.style.pointerEvents = 'auto';

    // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ï¼ˆæ”»æ’ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼‰
    if (state.phase === 'SELECT_CARD') {
        // â–¼â–¼â–¼ ä¿®æ­£: çŸ­ã„å˜èªã¸ â–¼â–¼â–¼
        badge.innerText = "PICK CARD";
        badge.style.color = "#fff";
        cardPanel.style.display = 'flex'; mainBtn.style.display = 'none';
        
    } else if (state.phase === 'SELECT_ROTATION') {
        // â–¼â–¼â–¼ ä¿®æ­£: ç‹™ãˆï¼ã¨ã„ã†ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ â–¼â–¼â–¼
        badge.innerText = "AIMING"; 
        badge.style.color = "#fff";
        cardPanel.style.display = 'flex'; mainBtn.style.display = 'none';
        
    } else if (state.phase === 'DEFENDER_MOVE') {
        // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ï¼ˆå›é¿ãƒ•ã‚§ãƒ¼ã‚ºï¼‰
        // â–¼â–¼â–¼ ä¿®æ­£: ç·Šæ€¥æ„Ÿã‚’å‡ºã™ â–¼â–¼â–¼
        badge.innerText = "MOVE"; 
        badge.style.color = "#ff3333"; // èµ¤æ–‡å­—ã§è­¦å‘Šæ„Ÿ

        cardPanel.style.display = 'none'; mainBtn.style.display = 'block';
        
        const defender = state.turnPlayer.id === 1 ? P2 : P1;
        
        // ãƒœã‚¿ãƒ³ã®æ–‡å­—ã‚‚å¤‰æ›´
        mainBtn.innerText = "GO";
        
        mainBtn.disabled = false;
        
        // æ‰‹ç•ªè¡¨ç¤ºã‚’é˜²å¾¡å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã«å¤‰æ›´
        indicator.innerText = defender.name;
        indicator.style.color = defender.color;
        document.body.style.backgroundColor = defender.bg;
        
    } else {
        badge.innerText = "";
    }
}

// CPUã®è¡Œå‹•å‡¦ç† (å¼·åŒ–ç‰ˆ: åŒã˜ãƒ¦ãƒ‹ãƒƒãƒˆã®é€£ç¶šç§»å‹•ç¦æ­¢)
async function triggerCpuAction() {
    if (state.gameMode !== 'PvE' || state.winner) return;
    
    const isCpuAttacker = (state.turnPlayer.id === 2);
    const isCpuDefender = (state.turnPlayer.id === 1 && state.phase === 'DEFENDER_MOVE');

    if (!isCpuAttacker && !isCpuDefender) return;

    state.isCpuThinking = true;
    updateTurnVisuals();

    await wait(1000);

    // --- æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚º ---
    if (state.phase === 'SELECT_CARD') {
        const bestAction = aiFindBestCardAction();
        const choice = bestAction.cardLen;
        uiSelectCard(choice, true);
        showToast(`CPU SELECT: ${choice}é€£`);
        await wait(1500);
        
        if (bestAction.indices) {
            state.hiddenRotation = { indices: bestAction.indices };
            state.phase = 'DEFENDER_MOVE';
            state.tempRotationStart = null;
            state.validDirections = [];
            showToast("CPUãŒå›è»¢ã‚’ã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
            updateTurnVisuals();
        } else {
            const cards = [2,3,4];
            uiSelectCard(cards[0], true);
        }
    } 
    // --- é˜²å¾¡/ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º ---
    else if (state.phase === 'DEFENDER_MOVE') {
        // 1å›ç›®ã®ç§»å‹•
        let move1 = aiFindBestMove(); // å¼•æ•°ãªã—ï¼åˆ¶é™ãªã—
        if (move1) {
            state.defenderMoves.push({ unitId: move1.unitId, toIndex: move1.toIndex });
            
            // ä»®æƒ³åæ˜ 
            const u = state.units.find(u => u.id === move1.unitId);
            const originalQ = u.q; const originalR = u.r;
            const targetHex = state.hexes[move1.toIndex];
            u.q = targetHex.q; u.r = targetHex.r;

            // 2å›ç›®ã®ç§»å‹• (â˜…ä¿®æ­£: move1.unitId ã‚’æ¸¡ã—ã¦é™¤å¤–ã•ã›ã‚‹)
            let move2 = aiFindBestMove(move1.unitId);
            if (move2) {
                state.defenderMoves.push({ unitId: move2.unitId, toIndex: move2.toIndex });
            }

            // åº§æ¨™æˆ»ã—
            u.q = originalQ; u.r = originalR;
        }

        showToast("CPUãŒç§»å‹•ã—ã¾ã—ãŸ");
        await wait(500);
        startTurnResolution();
    }

    state.isCpuThinking = false;
    updateTurnVisuals();
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›
function uiSelectCard(len, fromCpu = false) {
    if (state.isCpuThinking && !fromCpu) return;
    
    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãªã‚‰ç›¸æ‰‹ã«é€ä¿¡ â–¼â–¼â–¼
    // (fromCpuãƒ•ãƒ©ã‚°ãŒã‚ã‚‹ï¼ç›¸æ‰‹ã‹ã‚‰ã®é€šä¿¡ã§å‹•ã„ã¦ã„ã‚‹æ™‚ã¯ã€å†é€ä¿¡ã—ãªã„)
    if (state.gameMode === 'ONLINE' && !fromCpu) {
        sendAction('SELECT_CARD', { value: len });
    }
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    state.selectedCard = len;
    
    // ... (ä»¥ä¸‹ã€æ—¢å­˜ã®ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤ºã‚³ãƒ¼ãƒ‰ãªã©ã¯ãã®ã¾ã¾) ...
    const svgs = {
        2: `<svg viewBox="0 0 45 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        3: `<svg viewBox="0 0 62 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`,
        4: `<svg viewBox="0 0 80 24" xmlns="http://www.w3.org/2000/svg"><g transform="translate(10, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(27.32, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(44.64, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g><g transform="translate(61.96, 12)"><path d="M0 -10 L8.66 -5 L8.66 5 L0 10 L-8.66 5 L-8.66 -5 Z" /></g></svg>`
    };
    document.getElementById('card-info').innerHTML = svgs[len];

    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    document.querySelectorAll('.card')[len-2].classList.add('selected');
    state.phase = 'SELECT_ROTATION';

    state.tempRotationStart = null;
    state.validDirections = [];
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ™‚ã ã‘ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    if (!fromCpu) {
        showToast("è»¸ã‚’é¸ã‚“ã§ãã ã•ã„");
    }
    updateTurnVisuals();
    
    // PvE CPUãƒˆãƒªã‚¬ãƒ¼ (ã“ã“ã¯å¤‰æ›´ãªã—)
    if (!fromCpu && state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}

function uiConfirm() {
    if (state.isCpuThinking) return;

    // â˜…è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§è‡ªåˆ†ã®ç•ªã˜ã‚ƒãªã„ãªã‚‰æŠ¼ã›ãªã„
    if (state.gameMode === 'ONLINE') {
        // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºã®æ±ºå®šãƒœã‚¿ãƒ³ãªã®ã§ã€é˜²å¾¡å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼(myPlayerId)ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (defenderId !== myPlayerId) return;
    }

    if (state.phase === 'DEFENDER_MOVE') {
        // â–¼â–¼â–¼ è¿½åŠ ï¼šç§»å‹•å†…å®¹ã‚’é€ä¿¡ â–¼â–¼â–¼
        if (state.gameMode === 'ONLINE') {
            sendAction('MOVE', { moves: state.defenderMoves });
        }
        // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

        startTurnResolution();
    }
}

function handleInput(x, y) {
    if (state.phase === 'TITLE' || state.phase === 'ANIMATION' || state.winner || state.isCpuThinking) return;

    // â˜…è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã®æ™‚ã¯æ“ä½œã•ã›ãªã„
    if (state.gameMode === 'ONLINE' && state.turnPlayer.id !== myPlayerId && state.phase !== 'DEFENDER_MOVE') return;
    // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚º(DEFENDER_MOVE)ã®æ™‚ã¯ã€é˜²å¾¡å´ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ãŒæ“ä½œã§ãã‚‹
    if (state.gameMode === 'ONLINE' && state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        if (defenderId !== myPlayerId) return;
    }

    const coords = pixelToHex(x, y);
    const hexIndex = getHexIndex(coords.q, coords.r);
    
    if (hexIndex === -1) return;
    const clickedHex = state.hexes[hexIndex];

    // å›è»¢è¨­å®š
    if (state.phase === 'SELECT_ROTATION') {
        if (!state.tempRotationStart) {
            state.tempRotationStart = clickedHex;
            calcValidDirections(clickedHex);
            if (state.validDirections.length === 0) {
                showToast("å›è»¢ä¸å¯"); state.tempRotationStart = null;
            }
        } else {
            const clickedIndex = getHexIndex(clickedHex.q, clickedHex.r);
            const valid = state.validDirections.find(v => v.indices.includes(clickedIndex));

            if (valid) {
                // ç¢ºå®šï¼
                state.hiddenRotation = { indices: valid.indices };
                
                // â–¼â–¼â–¼ è¿½åŠ ï¼šå›è»¢ã‚’é€ä¿¡ â–¼â–¼â–¼
                if (state.gameMode === 'ONLINE') {
                    sendAction('ROTATE', { indices: valid.indices });
                }
                // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²


                state.tempRotationStart = null;
                state.validDirections = [];
                state.phase = 'DEFENDER_MOVE';
                
                updateTurnVisuals();
                showToast("ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º");

                /* â–¼â–¼â–¼ è¿½åŠ ï¼šé˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºã«ãªã£ãŸã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ â–¼â–¼â–¼ */
                resetTimer();
                
                if (state.gameMode === 'PvE') triggerCpuAction();
            }
else {
                // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                state.tempRotationStart = clickedHex;
                calcValidDirections(clickedHex);
                if (state.validDirections.length === 0) {
                    state.tempRotationStart = null;
                }
            }
        }
    }

    // ç§»å‹•è¨­å®š
    else if (state.phase === 'DEFENDER_MOVE') {
        const defenderId = state.turnPlayer.id === 1 ? 2 : 1;
        // CPUã‚„ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®ç›¸æ‰‹ã®é§’ã¯è§¦ã‚Œãªã„
        if (state.gameMode === 'PvE' && defenderId === 2) return;

        const unit = getUnitAt(clickedHex.q, clickedHex.r);
        
        // è‡ªåˆ†ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸ã‚“ã å ´åˆ
        if (unit && unit.owner === defenderId) {
            if (state.selectedUnit === unit) {
                state.selectedUnit = null;
            } else {
                state.selectedUnit = unit;
            }
            if (state.defenderMoves.find(m => m.unitId === unit.id)) {
                state.defenderMoves = state.defenderMoves.filter(m => m.unitId !== unit.id);
            }

        // ç©ºããƒã‚¹ã‚’é¸ã‚“ã å ´åˆ
        } else if (state.selectedUnit && !unit) {
            const isReserved = state.defenderMoves.find(m => m.toIndex === hexIndex);
            if (isReserved) {
                showToast("æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã¾ã™");
                return;
            }
            if (state.defenderMoves.length >= 2) {
                showToast("ç§»å‹•ã§ãã‚‹ã®ã¯2ä½“ã¾ã§ï¼");
                return;
            }

            state.defenderMoves.push({ unitId: state.selectedUnit.id, toIndex: hexIndex });
            state.selectedUnit = null;
        }
        updateTurnVisuals();
    }
}

// ã‚¿ãƒ¼ãƒ³è§£æ±º
async function startTurnResolution() {
    state.phase = 'ANIMATION';
    updateTurnVisuals();

    // 1. ç§»å‹•
    for (let m of state.defenderMoves) {
        const u = state.units.find(u => u.id === m.unitId);
        const target = state.hexes[m.toIndex];
        u.q = target.q; u.r = target.r;
    }
    state.defenderMoves = [];
    await wait(800);

    // 2. å›è»¢
    const indices = state.hiddenRotation.indices;
    showToast("ROTATION!");
    await wait(500);
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        const h = state.hexes[hexIdx];
        const u = getUnitAt(h.q, h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos;
        let nextHex = state.hexes[indices[nextLinePos]];
        item.u.q = nextHex.q; item.u.r = nextHex.r;
    });
    await wait(1000);

    // 3. ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã“ã“ã‚’ä¸¸ã”ã¨æ›¸ãæ›ãˆï¼‰
    
    // è§’ãƒ»è¾ºã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒã‚§ãƒƒã‚¯
    state.units.forEach(u => {
        const h = state.hexes[getHexIndex(u.q, u.r)];
        
        let damage = 0;
        if (h.isCorner) {
            damage = 500; // è§’ã¯å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸
        } else if (h.isEdge) { 
            damage = 100; // è¾ºã¯å°ãƒ€ãƒ¡ãƒ¼ã‚¸
        }

        if (damage > 0) {
            u.hp -= damage;
            addDamageEffect(u, damage); // â˜…ã“ã“ã§æ¼”å‡ºå‘¼ã³å‡ºã—ï¼
        }
    });

    // ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«æ”»æ’ƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒã‚§ãƒƒã‚¯
    [1, 2].forEach(attackerId => {
        const myUnits = state.units.filter(u => u.owner === attackerId);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.q, u.r));
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const defenderId = attackerId===1?2:1;
                state.units.filter(u => u.owner === defenderId).forEach(target => {
                    const ratio = getTriangleOverlapRatio(target, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) { 
                        const dmg = Math.floor(500 * ratio);
                        target.hp -= dmg;
                        addDamageEffect(target, dmg); // â˜…ã“ã“ã§ã‚‚æ¼”å‡ºå‘¼ã³å‡ºã—ï¼
                    }
                });
            }
        }
    });
    
    // showToast ã¯å‰Šé™¤ã—ã¦å‘¼ã³å‡ºã•ãªã„
    await wait(1500);


    // çµ‚äº†åˆ¤å®š
    const p1Lose = state.units.some(u => u.owner === 1 && u.hp <= 0);
    const p2Lose = state.units.some(u => u.owner === 2 && u.hp <= 0);
    
    if (p1Lose || p2Lose) {
        // â–¼â–¼â–¼ ã“ã“ã‚’å¤‰æ›´ â–¼â–¼â–¼
        state.winner = p1Lose && p2Lose ? "DRAW" : (p1Lose ? "RED" : "BLUE"); // åå‰ã ã‘ã«ã™ã‚‹
        showResult(state.winner); // ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã‚’è¡¨ç¤º
        // â–²â–²â–² å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–²
    } else {
        nextTurn();
    }
}


function nextTurn() {
    state.turnPlayer = state.turnPlayer.id === 1 ? P2 : P1;
    if (state.turnPlayer.id === 1) state.turn++;
    
    // æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«ãªã£ãŸã‚‰è¡¨ç¤ºã‚’æ¶ˆã™
    document.getElementById('card-info').innerText = "";

    state.phase = 'SELECT_CARD';
    state.selectedCard = null;
    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
    
    updateTurnVisuals();
    showToast(`${state.turnPlayer.name}'s TURN`);

    /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ã‚¿ã‚¤ãƒãƒ¼å§‹å‹• â–¼â–¼â–¼ */
    resetTimer();

    // CPUã‚¿ãƒ¼ãƒ³é–‹å§‹
    if (state.gameMode === 'PvE' && state.turnPlayer.id === 2) {
        triggerCpuAction();
    }
}


// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
function calcValidDirections(startHex) {
    state.validDirections = [];
    DIRECTIONS.forEach((d, idx) => {
        const indices = getLineIndices(startHex, state.selectedCard, idx);
        if (indices) state.validDirections.push({ dirIdx: idx, indices: indices });
    });
}
function getLineIndices(startHex, len, dirIdx) {
    let indices = [];
    let curr = startHex;
    let dir = DIRECTIONS[dirIdx];
    for(let i=0; i<len; i++) {
        let idx = getHexIndex(curr.q, curr.r);
        if (idx === -1) return null;
        indices.push(idx);
        curr = { q: curr.q + dir.dq, r: curr.r + dir.dr };
    }
    return indices;
}
function hexToPixel(q, r) {
    const x = canvas.width/2 + HEX_SIZE * (Math.sqrt(3) * (q + r/2));
    const y = canvas.height/2 + HEX_SIZE * (3/2 * r);
    return { x, y };
}
function pixelToHex(x, y) {
    const pt = { x: x - canvas.width/2, y: y - canvas.height/2 };
    const q = (Math.sqrt(3)/3 * pt.x - 1/3 * pt.y) / HEX_SIZE;
    const r = (2/3 * pt.y) / HEX_SIZE;
    return cubeRound(q, r, -q-r);
}
function cubeRound(x, y, z) {
    let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
    const x_diff = Math.abs(rx - x), y_diff = Math.abs(ry - y), z_diff = Math.abs(rz - z);
    if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
    else if (y_diff > z_diff) ry = -rx - rz;
    else rz = -rx - ry;
    return { q: rx, r: ry };
}
function getHexIndex(q, r) { return state.hexes.findIndex(h => h.q === q && h.r === r); }
function getUnitAt(q, r) { return state.units.find(u => u.q === q && u.r === r); }
function isEquilateral(p1, p2, p3) {
    const d1 = Math.hypot(p1.x-p2.x, p1.y-p2.y);
    const d2 = Math.hypot(p2.x-p3.x, p2.y-p3.y);
    const d3 = Math.hypot(p3.x-p1.x, p3.y-p1.y);
    const avg = (d1 + d2 + d3) / 3;
    if (avg < 10) return false;
    return Math.abs(d1 - avg) < avg * 0.1 && Math.abs(d2 - avg) < avg * 0.1 && Math.abs(d3 - avg) < avg * 0.1;
}
function getTriangleOverlapRatio(unit, t1, t2, t3) {
    const unitPos = hexToPixel(unit.q, unit.r);
    
    // â–¼ ä¿®æ­£ï¼šè¦‹ãŸç›®ã®ã‚µã‚¤ã‚º(0.7)ã«åˆ¤å®šç¯„å›²ã‚’åˆã‚ã›ã‚‹ï¼
    // ã“ã‚Œã§ã€Œè§¦ã‚Œã¦ãªã„ã®ã«å½“ãŸã£ãŸã€ç¾è±¡ãŒæ¶ˆãˆã¾ã™
    const visualRadius = HEX_SIZE * 0.7; 

    let hitCount = 0;
    let totalPoints = 0;

    // 1. ä¸­å¿ƒç‚¹ã®ãƒã‚§ãƒƒã‚¯
    if (isPointInTriangle(unitPos, t1, t2, t3)) hitCount++;
    totalPoints++;

    // 2. å‘¨å›²ã®ç‚¹ã®ãƒã‚§ãƒƒã‚¯ï¼ˆç²¾åº¦ã‚’ä¸Šã’ã‚‹ãŸã‚3æ®µéšã«å¢—é‡ï¼‰
    const rings = [
        { r: 0.4, count: 6 },   // å†…å´
        { r: 0.8, count: 8 },   // ä¸­é–“
        { r: 1.0, count: 12 }   // å¤–å‘¨ï¼ˆä¸€ç•ªé‡è¦ãªã®ã§å¤šã‚ã«ï¼‰
    ];

    rings.forEach(ring => {
        // visualRadius ã‚’åŸºæº–ã«è¨ˆç®—ã™ã‚‹ã®ã§ã€è¦‹ãŸç›®ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„
        const r = visualRadius * ring.r;
        
        for(let i = 0; i < ring.count; i++) {
            const theta = (Math.PI * 2 / ring.count) * i;
            const p = {
                x: unitPos.x + r * Math.cos(theta),
                y: unitPos.y + r * Math.sin(theta)
            };
            
            if (isPointInTriangle(p, t1, t2, t3)) hitCount++;
            totalPoints++;
        }
    });

    return hitCount / totalPoints;
}

function isPointInTriangle(p, a, b, c) {
    const v0 = {x: c.x-a.x, y: c.y-a.y}, v1 = {x: b.x-a.x, y: b.y-a.y}, v2 = {x: p.x-a.x, y: p.y-a.y};
    const dot00 = v0.x*v0.x+v0.y*v0.y, dot01 = v0.x*v1.x+v0.y*v1.y, dot02 = v0.x*v2.x+v0.y*v2.y;
    const dot11 = v1.x*v1.x+v1.y*v1.y; 
    const dot12 = v1.x*v2.x+v1.y*v2.y; 
    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v < 1);
}

function resizeCanvas() {
    const c = document.getElementById('game-area');
    canvas.width = c.clientWidth; canvas.height = c.clientHeight;
    HEX_SIZE = Math.min((canvas.width*0.9)/(7*Math.sqrt(3)), (canvas.height*0.9)/(7*1.5));
}
function showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg; t.style.opacity = 1;
    setTimeout(() => t.style.opacity = 0, 2000);
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
window.addEventListener('resize', resizeCanvas);
// ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Œå…¨ã«é˜²ã
const preventScroll = (e) => { e.preventDefault(); };
canvas.addEventListener('touchmove', preventScroll, {passive: false});

canvas.addEventListener('touchstart', e => {
    e.preventDefault(); // ã“ã“ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç™ºç”Ÿã‚’é˜²ã
    const r = canvas.getBoundingClientRect();
    // ã‚¿ãƒƒãƒä½ç½®ã®è£œæ­£
    handleInput(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive: false});

// æœ€åˆã«Canvasã‚µã‚¤ã‚ºã‚’è¨­å®š
resizeCanvas();

/* --- AI Logic Helpers --- */

// å…¨ã‚«ãƒ¼ãƒ‰ãƒ»å…¨å›è»¢ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦æœ€å–„æ‰‹ã‚’æ¢ã™
function aiFindBestCardAction() {
    let bestScore = -Infinity;
    let bestAction = { cardLen: 3, indices: null }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

    const cardLens = [2, 3, 4];
    
    // å…¨ã‚«ãƒ¼ãƒ‰é•·
    for (let len of cardLens) {
        // å…¨ãƒã‚¹
        for (let i = 0; i < state.hexes.length; i++) {
            const h = state.hexes[i];
            // å…¨æ–¹å‘
            for (let dirIdx = 0; dirIdx < DIRECTIONS.length; dirIdx++) {
                const indices = getLineIndices(h, len, dirIdx);
                if (!indices) continue;

                // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒ¦ãƒ‹ãƒƒãƒˆã®åº§æ¨™ã‚’ä»®æ›´æ–°
                const simUnits = aiSimulateRotation(indices);
                
                // ç›¤é¢è©•ä¾¡
                const score = aiEvaluateBoard(simUnits);
                
                // ã‚¹ã‚³ã‚¢æ›´æ–° (ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’å°‘ã—å…¥ã‚Œã¦åŒã˜ã‚¹ã‚³ã‚¢ãªã‚‰ãƒãƒ©ã‘ã•ã›ã‚‹)
                if (score > bestScore + (Math.random() * 5)) { // åƒ…å·®ãªã‚‰å…¥ã‚Œæ›¿ãˆ
                    bestScore = score;
                    bestAction = { cardLen: len, indices: indices };
                }
            }
        }
    }
    return bestAction;
}

// å…¨ãƒ¦ãƒ‹ãƒƒãƒˆãƒ»å…¨ç§»å‹•å…ˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦æœ€å–„ã®ç§»å‹•ã‚’æ¢ã™
// å¼•æ•° excludeUnitId: è¨ˆç®—ã‹ã‚‰é™¤å¤–ã™ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆID (2å›ç›®ã®ç§»å‹•ã§ä½¿ç”¨)
function aiFindBestMove(excludeUnitId = null) {
    let bestScore = -Infinity;
    let bestMove = null;

    const cpuUnits = state.units.filter(u => u.owner === 2);
    
    // ç¾åœ¨åŸ‹ã¾ã£ã¦ã„ã‚‹å ´æ‰€
    const occupied = new Set(state.units.map(u => getHexIndex(u.q, u.r)));
    state.defenderMoves.forEach(m => occupied.add(m.toIndex));

    for (let u of cpuUnits) {
        // â˜…ä¿®æ­£: é™¤å¤–æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ‹ãƒƒãƒˆãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
        if (excludeUnitId && u.id === excludeUnitId) continue;

        const currentIdx = getHexIndex(u.q, u.r);
        
        // å…¨ç©ºããƒã‚¹ã‚’æ¢ç´¢
        for (let i = 0; i < state.hexes.length; i++) {
            if (occupied.has(i)) continue;
            if (i === currentIdx) continue;

            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            const simUnits = state.units.map(unit => ({ ...unit }));
            const targetUnit = simUnits.find(unit => unit.id === u.id);
            const targetHex = state.hexes[i];
            targetUnit.q = targetHex.q;
            targetUnit.r = targetHex.r;

            // è©•ä¾¡
            let score = aiEvaluateBoard(simUnits);

            // å¤–å‘¨å›é¿ãƒ­ã‚¸ãƒƒã‚¯
            if (targetHex.isEdge && score < 500) { 
                 score -= 1000;
            }

            if (score > bestScore + (Math.random() * 5)) {
                bestScore = score;
                bestMove = { unitId: u.id, toIndex: i };
            }
        }
    }
    return bestMove;
}

// å›è»¢çµæœã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦ãƒ¦ãƒ‹ãƒƒãƒˆã®ä»®åº§æ¨™ãƒªã‚¹ãƒˆã‚’è¿”ã™
function aiSimulateRotation(indices) {
    const simUnits = state.units.map(u => ({ ...u })); // Deep Copy
    let unitsOnLine = [];
    indices.forEach((hexIdx, linePos) => {
        const h = state.hexes[hexIdx];
        const u = simUnits.find(unit => unit.q === h.q && unit.r === h.r);
        if(u) unitsOnLine.push({ u, linePos });
    });
    
    const len = indices.length;
    unitsOnLine.forEach(item => {
        let nextLinePos = (len - 1) - item.linePos; // åè»¢
        let nextHex = state.hexes[indices[nextLinePos]];
        item.u.q = nextHex.q;
        item.u.r = nextHex.r;
    });
    return simUnits;
}

// ç›¤é¢ã®ã‚¹ã‚³ã‚¢è¨ˆç®— (ã“ã“ãŒAIã®åˆ¤æ–­åŸºæº–)
function aiEvaluateBoard(simUnits) {
    let score = 0;
    const cpuId = 2;
    const playerId = 1;

    // 1. å¤–å‘¨(Edge)ã®è©•ä¾¡
    simUnits.forEach(u => {
        const hIdx = getHexIndex(u.q, u.r);
        if (hIdx !== -1 && state.hexes[hIdx].isEdge) {
            // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€: ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’å¤§å¹…å¼·åŒ– (-300 -> -2000) â–¼â–¼â–¼
            // HPãŒæ¸›ã‚‹ã®ã‚’æ¥µç«¯ã«å«ŒãŒã‚‹ã‚ˆã†ã«è¨­å®š
            if (u.owner === cpuId) score -= 2000;   
            
            // æ•µã‚’å¤–å‘¨ã«è¿½ã„ã‚„ã‚‹ã®ã¯è‰¯ã„ã“ã¨
            if (u.owner === playerId) score += 300; 
        }
    });

    // 2. ä¸‰è§’å½¢(Triangle)ã®è©•ä¾¡
    [cpuId, playerId].forEach(owner => {
        const myUnits = simUnits.filter(u => u.owner === owner);
        if (myUnits.length === 3) {
            const pts = myUnits.map(u => hexToPixel(u.q, u.r));
            // æ­£ä¸‰è§’å½¢ãŒã§ãã¦ã„ã‚‹ã‹ï¼Ÿ
            if (isEquilateral(pts[0], pts[1], pts[2])) {
                const targetId = owner === cpuId ? playerId : cpuId;
                const targets = simUnits.filter(u => u.owner === targetId);
                
                let hits = 0;
                targets.forEach(t => {
                    const ratio = getTriangleOverlapRatio(t, pts[0], pts[1], pts[2]);
                    if (ratio > 0.01) hits++;
                });

                if (owner === cpuId) {
                    // è‡ªåˆ†ã®æ”»æ’ƒãƒãƒ£ãƒ³ã‚¹
                    if (hits > 0) {
                        score += 5000 * hits; // æ”»æ’ƒæˆåŠŸã¯é«˜è©•ä¾¡
                    } else {
                        score -= 200; // ç©ºæŒ¯ã‚Šã¯å°‘ã—æ¸›ç‚¹
                    }
                } else {
                    // æ•µã®æ”»æ’ƒï¼ˆè‡ªåˆ†ãŒé£Ÿã‚‰ã†ï¼‰
                    score -= 500; 
                    if (hits > 0) {
                        // â–¼â–¼â–¼ ä¿®æ­£ç®‡æ‰€: è¢«å¼¾ã®å›é¿å„ªå…ˆåº¦ã‚’ã•ã‚‰ã«ä¸Šã’ã‚‹ â–¼â–¼â–¼
                        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹çŠ¶æ…‹ã¯ã€Œæ­»ã€ã¨åŒç¾©ã¨ã—ã¦æœ€å¤§ç´šã®ãƒšãƒŠãƒ«ãƒ†ã‚£
                        score -= 20000 * hits; 
                    }
                }
            }
        }
    });

    return score;
}

/* --- ãƒªã‚¶ãƒ«ãƒˆç”»é¢åˆ¶å¾¡ (æ–°è¦è¿½åŠ ) --- */

function showResult(winnerName) {
    const screen = document.getElementById('result-screen');
    const nameEl = document.getElementById('winner-name');
    
    // è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã¨è‰²ã‚’è¨­å®š
    if (winnerName === "DRAW") {
        nameEl.innerText = "DRAW";
        nameEl.style.color = "#fff";
    } else {
        nameEl.innerText = winnerName;
        // å‹è€…ã®è‰²ã‚’é©ç”¨
        nameEl.style.color = (winnerName === "BLUE") ? COLORS.p1 : COLORS.p2;
    }

    // ç”»é¢ã‚’è¡¨ç¤º
    screen.style.display = 'flex';
    // å°‘ã—é…ã‚‰ã›ã¦ã‚¯ãƒ©ã‚¹è¿½åŠ ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
    setTimeout(() => {
        screen.classList.add('show');
    }, 10);
}

function backToTitle() {
    // â–¼â–¼â–¼ è¿½åŠ : ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã ã£ãŸå ´åˆã€Firebaseã®éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ã‚’æ¶ˆã™ â–¼â–¼â–¼
    if (state.gameMode === 'ONLINE' && roomId) {
        remove(ref(db, roomId))
            .then(() => console.log("éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"))
            .catch((e) => console.error("å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", e));
        
        roomId = null; // IDã‚’ãƒªã‚»ãƒƒãƒˆ
    }

    const resScreen = document.getElementById('result-screen');
    resScreen.classList.remove('show');

    setTimeout(() => resScreen.style.display = 'none', 500);

    // ã‚²ãƒ¼ãƒ å†…è¦ç´ ã®ã‚¯ãƒªã‚¢ï¼ˆå¿µã®ãŸã‚ï¼‰
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    document.getElementById('turn-indicator').innerText = "";
    document.getElementById('card-info').innerHTML = "";

    // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’è¡¨ç¤º
    document.getElementById('title-screen').style.display = 'flex';
}

/* --- ä¸­æ–­æ©Ÿèƒ½ (æ–°è¦è¿½åŠ ) --- */
function quitGame() {
    // èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ã®ç¢ºèª
    if (!confirm("ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ\nï¼ˆç¾åœ¨ã®å¯¾æˆ¦ã¯ç ´æ£„ã•ã‚Œã¾ã™ï¼‰")) {
        return;
    }

    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    state.winner = "QUIT"; 
    
    // CPUæ€è€ƒä¸­ãƒ•ãƒ©ã‚°ã‚‚æŠ˜ã‚‹ï¼ˆå¿µã®ãŸã‚ï¼‰
    state.isCpuThinking = false;

    // æ—¢å­˜ã®ã‚¿ã‚¤ãƒˆãƒ«æˆ»ã‚Šé–¢æ•°ã‚’å‘¼ã³å‡ºã™
    backToTitle();
}

/* --- ã‚¨ãƒ¢ãƒ¼ãƒˆæ©Ÿèƒ½ (æ–°è¦è¿½åŠ ) --- */

// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é–‹é–‰
function toggleEmoteMenu() {
    document.getElementById('emote-menu').classList.toggle('show');
}

/* â–¼â–¼â–¼ ä¿®æ­£ï¼šCanvasã®æ ã«é–¢ä¿‚ãªãè¡¨ç¤ºã™ã‚‹æœ€å¼·ç‰ˆ â–¼â–¼â–¼ */

// 1. æç”»é–¢æ•°ã¯ã‚‚ã†ä½¿ã‚ãªã„ã®ã§ç©ºã«ã™ã‚‹
function drawEmotes() {
    // DOMè¦ç´ ã§è¡¨ç¤ºã™ã‚‹ãŸã‚ã€ã“ã“ã§ã®å‡¦ç†ã¯ä¸è¦
}

// 2. æ–°ã—ã„ã‚¨ãƒ¢ãƒ¼ãƒˆè¡¨ç¤ºå‡¦ç†
function sendEmote(emoji, forceOwnerId = null) {
    /* â–¼â–¼â–¼ è¿½åŠ ï¼š3ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆé€£æ‰“é˜²æ­¢ï¼‰ â–¼â–¼â–¼ */
    const now = Date.now();
    // ç›¸æ‰‹ã‹ã‚‰ã®å—ä¿¡(forceOwnerIdã‚ã‚Š)ã®å ´åˆã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ç„¡è¦–
    if (!forceOwnerId && now - state.lastEmoteTime < 3000) { 
        showToast("å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...");
        return; 
    }
    if (!forceOwnerId) state.lastEmoteTime = now;
    /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
    document.getElementById('emote-menu').classList.remove('show');

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãªã‚‰ç›¸æ‰‹ã«é€ä¿¡ â–¼â–¼â–¼
    // forceOwnerIdãŒãªã„ï¼è‡ªåˆ†ãŒæŠ¼ã—ãŸãƒœã‚¿ãƒ³ ã¨ã„ã†æ„å‘³
    if (state.gameMode === 'ONLINE' && !forceOwnerId) {
        sendAction('EMOTE', { value: emoji });
    }
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    let ownerId;
    // ... (ä»¥ä¸‹ãã®ã¾ã¾) ...

    if (forceOwnerId) {
        ownerId = forceOwnerId;
    } else {
        if (state.gameMode === 'PvE') ownerId = 1;
        else ownerId = state.turnPlayer.id;
    }

    // â˜…HTMLè¦ç´ ï¼ˆdivï¼‰ã‚’æ–°ã—ãä½œã‚‹
    const el = document.createElement('div');
    el.innerText = emoji;
    
    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šï¼ˆç”»é¢ã®ã©ã“ã«ã§ã‚‚å‡ºã›ã‚‹è¨­å®šï¼‰
    el.style.position = 'fixed';
    el.style.zIndex = '9999';       // ç”»é¢ã®ä½•ã‚ˆã‚Šã‚‚æ‰‹å‰ã«
    el.style.fontSize = '40px';     // å¤§ãã•
    el.style.fontWeight = 'bold';
    el.style.pointerEvents = 'none'; // ã‚¯ãƒªãƒƒã‚¯ã®é‚ªé­”ã‚’ã—ãªã„
    el.style.textShadow = '0 4px 10px rgba(0,0,0,0.5)'; // å½±ã‚’ã¤ã‘ã¦è¦‹ã‚„ã™ã
    el.style.fontFamily = "Arial, sans-serif";

    // ä½ç½®è¨­å®šï¼ˆã“ã“ã§å¥½ããªé«˜ã•ã‚’æŒ‡å®šã§ãã¾ã™ï¼ï¼‰
    const topPosition = '120px'; // â˜…ã“ã“ã‚’å¤‰ãˆã‚Œã°ã„ãã‚‰ã§ã‚‚ä¸Šã«ã§ãã¾ã™

    if (ownerId === 1) {
        // P1 (å·¦å´)
        el.style.left = '40px'; 
        el.style.top = topPosition;
        el.style.transformOrigin = 'center left'; // å·¦ã‹ã‚‰å‡ºã‚‹æ„Ÿã˜
    } else {
        // P2 (å³å´)
        el.style.right = '40px'; // å³ç«¯ã‹ã‚‰ã®è·é›¢
        el.style.top = topPosition;
        el.style.transformOrigin = 'center right'; // å³ã‹ã‚‰å‡ºã‚‹æ„Ÿã˜
    }

    // ç”»é¢ã«è¿½åŠ 
    document.body.appendChild(el);

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š (Web Animations API)
    // ãƒãƒ³ãƒƒã¨å‡ºã¦ã€ãµã‚“ã‚ã‚Šä¸Šã«æ¶ˆãˆã‚‹å‹•ã
    const anim = el.animate([
        { transform: 'scale(0) translateY(20px)', opacity: 0 },    // 0%: å°ã•ãã¦é€æ˜
        { transform: 'scale(1.2) translateY(0)', opacity: 1, offset: 0.1 }, // 10%: ãƒãƒ³ãƒƒã¨æ‹¡å¤§
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.2 }, // 20%: å…ƒã®ã‚µã‚¤ã‚ºã«
        { transform: 'scale(1.0) translateY(0)', opacity: 1, offset: 0.7 }, // 70%: å¾…æ©Ÿ
        { transform: 'scale(1.0) translateY(-50px)', opacity: 0 }  // 100%: ä¸Šã«æ˜‡ã£ã¦æ¶ˆãˆã‚‹
    ], {
        duration: 1500, // 1.5ç§’ã‹ã‘ã¦å‹•ã
        easing: 'ease-out'
    });

    // ã‚¢ãƒ‹ãƒ¡ãŒçµ‚ã‚ã£ãŸã‚‰ã‚´ãƒŸæƒé™¤ï¼ˆè¦ç´ ã‚’å‰Šé™¤ï¼‰
    anim.onfinish = () => el.remove();
}

/* â–¼â–¼â–¼ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦æ©Ÿèƒ½ (Firebaseç‰ˆãƒ»ãƒ©ãƒ³ãƒ€ãƒ é™£å–¶) â–¼â–¼â–¼ */

let roomId = null;
let myPlayerId = 0; // 1=P1(é’), 2=P2(èµ¤)

// ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ é–‹å§‹ãƒœã‚¿ãƒ³
window.startOnlineGame = function() { 
    const inputRoom = document.getElementById('room-input').value.trim();
    if (!inputRoom) {
        alert("åˆè¨€è‘‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
    }
    
    // è‹±æ•°å­—ä»¥å¤–ã‚’é™¤å»
    roomId = "rooms/" + inputRoom.replace(/[^a-zA-Z0-9]/g, '');
    const myName = document.getElementById('username-input').value.trim() || "PLAYER";

    // éƒ¨å±‹ã‚’è¦‹ã«è¡Œã
    const roomRef = ref(db, roomId);
    get(roomRef).then((snapshot) => {
        if (!snapshot.exists()) {
            // éƒ¨å±‹ãŒãªã„ â†’ è‡ªåˆ†ãŒãƒ›ã‚¹ãƒˆï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã§å¸­ã‚’æ±ºã‚ã‚‹ï¼‰
            createRoom(myName);
        } else {
            const data = snapshot.val();
            // ç©ºã„ã¦ã„ã‚‹å¸­ã‚’æ¢ã™
            if (!data.p1) {
                // P1(é’)ãŒç©ºã„ã¦ã„ã‚‹ â†’ P1ã«ãªã‚‹
                joinRoom(myName, 1);
            } else if (!data.p2) {
                // P2(èµ¤)ãŒç©ºã„ã¦ã„ã‚‹ â†’ P2ã«ãªã‚‹
                joinRoom(myName, 2);
            } else {
                alert("ãã®éƒ¨å±‹ã¯æº€å“¡ã§ã™ï¼åˆ¥ã®åˆè¨€è‘‰ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚");
            }
        }
    }).catch((error) => {
        console.error(error);
        alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ");
    });
};

// éƒ¨å±‹ã‚’ä½œã‚‹(ãƒ›ã‚¹ãƒˆ)
function createRoom(name) {
    myPlayerId = Math.random() < 0.5 ? 1 : 2;

    const roomData = {
        p1: myPlayerId === 1 ? name : null,
        p2: myPlayerId === 2 ? name : null,
        status: "waiting",
        turn: 1,
        lastUpdate: Date.now()
    };

    const roomRef = ref(db, roomId);
    set(roomRef, roomData);

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚‚ã—è½ã¡ãŸã‚‰éƒ¨å±‹ã‚’æ¶ˆã™äºˆç´„ â–¼â–¼â–¼
    onDisconnect(roomRef).remove(); 
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²

    waitForOpponent();
}

// éƒ¨å±‹ã«å‚åŠ ã™ã‚‹(ã‚²ã‚¹ãƒˆ)
function joinRoom(name, joinAsId) {
    myPlayerId = joinAsId;
    
    const updates = {};
    updates[`p${myPlayerId}`] = name;
    updates["status"] = "ready";
    
    const roomRef = ref(db, roomId);
    update(roomRef, updates);

    // â–¼â–¼â–¼ è¿½åŠ ï¼šã‚‚ã—è½ã¡ãŸã‚‰éƒ¨å±‹ã‚’æ¶ˆã™äºˆç´„ â–¼â–¼â–¼
    onDisconnect(roomRef).remove();
    // â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–²
    
    const opponentId = myPlayerId === 1 ? 2 : 1;
    get(ref(db, roomId + `/p${opponentId}`)).then((snap) => {
        startGameOnline(snap.val());
    });
}


// ç›¸æ‰‹å¾…ã¡ç”»é¢
function waitForOpponent() {
    document.getElementById('title-screen').style.display = 'none';
    showToast("å¯¾æˆ¦ç›¸æ‰‹ã‚’å¾…ã£ã¦ã„ã¾ã™...");
    
    // è‡ªåˆ†ãŒP1ãªã‚‰P2ã‚’å¾…ã¤ã€è‡ªåˆ†ãŒP2ãªã‚‰P1ã‚’å¾…ã¤
    const waitTargetId = myPlayerId === 1 ? 2 : 1;
    const waitRef = ref(db, roomId + `/p${waitTargetId}`);
    
    onValue(waitRef, (snapshot) => {
        if (snapshot.exists()) {
            showToast("ç›¸æ‰‹ãŒå‚åŠ ã—ã¾ã—ãŸï¼");
            startGameOnline(snapshot.val()); // ã‚²ãƒ¼ãƒ é–‹å§‹ã¸
        }
    });
}

// ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†ï¼ˆå…±é€šï¼‰
function startGameOnline(opponentName) {
    state.gameMode = 'ONLINE';
    state.turn = 1;
    state.turnPlayer = P1;
    state.phase = 'SELECT_CARD';
    state.winner = null;
    state.isCpuThinking = false;
    
    const myName = document.getElementById('username-input').value || "YOU";
    const oppName = opponentName || "OPPONENT";

    // åå‰ãƒ©ãƒ™ãƒ«ã®è¨­å®šï¼ˆè‡ªåˆ†ãŒã©ã£ã¡ã«ãªã£ã¦ã‚‚æ­£ã—ãè¡¨ç¤ºã™ã‚‹ï¼‰
    if (myPlayerId === 1) {
        // è‡ªåˆ†ï¼é’(P1)
        document.getElementById('p1-label').innerText = myName;
        document.getElementById('p2-label').innerText = oppName;
    } else {
        // è‡ªåˆ†ï¼èµ¤(P2)
        document.getElementById('p1-label').innerText = oppName;
        document.getElementById('p2-label').innerText = myName;
    }

    document.getElementById('title-screen').style.display = 'none';
    initBoardUnits();
    resizeCanvas();
    updateTurnVisuals();
    gameLoop();
    resetTimer(); // â˜…è¿½åŠ 

    
    startOnlineListener();
}

// ç›¸æ‰‹ã®æ“ä½œã‚’å—ä¿¡ã—ã¦åæ˜ ã™ã‚‹
function startOnlineListener() {
    onValue(ref(db, roomId + "/action"), (snapshot) => {
        const action = snapshot.val();
        if (!action) return;
        
        // è‡ªåˆ†ãŒé€ã£ãŸãƒ‡ãƒ¼ã‚¿ãªã‚‰ç„¡è¦–
        if (action.sender === myPlayerId) return;

        // ç›¸æ‰‹ã®æ“ä½œã‚’å†ç¾
        if (action.type === 'SELECT_CARD') {
            uiSelectCard(action.value, true); 
        } else if (action.type === 'ROTATE') {
            state.hiddenRotation = { indices: action.indices };
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals();
            showToast("ç›¸æ‰‹ãŒå›è»¢ã‚’æ±ºã‚ã¾ã—ãŸ");
        } else if (action.type === 'MOVE') {
            state.defenderMoves = action.moves;
            startTurnResolution(); 
        } 
        /* â–¼â–¼â–¼ è¿½åŠ ï¼šã‚¨ãƒ¢ãƒ¼ãƒˆã®å—ä¿¡ â–¼â–¼â–¼ */
        else if (action.type === 'EMOTE') {
            // ç›¸æ‰‹(action.sender)ã¨ã—ã¦ã‚¨ãƒ¢ãƒ¼ãƒˆã‚’è¡¨ç¤º
            sendEmote(action.value, action.sender);
        }
        /* â–²â–²â–² è¿½åŠ ã“ã“ã¾ã§ â–²â–²â–² */
    });
}


/* â–¼â–¼â–¼ ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½ â–¼â–¼â–¼ */

// ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦é–‹å§‹ï¼ˆãƒ•ã‚§ãƒ¼ã‚ºãŒå¤‰ã‚ã‚‹ãŸã³ã«å‘¼ã¶ï¼‰
function resetTimer() {
    clearInterval(state.timerInterval);
    state.timeLeft = 30; // åˆ¶é™æ™‚é–“ï¼ˆç§’ï¼‰
    updateTimerDisplay();

    // 1ç§’ã”ã¨ã«æ¸›ã‚‰ã™
    state.timerInterval = setInterval(() => {
        state.timeLeft--;
        updateTimerDisplay();

        if (state.timeLeft <= 0) {
            clearInterval(state.timerInterval);
            handleTimeout(); // æ™‚é–“åˆ‡ã‚Œã®å‡¦ç†
        }
    }, 1000);
}

// ç”»é¢è¡¨ç¤ºã®æ›´æ–°
function updateTimerDisplay() {
    const el = document.getElementById('timer-display');
    if (!el) return;
    el.innerText = state.timeLeft;
    
    // æ®‹ã‚Š10ç§’ã‚’åˆ‡ã£ãŸã‚‰èµ¤ãã™ã‚‹
    if (state.timeLeft <= 10) {
        el.classList.add('danger');
    } else {
        el.classList.remove('danger');
    }
}

// æ™‚é–“åˆ‡ã‚Œã«ãªã£ãŸæ™‚ã®è‡ªå‹•æ“ä½œ
function handleTimeout() {
    // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã®å ´åˆã€è‡ªåˆ†ã®æ“ä½œæ‰‹ç•ªã§ãªã‘ã‚Œã°å‹æ‰‹ã«å‹•ã‹ãªã„
    if (state.gameMode === 'ONLINE') {
        const isMyTurn = (state.phase === 'DEFENDER_MOVE') 
            ? (state.turnPlayer.id !== myPlayerId) // é˜²å¾¡ãƒ•ã‚§ãƒ¼ã‚ºãªã‚‰é˜²å¾¡å´ï¼ˆï¼ã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã˜ã‚ƒãªã„æ–¹ï¼‰
            : (state.turnPlayer.id === myPlayerId); // æ”»æ’ƒãƒ•ã‚§ãƒ¼ã‚ºãªã‚‰æ”»æ’ƒå´

        if (!isMyTurn) return; // ç›¸æ‰‹ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆç›¸æ‰‹ãŒé€ä¿¡ã—ã¦ãã‚‹ã®ã‚’å¾…ã¤ï¼‰
    }
    
    // CPUæ€è€ƒä¸­ãªã‚‰ç„¡è¦–
    if (state.isCpuThinking) return;

    showToast("TIME UP!");

    // ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®å¼·åˆ¶æ“ä½œ
    if (state.phase === 'SELECT_CARD') {
        // å‹æ‰‹ã«ä¸€ç•ªå·¦ã®ã‚«ãƒ¼ãƒ‰ã‚’é¸ã¶
        uiSelectCard(2);
    } 
    else if (state.phase === 'SELECT_ROTATION') {
        // å›è»¢å¯èƒ½ãªæ–¹å‘ãŒã‚ã‚Œã°ã€æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã«æ±ºå®šã™ã‚‹
        // ãªã‘ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¦ã‚«ãƒ¼ãƒ‰é¸æŠã«æˆ»ã‚‹ï¼ˆãŒã€ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²ããŸã‚é©å½“ã«å‡¦ç†ï¼‰
        if (state.validDirections.length > 0) {
            // å¼·åˆ¶æ±ºå®š
            const valid = state.validDirections[0];
            state.hiddenRotation = { indices: valid.indices };
            
            if (state.gameMode === 'ONLINE') sendAction('ROTATE', { indices: valid.indices });
            
            state.phase = 'DEFENDER_MOVE';
            updateTurnVisuals(); // ã“ã“ã§ã‚¿ã‚¤ãƒãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹
        } else {
            // ä¸‡ãŒä¸€ç½®ã‘ãªã‹ã£ãŸã‚‰ã‚«ãƒ¼ãƒ‰é¸æŠã«æˆ»ã™
            state.phase = 'SELECT_CARD';
            resetTimer(); 
        }
    } 
    else if (state.phase === 'DEFENDER_MOVE') {
        // ç§»å‹•ã›ãšã«ç¢ºå®šã™ã‚‹
        uiConfirm();
    }
}

// è‡ªåˆ†ã®æ“ä½œã‚’é€ä¿¡ã™ã‚‹é–¢æ•°
function sendAction(type, data) {
    if (state.gameMode !== 'ONLINE') return;
    
    set(ref(db, roomId + "/action"), {
        type: type,
        sender: myPlayerId,
        ...data,
        timestamp: Date.now()
    });
}

/* â–²â–²â–² ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã“ã“ã¾ã§ â–²â–²â–² */

/* â–¼â–¼â–¼ è¿½åŠ ï¼šHTMLã®ãƒœã‚¿ãƒ³ã‹ã‚‰é–¢æ•°ã‚’å‘¼ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹è¨­å®š â–¼â–¼â–¼ */
window.startGame = startGame;
window.uiSelectCard = uiSelectCard;
window.uiConfirm = uiConfirm;
window.quitGame = quitGame;
window.backToTitle = backToTitle;
window.toggleEmoteMenu = toggleEmoteMenu;
window.sendEmote = sendEmote;

</script>
</body>
</html>
